use super::common::*;
use crate::{
    environment::{EnvQuery, Environment},
    utils::{
        has_abstract_predicate_attr, has_check_only_attr, has_prusti_attr, has_spec_only_attr,
    },
    PrustiError,
};
use log::debug;
use prusti_rustc_interface::{
    data_structures::fx::{FxHashMap, FxHashSet},
    errors::MultiSpan,
    hir::{
        self as hir,
        def_id::{DefId, LocalDefId},
        intravisit,
    },
    middle::{hir::map::Map, ty::TyCtxt},
    span::Span,
};

/// Checks for illegal predicate usages
pub struct IllegalPredicateUsagesChecker;

impl<'tcx> SpecCheckerStrategy<'tcx> for IllegalPredicateUsagesChecker {
    #[tracing::instrument(
        name = "IllegalPredicateUsagesChecker::check",
        level = "debug",
        skip(self, env)
    )]
    fn check(&self, env: &Environment<'tcx>) -> Vec<PrustiError> {
        let collected_predicates = self.collect_predicates(env.query);
        debug!("Predicate funcs: {:?}", collected_predicates.predicates);
        debug!(
            "Abstract predicates with bodies: {:?}",
            collected_predicates.abstract_predicate_with_bodies
        );
        let illegal_rtc_pred_usages =
            self.collect_illegal_predicate_usages_rtc(&collected_predicates.predicates, env.query);
        debug!(
            "Predicate usages from runtime check code: {:?}",
            illegal_rtc_pred_usages
        );

        let illegal_pred_usages =
            self.collect_illegal_predicate_usages(collected_predicates.predicates, env.query);
        debug!("Predicate usages: {:?}", illegal_pred_usages);

        // TODO: check behavioral subtyping of implemented predicates against default implementation

        let illegal_pred_usages_rtc = illegal_rtc_pred_usages.into_iter().map(|(usage_span, def_span)|{
            PrustiError::incorrect(
                "Referring to predicate that is not runtime checkable in specifications that should be runtime checked is not allowed".to_string(),
                MultiSpan::from_span(usage_span),
            ).add_note(
                "this predicate can not be checked at runtime, make sure it has a body and mark it with #[insert_runtime_check]",
                Some(def_span)
            )
        });

        let illegal_usage_errors = illegal_pred_usages
            .into_iter()
            .map(|(usage_span, def_span)| {
                PrustiError::incorrect(
                    "using predicate from non-specification code is not allowed".to_string(),
                    MultiSpan::from_span(usage_span),
                )
                .add_note(
                    "this is a specification-only predicate function",
                    Some(def_span),
                )
            })
            .chain(illegal_pred_usages_rtc);

        illegal_usage_errors.collect()
    }
}

impl IllegalPredicateUsagesChecker {
    /// Map of the `DefID`s to the `Span`s of `predicate!` functions found in the first pass.
    fn collect_predicates<'tcx>(
        &self,
        env_query: EnvQuery<'tcx>,
    ) -> CollectPredicatesVisitor<'tcx> {
        let mut collect = CollectPredicatesVisitor {
            env_query,
            predicates: FxHashMap::default(),
            abstract_predicate_with_bodies: FxHashSet::default(),
        };
        env_query.hir().walk_toplevel_module(&mut collect);
        env_query.hir().walk_attributes(&mut collect);

        collect
    }

    /// Span of use and definition of predicates used outside of specifications, collected in the second pass.
    /// Ignores calls to predicates within code generated by runtime checks
    fn collect_illegal_predicate_usages(
        &self,
        predicates: FxHashMap<DefId, (Span, bool)>,
        env_query: EnvQuery,
    ) -> Vec<(Span, Span)> {
        let mut visit = CheckPredicatesVisitor {
            env_query,
            predicates,
            pred_usages: Vec::new(),
        }
        .wrap_as_visitor();

        env_query.hir().walk_toplevel_module(&mut visit);
        env_query.hir().walk_attributes(&mut visit);

        visit.wrapped.pred_usages
    }

    /// Similar to previous check, but now we look at the code generated by runtime checks.
    /// For the predicates that are called here, we need to make sure that they are
    /// indeed runtime checkable (i.e. they have been marked with a #[check_only] attribute,
    /// which means an impelementation for them has been generated)
    fn collect_illegal_predicate_usages_rtc<'tcx>(
        &self,
        predicates: &FxHashMap<DefId, (Span, bool)>,
        env_query: EnvQuery<'tcx>,
    ) -> Vec<(Span, Span)> {
        let mut visit = RuntimeCheckablePredicatesVisitor {
            env_query,
            predicates,
            bad_usages: Vec::new(),
            within_check_code: false,
        };
        env_query.hir().visit_all_item_likes_in_crate(&mut visit);
        visit.bad_usages
    }
}

/// First predicate checks visitor: collect all function items that originate
/// from predicates
struct CollectPredicatesVisitor<'tcx> {
    env_query: EnvQuery<'tcx>,
    /// Maps from predicates to their Span + a boolean telling us whether this predicate
    /// can be checked at runtime
    predicates: FxHashMap<DefId, (Span, bool)>,
    abstract_predicate_with_bodies: FxHashSet<DefId>,
}

impl<'tcx> intravisit::Visitor<'tcx> for CollectPredicatesVisitor<'tcx> {
    type Map = Map<'tcx>;
    type NestedFilter = prusti_rustc_interface::middle::hir::nested_filter::All;

    fn nested_visit_map(&mut self) -> Self::Map {
        self.env_query.hir()
    }

    fn visit_fn(
        &mut self,
        fk: intravisit::FnKind<'tcx>,
        fd: &'tcx hir::FnDecl<'tcx>,
        b: hir::BodyId,
        s: Span,
        local_id: LocalDefId,
    ) {
        // collect this fn's DefId if predicate function
        let attrs = self.env_query.get_local_attributes(local_id);
        if has_prusti_attr(attrs, "pred_spec_id_ref") {
            let runtime_checkable = has_check_only_attr(attrs);
            let def_id = local_id.to_def_id();
            self.predicates.insert(def_id, (s, runtime_checkable));
        }

        intravisit::walk_fn(self, fk, fd, b, local_id);
    }

    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {
        let def_id = ti.owner_id.def_id.to_def_id();
        let attrs = self.env_query.get_local_attributes(ti.owner_id.def_id);

        if has_abstract_predicate_attr(attrs) {
            let span = self.env_query.get_def_span(def_id);
            self.predicates.insert(def_id, (span, false));
        } else if has_prusti_attr(attrs, "pred_spec_id_ref") {
            if let hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) = &ti.kind {
                self.abstract_predicate_with_bodies.insert(def_id);
            }
        }

        intravisit::walk_trait_item(self, ti);
    }
}

/// Second predicate checks visitor: check any references to predicate functions
/// from non-specification code
struct CheckPredicatesVisitor<'tcx> {
    env_query: EnvQuery<'tcx>,
    predicates: FxHashMap<DefId, (Span, bool)>,
    pred_usages: Vec<(Span, Span)>,
}

impl<'v, 'tcx: 'v> NonSpecExprVisitor<'tcx> for CheckPredicatesVisitor<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.env_query.tcx()
    }

    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {
        if let Some(def_id) = resolve_path(ex, self.env_query) {
            if let Some((pred_def_span, _)) = self.predicates.get(&def_id) {
                self.pred_usages.push((ex.span, *pred_def_span));
            }
        }

        if let Some(called_def_id) = resolve_impl(ex, self.env_query) {
            if let Some((pred_def_span, _)) = self.predicates.get(&called_def_id) {
                self.pred_usages.push((ex.span, *pred_def_span));
            }
        }
    }
}

fn resolve_path<'tcx>(ex: &'tcx hir::Expr<'tcx>, env_query: EnvQuery<'tcx>) -> Option<DefId> {
    let owner_def_id = ex.hir_id.owner.def_id;

    // General check: The "path" of a predicate doesn't appear anywhere
    // (e.g. as in a function call or an argument when we pass the predicate to another function)
    if let hir::ExprKind::Path(ref path) = ex.kind {
        if env_query.has_body(owner_def_id) {
            let res = env_query
                .tcx()
                .typeck(owner_def_id)
                .qpath_res(path, ex.hir_id);
            if let hir::def::Res::Def(_, def_id) = res {
                return Some(def_id);
            }
        }
    }
    None
}

fn resolve_impl<'tcx>(ex: &'tcx hir::Expr<'tcx>, env_query: EnvQuery<'tcx>) -> Option<DefId> {
    let owner_def_id = ex.hir_id.owner.def_id;
    // When we deal with predicates in impls, the above path resolving is not enough,
    // i.e. when Foo::bar is a predicate and we call `foo.bar()` on some `foo: Foo`,
    // we do not observe the called def id `bar` via path resolution.
    if env_query.has_body(owner_def_id) {
        let resolved_called_method = env_query
            .tcx()
            .typeck(owner_def_id)
            .type_dependent_def_id(ex.hir_id);
        if let Some(called_def_id) = resolved_called_method {
            if !env_query.tcx().is_constructor(called_def_id) {
                return Some(called_def_id);
            }
        }
    }
    None
}

/// This visitors purpose is to detect calls to predicates within blocks marked with
/// #[check_only] that are not actually runtime checkable (because they were not
/// marked with #[insert_runtime_check] for example)
struct RuntimeCheckablePredicatesVisitor<'tcx, 'a> {
    env_query: EnvQuery<'tcx>,
    predicates: &'a FxHashMap<DefId, (Span, bool)>,
    bad_usages: Vec<(Span, Span)>,
    within_check_code: bool,
}

impl<'tcx, 'a> intravisit::Visitor<'tcx> for RuntimeCheckablePredicatesVisitor<'tcx, 'a> {
    type Map = Map<'tcx>;
    type NestedFilter = prusti_rustc_interface::middle::hir::nested_filter::OnlyBodies;

    fn nested_visit_map(&mut self) -> Self::Map {
        self.env_query.hir()
    }

    fn visit_fn(
        &mut self,
        fk: intravisit::FnKind<'tcx>,
        fd: &'tcx hir::FnDecl<'tcx>,
        b: hir::BodyId,
        _s: Span,
        local_id: LocalDefId,
    ) {
        // for closures we still need to store this.
        let old_within_check_code = self.within_check_code;
        let tcx = self.env_query.tcx();
        let attrs = tcx.hir().attrs(tcx.local_def_id_to_hir_id(local_id));
        let check_only_attr = has_check_only_attr(attrs);
        // skip normal spec functions, but not if they are also check functions
        if has_spec_only_attr(attrs) && !check_only_attr {
            return;
        }
        // the case where the whole function was generated for runtime checks, e.g.
        // for preconditions
        if check_only_attr {
            self.within_check_code = true;
        }
        intravisit::walk_fn(self, fk, fd, b, local_id);
        self.within_check_code = old_within_check_code;
    }

    // find blocks generated for a runtime check of e.g. a prusti_assert or similar,
    fn visit_block(&mut self, block: &'tcx hir::Block<'tcx>) {
        let old_within_check_code = self.within_check_code;

        if let Some(hir::Stmt {
            kind:
                hir::StmtKind::Semi(hir::Expr {
                    kind: hir::ExprKind::Closure(hir::Closure { def_id, .. }),
                    ..
                }),
            ..
        }) = block.stmts.get(0)
        {
            // check if this def_id has a check_only attribute:
            let tcx = self.env_query.tcx();
            let attrs = tcx.hir().attrs(tcx.local_def_id_to_hir_id(*def_id));
            if has_check_only_attr(attrs) {
                // signal to members of this block that they are within code
                // generated by runtime checks
                self.within_check_code = true;
            }
        }
        intravisit::walk_block(self, block);
        self.within_check_code = old_within_check_code;
    }

    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {
        if let Some(def_id) = resolve_path(ex, self.env_query) {
            if let Some((pred_def_span, runtime_checkable)) = self.predicates.get(&def_id) {
                if !runtime_checkable && self.within_check_code {
                    self.bad_usages.push((ex.span, *pred_def_span));
                }
            }
        }

        if let Some(called_def_id) = resolve_impl(ex, self.env_query) {
            if let Some((pred_def_span, runtime_checkable)) = self.predicates.get(&called_def_id) {
                if !runtime_checkable && self.within_check_code {
                    self.bad_usages.push((ex.span, *pred_def_span));
                }
            }
        }
        intravisit::walk_expr(self, ex);
    }
}
