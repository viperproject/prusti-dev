use prusti_interface::globals;
use prusti_rustc_interface::{
    middle::{
        mir::{
            self,
            patch::MirPatch,
            visit::{self, MutVisitor},
            AssertKind,
        },
        ty::{self, TyCtxt},
    },
    span::{def_id::DefId, DUMMY_SP},
};
use rustc_hash::{FxHashMap, FxHashSet};

use crate::modify_mir::mir_helper::dummy_source_info;

pub struct DeadCodeElimination<'tcx> {
    tcx: TyCtxt<'tcx>,
    unreachable_blocks: FxHashSet<mir::BasicBlock>,
    removable_assertions: FxHashSet<mir::BasicBlock>,
}

impl<'tcx> DeadCodeElimination<'tcx> {
    pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId) -> Self {
        // collect all the blocks that were inserted but didnt generate
        // a verification error:
        let reachability_map = globals::get_reachability_map(def_id).unwrap_or_default();
        let unreachable_blocks: FxHashSet<mir::BasicBlock> = reachability_map
            .iter()
            .filter_map(|(bb, reachable)| (!reachable).then_some(*bb))
            .collect();

        let assertion_map = globals::get_assertion_map(def_id).unwrap_or_default();
        let removable_assertions: FxHashSet<mir::BasicBlock> = assertion_map
            .iter()
            .filter_map(|(bb, verified)| verified.then_some(*bb))
            .collect();
        Self {
            tcx,
            unreachable_blocks,
            removable_assertions,
        }
    }

    pub fn run(&mut self, body: &mut mir::Body<'tcx>) {
        self.remove_assertions(body);
        if self.unreachable_blocks.is_empty() {
            return;
        }
        self.visit_body(body);
    }

    fn remove_assertions(&self, body: &mut mir::Body<'tcx>) {
        let mut locals_to_replace: Vec<(mir::Local, ty::Ty<'tcx>)> = Default::default();
        for block in self.removable_assertions.iter() {
            let terminator = body.basic_blocks_mut()[*block].terminator.take().unwrap();
            if let mir::TerminatorKind::Assert {
                cond,
                msg: box kind,
                target,
                ..
            } = terminator.kind
            {
                // Assertions associated with checked operations
                if matches!(kind, AssertKind::Overflow(..) | AssertKind::OverflowNeg(_)) {
                    // this place should be of the form `_x.1` (the check field
                    // of the result of a checked operation)
                    let place = cond.place().unwrap();
                    // If generated by a checkedAdd or similar, this will be
                    // a tuple with 1 projection.
                    if place.projection.len() == 1 {
                        // figure out the type of the first field:
                        let base_place: mir::Place<'tcx> = place.local.into();
                        let ty = base_place.ty(&body.local_decls, self.tcx).ty;
                        let res_type = if let ty::TyKind::Tuple(typelist) = ty.kind() {
                            *typelist.get(0).unwrap()
                        } else {
                            unreachable!();
                        };
                        locals_to_replace.push((place.local, res_type));
                    }
                }

                // make the terminator a goto
                let new_term = mir::Terminator {
                    source_info: dummy_source_info(),
                    kind: mir::TerminatorKind::Goto { target },
                };
                body.basic_blocks_mut()[*block].terminator = Some(new_term);
            } else {
                unreachable!("Somehow mir must have been modified in a bad way between verification and here");
            }
        }
        let mut patcher = MirPatch::new(body);
        let replacements: FxHashMap<mir::Local, mir::Local> = locals_to_replace
            .into_iter()
            .map(|(local, ty)| (local, patcher.new_temp(ty, DUMMY_SP)))
            .collect();
        patcher.apply(body);

        let mut op_replacer = OperationReplacer {
            tcx: self.tcx,
            replacements,
        };
        op_replacer.visit_body(body);
    }
}

impl<'tcx> MutVisitor<'tcx> for DeadCodeElimination<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.tcx
    }

    fn visit_terminator(
        &mut self,
        terminator: &mut mir::Terminator<'tcx>,
        _location: mir::Location,
    ) {
        let new_term_opt = match &mut terminator.kind {
            mir::TerminatorKind::SwitchInt { discr, targets } => {
                // filter out unreachable blocks
                let mut targets_vec: Vec<(u128, mir::BasicBlock)> = targets
                    .iter()
                    .filter_map(|(value, bb)| {
                        (!self.unreachable_blocks.contains(&bb)).then_some((value, bb))
                    })
                    .collect();
                let otherwise_opt = if !self.unreachable_blocks.contains(&targets.otherwise()) {
                    Some(targets.otherwise())
                } else {
                    // unreachable otherwise block, take one of the
                    // targets
                    targets_vec.pop().map(|tup| tup.1)
                };
                if let Some(otherwise) = otherwise_opt {
                    if targets_vec.is_empty() {
                        Some(mir::TerminatorKind::Goto { target: otherwise })
                    } else {
                        let switch_targets =
                            mir::terminator::SwitchTargets::new(targets_vec.into_iter(), otherwise);
                        Some(mir::TerminatorKind::SwitchInt {
                            discr: discr.clone(),
                            targets: switch_targets,
                        })
                    }
                } else {
                    // if none of the targets is reachable, then this block
                    // must be unreachable itself!!
                    // make it actually unreachable?
                    Some(mir::TerminatorKind::Unreachable)
                }
            }
            // potentially perform some checks on sanity of our results.
            // E.g. a goto to a unreachable block can only come from
            // another unreachable block.
            _ => None,
        };
        if let Some(new_term) = new_term_opt {
            terminator.kind = new_term;
        }
    }
}

struct OperationReplacer<'tcx> {
    tcx: TyCtxt<'tcx>,
    replacements: FxHashMap<mir::Local, mir::Local>,
}

impl<'tcx> MutVisitor<'tcx> for OperationReplacer<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.tcx
    }

    fn visit_assign(
        &mut self,
        place: &mut mir::Place<'tcx>,
        rvalue: &mut mir::Rvalue<'tcx>,
        location: mir::Location,
    ) {
        // is rhs a checked operation?
        if let Some(replacing_local) = self.replacements.get(&place.local) {
            if let mir::Rvalue::CheckedBinaryOp(bin_op, box (op1, op2)) = rvalue {
                // replace the statement with an unchecked operation
                *place = (*replacing_local).into();
                *rvalue = mir::Rvalue::BinaryOp(*bin_op, Box::new((op1.clone(), op2.clone())));
            }
        }
        self.super_assign(place, rvalue, location);
    }

    fn visit_place(
        &mut self,
        place: &mut mir::Place<'tcx>,
        _context: visit::PlaceContext,
        _location: mir::Location,
    ) {
        if let Some(replacing_local) = self.replacements.get(&place.local) {
            // make sure this is an access to _x.0, all others should not
            // exist anymore at this point
            assert!(place.projection.len() == 1);
            if let mir::ProjectionElem::Field(id, _) = place.projection.first().unwrap() {
                if id.index() == 0 {
                    // replace the local
                    *place = mir::Place::from(*replacing_local);
                }
            }
        }
    }
}
