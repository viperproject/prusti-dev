// Insert assert!(false) for reachability analysis:

use super::super::{mir_helper::*, mir_modifications::MirModifier};
use lazy_static::lazy_static;
use prusti_interface::environment::inserted_locations_store;
use prusti_rustc_interface::{
    index::IndexVec,
    middle::{
        mir::{self, patch::MirPatch, visit::Visitor},
        ty::{self, TyCtxt},
    },
    span::{def_id::DefId, DUMMY_SP},
};
use rustc_hash::{FxHashMap, FxHashSet};
use std::{
    cell::{RefCell, RefMut},
    sync::Mutex,
};

lazy_static! {
    static ref MOVED_START_BLOCK: Mutex<FxHashMap<DefId, mir::BasicBlock>> = Default::default();
}

/// This pass inserts precondition checks at the beginning of the
/// body, and also in front of each function that is called
/// (in case they have them)
pub struct AssertionInserter<'tcx, 'a> {
    tcx: TyCtxt<'tcx>,
    /// making modifications from a Visitor often requires access
    /// to a patcher! But from the visiting methods we don't have
    /// direct access to a mutable body
    patch_opt: Option<RefCell<MirPatch<'tcx>>>,
    def_id: DefId,
    local_decls: &'a IndexVec<mir::Local, mir::LocalDecl<'tcx>>,
    random_bool_locals: FxHashMap<mir::Local, mir::BasicBlock>,
    added_assertion_blocks: FxHashSet<(mir::Local, mir::BasicBlock, mir::BasicBlock)>,
}

impl<'tcx, 'a> AssertionInserter<'tcx, 'a> {
    pub fn new(
        tcx: TyCtxt<'tcx>,
        def_id: DefId,
        local_decls: &'a IndexVec<mir::Local, mir::LocalDecl<'tcx>>,
    ) -> Self {
        Self {
            tcx,
            patch_opt: None,
            def_id,
            local_decls,
            random_bool_locals: Default::default(),
            added_assertion_blocks: Default::default(),
        }
    }
    pub fn run(&mut self, body: &mut mir::Body<'tcx>) {
        let new_start_block = prepend_dummy_block(body);
        MOVED_START_BLOCK
            .lock()
            .unwrap()
            .insert(self.def_id, new_start_block);
        self.patch_opt = Some(MirPatch::new(body).into());
        // create a boolean with value false at the very beginning of the body
        let random_bool_defid = find_random_bool_defid(self.tcx).unwrap();
        let bool_ty = self.tcx.mk_ty_from_kind(ty::TyKind::Bool);

        let mut current_target = new_start_block;
        for (bb, bb_data) in body.basic_blocks.iter_enumerated() {
            if bb == mir::START_BLOCK || bb_data.is_cleanup {
                // skip the dummy block we inserted and cleanup blocks
                continue;
            }
            let bool_temp = self.patcher().new_temp(bool_ty, DUMMY_SP);
            let assert_message = mir::AssertKind::OverflowNeg(mir::Operand::Copy(bool_temp.into()));
            (current_target, _) = self
                .create_call_block(
                    random_bool_defid,
                    vec![],
                    &ty::List::empty(),
                    Some(bool_temp.into()),
                    Some(current_target),
                )
                .unwrap();
            // move the terminator to a new block
            let new_block_data = mir::BasicBlockData::new(bb_data.terminator.clone());
            let new_block = self.patcher().new_block(new_block_data);
            let assert_term = mir::TerminatorKind::Assert {
                cond: mir::Operand::Copy(bool_temp.into()),
                expected: true,
                msg: Box::new(assert_message),
                target: new_block,
                unwind: mir::UnwindAction::Continue,
            };
            let terminator_location = mir::Location {
                block: bb,
                statement_index: bb_data.statements.len(),
            };
            inserted_locations_store::add_location(self.def_id, terminator_location);

            self.patcher().patch_terminator(bb, assert_term);
        }
        // finally point the first block to our random_bool_chain:
        self.patcher().patch_terminator(
            mir::START_BLOCK,
            mir::TerminatorKind::Goto {
                target: current_target,
            },
        );
        let patch_ref = self.patch_opt.take().unwrap();
        patch_ref.into_inner().apply(body);
    }

    pub fn undo_insertions(&mut self, body: &mut mir::Body<'tcx>) {
        let moved_start_block = *MOVED_START_BLOCK.lock().unwrap().get(&self.def_id).unwrap();
        self.visit_body(body);
        // only remove the blocks with assertions who's operands are
        // generated by a random_bool call, because those are definitely
        // not user generated
        for (local, bb, target) in self.added_assertion_blocks.iter() {
            if self.random_bool_locals.get(local).is_none() {
                // skip it if the local was not generated by random_bool call
                continue;
            }
            let terminator = body.basic_blocks[*target].terminator.clone();
            body.basic_blocks_mut()[*bb].terminator = terminator;
        }
        // we don't actually remove the inserted blocks, but just make them
        // unreachable.
        // Make first block point to moved start block
        if let Some(mir::Terminator {
            kind: mir::TerminatorKind::Goto { target, .. },
            ..
        }) = &mut body.basic_blocks_mut()[mir::START_BLOCK].terminator
        {
            *target = moved_start_block;
        }
    }
}

impl<'tcx, 'a> Visitor<'tcx> for AssertionInserter<'tcx, 'a> {
    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: mir::Location) {
        match &terminator.kind {
            mir::TerminatorKind::Call {
                func, destination, ..
            } => {
                if let Some((call_id, _)) = func.const_fn_def() {
                    let item_name = self.tcx.def_path_str(call_id);
                    if &item_name[..] == "prusti_contracts::random_bool" {
                        self.random_bool_locals
                            .insert(destination.local, location.block);
                    }
                }
            }
            // this sort of assertion with a boolean condition can not
            // be crated by a User (would make zero sense at least)
            // so we should not eliminate blocks generated by original code
            mir::TerminatorKind::Assert {
                cond: mir::Operand::Copy(place),
                msg: box mir::AssertKind::OverflowNeg(_),
                target,
                ..
            } => {
                self.added_assertion_blocks
                    .insert((place.local, location.block, *target));
            }
            _ => {}
        }
        self.super_terminator(terminator, location);
    }
}

impl<'tcx, 'a> MirModifier<'tcx> for AssertionInserter<'tcx, 'a> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.tcx
    }
    fn patcher(&self) -> RefMut<MirPatch<'tcx>> {
        self.patch_opt
            .as_ref()
            .expect("Bug: MirPatch for inserting assertions was not initialized")
            .borrow_mut()
    }

    fn def_id(&self) -> DefId {
        self.def_id
    }

    fn local_decls(&self) -> &'a IndexVec<mir::Local, mir::LocalDecl<'tcx>> {
        self.local_decls
    }
}
