use crate::encoder::{
    errors::{SpannedEncodingError, SpannedEncodingResult},
    middle::core_proof::{lowerer::FunctionsLowererInterface, snapshots::IntoSnapshot},
};
use vir_crate::{
    common::identifier::WithIdentifier, low as vir_low, low::operations::ToLowLowerer,
    middle as vir_mid,
};

impl<'p, 'v: 'p, 'tcx: 'v> ToLowLowerer for super::super::lowerer::Lowerer<'p, 'v, 'tcx> {
    type Error = SpannedEncodingError;

    fn to_low_expression_downcast(
        &mut self,
        _variant: vir_mid::expression::Downcast,
    ) -> SpannedEncodingResult<vir_low::Expression> {
        todo!()
    }

    fn to_low_func_app(
        &mut self,
        app: vir_mid::expression::FuncApp,
    ) -> SpannedEncodingResult<vir_low::expression::FuncApp> {
        let function_name = app.get_identifier();
        let arguments = self.to_low_vec_expression(app.arguments)?;
        let return_type = self.to_low_type(app.return_type)?;
        let position = self.to_low_position(app.position)?;
        let func_app = self.create_func_app(function_name, arguments, return_type, position)?;
        Ok(func_app)
    }

    fn to_low_expression_builtin_func_app(
        &mut self,
        _app: vir_mid::expression::BuiltinFuncApp,
    ) -> SpannedEncodingResult<vir_low::expression::Expression> {
        todo!()
    }

    fn to_low_position(
        &mut self,
        position: vir_mid::Position,
    ) -> SpannedEncodingResult<vir_low::Position> {
        Ok(position)
    }

    fn to_low_variable_decl(
        &mut self,
        decl: vir_mid::VariableDecl,
    ) -> SpannedEncodingResult<vir_low::VariableDecl> {
        Ok(vir_low::VariableDecl {
            name: decl.name,
            ty: self.to_low_type(decl.ty)?,
        })
    }

    fn to_low_type(&mut self, ty: vir_mid::Type) -> SpannedEncodingResult<vir_low::Type> {
        ty.create_snapshot(self)
    }

    fn to_low_constant(
        &mut self,
        value: vir_mid::Constant,
    ) -> SpannedEncodingResult<vir_low::expression::Constant> {
        let low_type = match value.ty {
            vir_mid::Type::MBool => vir_low::Type::Bool,
            vir_mid::Type::MInt => vir_low::Type::Int,
            vir_mid::Type::MFloat32 => unimplemented!(),
            vir_mid::Type::MFloat64 => unimplemented!(),
            vir_mid::Type::Bool => vir_low::Type::Bool,
            vir_mid::Type::Int(_) => vir_low::Type::Int,
            _ => unimplemented!("constant: {:?}", value),
        };
        Ok(vir_low::expression::Constant {
            value: self.to_low_constant_value(value.value)?,
            ty: low_type,
            position: self.to_low_position(value.position)?,
        })
    }

    fn to_low_labelled_old(
        &mut self,
        expression: vir_mid::expression::LabelledOld,
    ) -> Result<vir_low::expression::LabelledOld, Self::Error> {
        Ok(vir_low::expression::LabelledOld {
            label: Some(expression.label),
            base: Box::new(self.to_low_expression(*expression.base)?),
            position: self.to_low_position(expression.position)?,
        })
    }

    fn to_low_constant_value_fn_ptr(
        &mut self,
    ) -> Result<vir_low::expression::ConstantValue, Self::Error> {
        todo!()
    }

    fn to_low_expression_addr_of(
        &mut self,
        _expression: vir_mid::expression::AddrOf,
    ) -> Result<vir_low::Expression, Self::Error> {
        todo!()
    }

    fn to_low_expression_deref(
        &mut self,
        _expression: vir_mid::expression::Deref,
    ) -> Result<vir_low::Expression, Self::Error> {
        todo!()
    }

    fn to_low_field_decl(
        &mut self,
        _field: vir_mid::FieldDecl,
    ) -> Result<vir_low::FieldDecl, Self::Error> {
        todo!()
    }

    fn to_low_expression_variant(
        &mut self,
        _expression: vir_mid::expression::Variant,
    ) -> Result<vir_low::Expression, Self::Error> {
        todo!()
    }

    fn to_low_expression_constructor(
        &mut self,
        _expression: vir_mid::expression::Constructor,
    ) -> Result<vir_low::Expression, Self::Error> {
        todo!()
    }

    fn to_low_constant_value_float(
        &mut self,
        _variant: vir_mid::expression::FloatConst,
    ) -> Result<vir_low::expression::ConstantValue, Self::Error> {
        todo!()
    }
}
