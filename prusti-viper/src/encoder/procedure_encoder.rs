// Â© 2019, ETH Zurich
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// TODO: Remove this and fix.
#![allow(deprecated)]

use encoder::borrows::ProcedureContract;
use encoder::builtin_encoder::BuiltinMethodKind;
use encoder::Encoder;
use encoder::error_manager::ErrorCtxt;
use encoder::error_manager::PanicCause;
use encoder::foldunfold;
use encoder::optimiser;
use encoder::loop_encoder::LoopEncoder;
use encoder::places::{Local, LocalVariableManager, Place};
use encoder::spec_encoder::SpecEncoder;
use encoder::vir::{self, CfgBlockIndex, Successor};
use encoder::vir::ExprIterator;
use encoder::vir::optimisations;
use prusti_interface::config;
use prusti_interface::data::ProcedureDefId;
use prusti_interface::environment::BasicBlockIndex;
use prusti_interface::environment::Procedure;
use prusti_interface::environment::PermissionKind;
use prusti_interface::environment::polonius_info::{LoanPlaces, PoloniusInfo};
use prusti_interface::environment::polonius_info::{ReborrowingZombity, ReborrowingGuard, ReborrowingDAG, ReborrowingDAGNode, ReborrowingForest, ReborrowingTree, ReborrowingNode, ReborrowingKind, ReborrowingBranching};
use prusti_interface::environment::borrowck::{facts};
use prusti_interface::report::log;
use rustc::hir::Mutability;
use rustc::middle::const_val::ConstVal;
use rustc::mir;
use rustc::mir::TerminatorKind;
use rustc::ty;
use rustc_data_structures::indexed_vec::Idx;
use std::collections::HashMap;
use std::collections::HashSet;
use syntax::codemap::{Span, MultiSpan};
use prusti_interface::specifications::*;
use syntax::ast;
use encoder::mir_encoder::MirEncoder;
use encoder::mir_encoder::{PRECONDITION_LABEL, POSTCONDITION_LABEL};
use encoder::initialisation::InitInfo;
use prusti_interface::utils::get_attr_value;
use rustc::ty::layout;
use rustc::ty::layout::IntegerExt;
use syntax::attr::SignedInt;
use encoder::vir::fixes::fix_ghost_vars;
use encoder::vir::optimisations::methods::{remove_unused_vars, remove_trivial_assertions};
use utils::to_string::ToString;

pub struct ProcedureEncoder<'p, 'v: 'p, 'r: 'v, 'a: 'r, 'tcx: 'a> {
    encoder: &'p Encoder<'v, 'r, 'a, 'tcx>,
    proc_def_id: ProcedureDefId,
    procedure: &'p Procedure<'a, 'tcx>,
    mir: &'p mir::Mir<'tcx>,
    cfg_method: vir::CfgMethod,
    locals: LocalVariableManager<'tcx>,
    loop_encoder: LoopEncoder<'p, 'tcx>,
    auxiliar_local_vars: HashMap<String, vir::Type>,
    mir_encoder: MirEncoder<'p, 'v, 'r, 'a, 'tcx>,
    check_panics: bool,
    check_fold_unfold_state: bool,
    polonius_info: PoloniusInfo<'p, 'tcx>,
    label_after_location: HashMap<mir::Location, String>,
    /// Contains the boolean local variables that became `true` the first time the block is executed
    cfg_block_has_been_executed: HashMap<mir::BasicBlock, vir::LocalVar>,
    /// Magic wand generated by a call at a given location with a label used in post.
    magic_wand_at_location: HashMap<mir::Location, (String, vir::Expr, vir::Expr)>,
    /// Statements that should be performed after applying the given magic wand.
    magic_wand_apply_post: HashMap<mir::Location, Vec<vir::Stmt>>,
    /// Contracts of functions called at given locations with map for replacing fake expressions.
    procedure_contracts: HashMap<mir::Location, (ProcedureContract<'tcx>, HashMap<vir::Expr, vir::Expr>)>,
    /// Mapping from MIR basic block indices to VIR basic block indices.
    mir_to_vir_blocks: HashMap<BasicBlockIndex, vir::CfgBlockIndex>,
    /// A map that stores local variables used to preserve the value of a place accross the loop
    /// when we cannot do that by using permissions.
    pure_var_for_preserving_value_map: HashMap<BasicBlockIndex, HashMap<vir::Expr, vir::LocalVar>>,
    /// Information about which places are definitely initialised.
    init_info: InitInfo,
    /// Mapping from old expressions to ghost variables with which they were replaced.
    old_to_ghost_var: HashMap<vir::Expr, vir::Expr>,
    /// Ghost variables used inside package statements.
    old_ghost_vars: HashMap<String, vir::Type>,
}

impl<'p, 'v: 'p, 'r: 'v, 'a: 'r, 'tcx: 'a> ProcedureEncoder<'p, 'v, 'r, 'a, 'tcx> {
    pub fn new(encoder: &'p Encoder<'v, 'r, 'a, 'tcx>, procedure: &'p Procedure<'a, 'tcx>) -> Self {
        debug!("ProcedureEncoder constructor");

        let mir = procedure.get_mir();
        let def_id = procedure.get_id();
        let tcx = encoder.env().tcx();
        let mir_encoder = MirEncoder::new(encoder, mir, def_id);
        let init_info = InitInfo::new(mir, tcx, def_id, &mir_encoder);

        let cfg_method = vir::CfgMethod::new(
            // method name
            encoder.encode_item_name(def_id),
            // formal args
            vec![],
            // formal returns
            vec![],
            // local vars
            vec![],
            // reserved labels
            vec![],
        );

        ProcedureEncoder {
            encoder,
            proc_def_id: def_id,
            procedure,
            mir,
            cfg_method,
            locals: LocalVariableManager::new(&mir.local_decls),
            loop_encoder: LoopEncoder::new(mir, tcx, def_id),
            auxiliar_local_vars: HashMap::new(),
            mir_encoder: mir_encoder,
            check_panics: config::check_panics(),
            check_fold_unfold_state: config::check_foldunfold_state(),
            polonius_info: PoloniusInfo::new(procedure),
            label_after_location: HashMap::new(),
            cfg_block_has_been_executed: HashMap::new(),
            magic_wand_at_location: HashMap::new(),
            magic_wand_apply_post: HashMap::new(),
            procedure_contracts: HashMap::new(),
            mir_to_vir_blocks: HashMap::new(),
            pure_var_for_preserving_value_map: HashMap::new(),
            init_info: init_info,
            old_to_ghost_var: HashMap::new(),
            old_ghost_vars: HashMap::new(),
        }
    }

    pub fn encode_name(&self) -> String {
        self.cfg_method.name()
    }

    pub fn encode(mut self) -> vir::CfgMethod {
        trace!("Encode procedure {}", self.cfg_method.name());

        let mut procedure_contract = self.encoder.get_procedure_contract_for_def(self.proc_def_id);

        debug!("procedure_contract: {:?}", &procedure_contract);
        //trace!("def_id of proc: {:?}", &self.proc_def_id);
        let impl_def_id = self.encoder.env().tcx().impl_of_method(self.proc_def_id);
        //trace!("def_id of impl: {:?}", &impl_def_id);
        if let Some(id) = impl_def_id {
            let def_id_trait = self.encoder.env().tcx().trait_id_of_impl(id);
            //trace!("def_id of trait: {:?}", &def_id_trait);
            if let Some(id) = def_id_trait {
                let proc_name = self.encoder.env().tcx().item_name(self.proc_def_id).to_string();
                //trace!("proc_name: {:?}", proc_name);
                let assoc_items: Vec<_> = self.encoder.env().tcx().associated_items(id).collect();
                //trace!("assoc items: {:?}", &assoc_items);
                if procedure_contract.functional_precondition().len() != 0 ||
                    procedure_contract.functional_postcondition().len() != 0 {
                    unimplemented!("Refinement of trait specifications is not supported.");
                }
                for assoc_item in assoc_items {
                    if assoc_item.name == proc_name {
                        // TODO use the impl's specs if there are any (separately replace pre/post!)
                        //error!("found: {:?}", &assoc_item);

                        procedure_contract = self.encoder.get_procedure_contract_for_def(assoc_item.def_id);
                        //error!("new procedure contract: {:?}", &procedure_contract);
                    }
                }
            }
        }

        // Formal return
        for local in self.mir.local_decls.indices().take(1) {
            let name = self.mir_encoder.encode_local_var_name(local);
            let type_name = self.encoder.encode_type_predicate_use(self.mir_encoder.get_local_ty(local));
            self.cfg_method.add_formal_return(&name, vir::Type::TypedRef(type_name))
        }

        let mut cfg_edges: HashMap<BasicBlockIndex, HashMap<BasicBlockIndex, CfgBlockIndex>> = HashMap::new();

        // Initialize CFG blocks
        let start_cfg_block = self.cfg_method.add_block("start", vec![], vec![
            vir::Stmt::comment("========== start =========="),
            vir::Stmt::comment(format!("Name: {:?}", self.procedure.get_name())),
            vir::Stmt::comment(format!("Def path: {:?}", self.procedure.get_def_path())),
            vir::Stmt::comment(format!("Span: {:?}", self.procedure.get_span())),
        ]);

        for bbi in self.procedure.get_reachable_cfg_blocks() {
            let cfg_block = self.cfg_method.add_block(&format!("{:?}", bbi), vec![], vec![
                vir::Stmt::comment(format!("========== {:?} ==========", bbi))
            ]);
            self.mir_to_vir_blocks.insert(bbi, cfg_block);
        }

        for bbi in self.procedure.get_reachable_cfg_blocks() {
            let mut cfg_successors: HashMap<BasicBlockIndex, CfgBlockIndex> = HashMap::new();
            for bbi_successor in self.procedure.successors(bbi) {
                if self.procedure.is_reachable_block(bbi_successor) {
                    let cfg_edge = self.cfg_method.add_block(&format!("{:?}_{:?}", bbi, bbi_successor), vec![], vec![
                        vir::Stmt::comment(format!("========== {:?} --> {:?} ==========", bbi, bbi_successor))
                    ]);
                    self.cfg_method.set_successor(
                        cfg_edge,
                        Successor::Goto(self.mir_to_vir_blocks[&bbi_successor]));
                    cfg_successors.insert(bbi_successor, cfg_edge);
                }
            }
            cfg_edges.insert(bbi, cfg_successors);
        }

        let return_cfg_block = self.cfg_method.add_block("return", vec![], vec![
            vir::Stmt::comment(format!("========== return ==========")),
            vir::Stmt::comment("Target of any 'return' statement."),
        ]);
        self.cfg_method.set_successor(return_cfg_block, Successor::Return);

        // Set the first CFG block
        self.cfg_method.set_successor(
            start_cfg_block,
            Successor::Goto(
                *self.mir_to_vir_blocks
                    .get(&self.procedure.get_first_cfg_block())
                    .unwrap_or(&return_cfg_block)
            )
        );

        // Encode a flag that becomes true the first time the block is executed
        for bbi in self.procedure.get_reachable_cfg_blocks() {
            let executed_flag_var = self.cfg_method.add_fresh_local_var(vir::Type::Bool);
            let bb_pos = self.mir_encoder.encode_expr_pos(self.mir_encoder.get_span_of_basic_block(bbi));
            self.cfg_method.add_stmt(
                start_cfg_block,
                vir::Stmt::Assign(vir::Expr::local(executed_flag_var.clone()).set_pos(bb_pos), false.into(), vir::AssignKind::Copy)
            );
            self.cfg_block_has_been_executed.insert(bbi, executed_flag_var);
        }

        // Encode preconditions
        self.encode_preconditions(start_cfg_block, &mut procedure_contract);

        // Encode postcondition
        self.encode_postconditions(return_cfg_block, &mut procedure_contract);

        // Encode statements
        for bbi in self.procedure.get_reachable_cfg_blocks() {
            let bb_data = &self.mir.basic_blocks()[bbi];
            let cfg_block = *self.mir_to_vir_blocks.get(&bbi).unwrap();
            let bb_pos = self.mir_encoder.encode_expr_pos(self.mir_encoder.get_span_of_basic_block(bbi));

            // Store a flag that becomes true the first time the block is executed
            let executed_flag_var = self.cfg_block_has_been_executed[&bbi].clone();
            self.cfg_method.add_stmt(
                cfg_block,
                vir::Stmt::Assign(vir::Expr::local(executed_flag_var).set_pos(bb_pos), true.into(), vir::AssignKind::Copy)
            );

            // Inhale the loop invariant if this is a loop head
            if self.loop_encoder.is_loop_head(bbi) {
                for (successor, cfg_successor) in &cfg_edges[&bbi] {
                    let after_loop = self.loop_encoder.get_loop_head(*successor) != Some(bbi);
                    let stmts = self.encode_loop_invariant_inhale(bbi, after_loop);
                    for stmt in stmts.iter() {
                        self.cfg_method.add_stmt(*cfg_successor, stmt.clone());
                    }
                }
            }

            // Encode statements of the block, if this is not a "spec" block
            if !self.procedure.is_spec_block(bbi) {
                if self.loop_encoder.is_loop_head(bbi) {
                    for cfg_successor in cfg_edges[&bbi].values() {
                        self.encode_block_statements(bbi, *cfg_successor);
                    }
                } else {
                    self.encode_block_statements(bbi, cfg_block);
                }
            } else {
                // Any spec block must be unreachable
                self.cfg_method.add_stmt(
                    cfg_block,
                    vir::Stmt::comment("Unreachable block, used for type-checking specifications")
                );
                self.cfg_method.add_stmt(
                    cfg_block,
                    vir::Stmt::Assert(false.into(), vir::Position::default())
                );
            }

            // Encode terminators and set CFG edges
            if let Some(ref term) = bb_data.terminator {
                trace!("Encode terminator of {:?}", bbi);
                let cfg_block = *self.mir_to_vir_blocks.get(&bbi).unwrap();
                self.cfg_method.add_stmt(cfg_block, vir::Stmt::comment(format!("[mir] {:?}", term.kind)));
                let location = mir::Location {
                    block: bbi,
                    statement_index: bb_data.statements.len()
                };
                let (stmts, successor) = self.encode_terminator(
                    term,
                    location,
                    cfg_edges.get(&bbi).expect(&format!("CFG block {:?} has no entry in 'cfg_edges'", bbi)),
                    return_cfg_block,
                    &mut procedure_contract
                );
                if self.loop_encoder.is_loop_head(bbi) {
                    for cfg_successor in cfg_edges[&bbi].values() {
                        for stmt in stmts.iter() {
                            self.cfg_method.add_stmt(*cfg_successor, stmt.clone());
                        }
                    }
                    match successor {
                        Successor::GotoSwitch(cfg_targets, cfg_default_target) => {
                            let mut new_cfg_targets = Vec::new();
                            let mut default_condition_conjuncts = Vec::new();
                            for (expr, cfg_target) in cfg_targets {

                                // Make the jump non-deterministic.
                                let new_local = self.cfg_method.add_fresh_local_var(vir::Type::Bool);
                                new_cfg_targets.push((new_local.into(), cfg_target));

                                // Assume the condition under which the jump happened.
                                let stmt = vir::Stmt::Inhale(expr.clone());
                                default_condition_conjuncts.push(expr);
                                self.cfg_method.add_stmt(cfg_target, stmt);
                            }
                            let default_condition = vir::Expr::UnaryOp(
                                vir::UnaryOpKind::Not,
                                box default_condition_conjuncts.into_iter().conjoin(),
                                vir::Position::default(),
                            );
                            let stmt = vir::Stmt::Inhale(default_condition);
                            self.cfg_method.add_stmt(cfg_default_target, stmt);
                            let new_successor = Successor::GotoSwitch(
                                new_cfg_targets, cfg_default_target);
                            self.cfg_method.set_successor(cfg_block, new_successor);
                        },
                        Successor::Goto(cfg_target) => {
                            let new_successor = Successor::Goto(cfg_target);
                            self.cfg_method.set_successor(cfg_block, new_successor);
                        },
                        x => unreachable!("{:?}", x),
                    }
                } else {
                    for stmt in stmts.into_iter() {
                        self.cfg_method.add_stmt(cfg_block, stmt);
                    }
                    if successor != vir::Successor::Return {
                        for successor in self.procedure.successors(bbi) {
                            if self.procedure.is_reachable_block(successor) {
                                let succ_location = mir::Location {
                                    block: successor,
                                    statement_index: 0
                                };
                                let cfg_edge_block = cfg_edges[&bbi][&successor];
                                for stmt in self.encode_expiring_borrows_between(
                                        location, succ_location).drain(..) {
                                    self.cfg_method.add_stmt(cfg_edge_block, stmt);
                                }
                            }
                        }
                    }
                    self.cfg_method.set_successor(cfg_block, successor);
                }
            }

            // Exhale the loop invariant if the successor is a loop head
            // Add an `BeginFrame` statement if the outgoing edge is an *in* edge
            for successor in self.procedure.successors(bbi) {
                if self.loop_encoder.is_loop_head(successor) {
                    let cfg_edge_block = cfg_edges[&bbi][&successor];
                    let after_loop_iteration = self.loop_encoder.get_loop_head(bbi) == Some(successor);
                    let stmts = self.encode_loop_invariant_exhale(successor, after_loop_iteration);
                    for stmt in stmts.into_iter() {
                        self.cfg_method.add_stmt(cfg_edge_block, stmt);
                    }
                    let is_edge_in_loop = self.loop_encoder.get_loop_depth(successor) > self.loop_encoder.get_loop_depth(bbi);
                    if is_edge_in_loop {
                        self.cfg_method.add_stmt(cfg_edge_block, vir::Stmt::BeginFrame);
                    }
                }
            }
        }

        let local_vars: Vec<_> = self.locals
            .iter()
            .filter(|local| !self.locals.is_return(*local))
            .collect();
        for local in local_vars.iter() {
            let local_ty = self.locals.get_type(*local);
            if let ty::TypeVariants::TyClosure(..) = local_ty.sty {
                // Do not encode closures
                continue;
            }
            let type_name = self.encoder.encode_type_predicate_use(local_ty);
            let var_name = self.locals.get_name(*local);
            self.cfg_method.add_local_var(&var_name, vir::Type::TypedRef(type_name));
        }

        /*
        // Keep a copy of the value of the variable (fixes issue #20)
        let formal_args: Vec<_> = self.locals
            .iter()
            .filter(|local| self.locals.is_formal_arg(self.mir, *local))
            .collect();
        for local in formal_args.iter() {
            let local_ty = self.locals.get_type(*local);
            if let ty::TypeVariants::TyClosure(..) = local_ty.sty {
                // Do not encode closures
                continue;
            }
            let type_name = self.encoder.encode_type_predicate_use(local_ty);
            let var_name = self.locals.get_name(*local);
            let old_var_name = format!("_old{}", var_name);
            let var_type = vir::Type::TypedRef(type_name.clone());
            let old_var_type = vir::Type::TypedRef(type_name.clone());
            let local_var = vir::LocalVar::new(var_name.clone(), var_type);
            let old_local_var = vir::LocalVar::new(old_var_name.clone(), old_var_type.clone());
            self.cfg_method.add_local_var(&old_var_name, old_var_type);
            let init_old = vir::Stmt::Inhale(
                vir::Expr::eq_cmp(
                    old_local_var.into(),
                    local_var.into()
                )
            );
            self.cfg_method.add_stmt(start_cfg_block, init_old);
        }
        */

        /*
        // Fix evaluation of arguments in old states (see issue #20)
        for local in self.mir.local_decls.indices() {
            let local_var = self.mir_encoder.encode_local(local);
            let old_var_name = format!("_old{}", local_var.name);
            let old_local_var = vir::LocalVar::new(old_var_name, local_var.typ.clone());
            trace!("replace {} --> {}", local_var, old_local_var);
            let local_var_ref: &vir::Expr = &local_var.into();
            let old_local_var_ref: &vir::Expr = &old_local_var.into();
            self.cfg_method.substitute_expr(
                |expr| expr.map_old_expr(
                    |label, old_expr| {
                        if label == PRECONDITION_LABEL {
                            old_expr.replace_place(local_var_ref, old_local_var_ref.clone())
                        } else {
                            // See issue #20 "Evaluation of arguments in old expressions"
                            debug!("local variables may be evaluated in the wrong state");
                            old_expr
                        }
                    }
                )
            );
        }
        */

        self.check_vir();
        let method_name = self.cfg_method.name();
        let source_path = self.encoder.env().source_path();
        let source_filename = source_path.file_name().unwrap().to_str().unwrap();

        self.encoder.log_vir_program_before_foldunfold(self.cfg_method.to_string());

        // Dump initial CFG
        if config::dump_debug_info() {
            log::report_with_writer("graphviz_method_before_foldunfold", format!("{}.{}.dot", source_filename, method_name), |writer| self.cfg_method.to_graphviz(writer));
        }

        // Add fold/unfold
        let loan_positions = self.polonius_info
            .loan_locations()
            .into_iter()
            .map(|(loan, mir_location)| {
                let vir_basic_block = self.mir_to_vir_blocks[&mir_location.block];
                (loan, vir_basic_block)
            })
            .collect();
        let method_with_fold_unfold = foldunfold::add_fold_unfold(
            self.encoder, self.cfg_method, loan_positions);

        // Fix variable declarations.
        let fixed_method = fix_ghost_vars(method_with_fold_unfold);

        // Optimise encoding a bit
        let method_without_unused_vars = remove_unused_vars(fixed_method);
        let method_without_trivial_assertions = remove_trivial_assertions(method_without_unused_vars);
        let final_method = optimiser::rewrite(method_without_trivial_assertions);

        // Dump final CFG
        if config::dump_debug_info() {
            log::report_with_writer("graphviz_method_before_viper", format!("{}.{}.dot", source_filename, method_name), |writer| final_method.to_graphviz(writer));
        }

        final_method
    }

    fn encode_block_statements(&mut self, bbi: BasicBlockIndex, cfg_block: CfgBlockIndex) {
        let bb_data = &self.mir.basic_blocks()[bbi];
        let statements: &Vec<mir::Statement<'tcx>> = &bb_data.statements;
        let is_panic_block = self.procedure.is_panic_block(bbi);
        for (stmt_index, stmt) in statements.iter().enumerate() {
            trace!("Encode statement {:?}:{}", bbi, stmt_index);
            self.cfg_method.add_stmt(cfg_block, vir::Stmt::comment(format!("[mir] {:?}", stmt)));
            let location = mir::Location {
                block: bbi,
                statement_index: stmt_index
            };
            if !is_panic_block {
                for stmt in self.encode_statement(stmt, location).drain(..) {
                    self.cfg_method.add_stmt(cfg_block, stmt);
                }
            }
            for stmt in self.encode_expiring_borrows_at(location).drain(..) {
                self.cfg_method.add_stmt(cfg_block, stmt);
            }
        }
    }

    fn encode_statement(&mut self, stmt: &mir::Statement<'tcx>, location: mir::Location) -> Vec<vir::Stmt> {
        debug!("Encode statement '{:?}', span: {:?}", stmt.kind, stmt.source_info.span);

        let stmts = match stmt.kind {
            mir::StatementKind::StorageDead(_) |
            mir::StatementKind::StorageLive(_) |
            mir::StatementKind::EndRegion(_) |
            mir::StatementKind::ReadForMatch(_) |
            mir::StatementKind::UserAssertTy(_, _) |
            mir::StatementKind::Nop => vec![],

            mir::StatementKind::Assign(ref lhs, ref rhs) => {
                let (encoded_lhs, ty, _) = self.mir_encoder.encode_place(lhs);
                let type_name = self.encoder.encode_type_predicate_use(ty);
                match rhs {
                    &mir::Rvalue::Use(ref operand) => {
                        self.encode_assign_operand(&encoded_lhs, operand, location)
                    }
                    &mir::Rvalue::Aggregate(ref aggregate, ref operands) => {
                        self.encode_assign_aggregate(&encoded_lhs, ty, aggregate, operands, location)
                    }
                    &mir::Rvalue::BinaryOp(op, ref left, ref right) => {
                        self.encode_assign_binary_op(op, left, right, encoded_lhs, ty, location)
                    }
                    &mir::Rvalue::CheckedBinaryOp(op, ref left, ref right) => {
                        self.encode_assign_checked_binary_op(
                            op, left, right, encoded_lhs, ty, location)
                    }
                    &mir::Rvalue::UnaryOp(op, ref operand) => {
                        self.encode_assign_unary_op(op, operand, encoded_lhs, ty, location)
                    }
                    &mir::Rvalue::NullaryOp(op, ref op_ty) => {
                        self.encode_assign_nullary_op(op, op_ty, encoded_lhs, ty, location)
                    }
                    &mir::Rvalue::Discriminant(ref src) => {
                        self.encode_assign_discriminant(src, location, encoded_lhs, ty)
                    }
                    &mir::Rvalue::Ref(ref _region, mir_borrow_kind, ref place) => {
                        self.encode_assign_ref(mir_borrow_kind, place, location, encoded_lhs, ty)
                    }
                    &mir::Rvalue::Cast(mir::CastKind::Misc, ref operand, dst_ty) => {
                        self.encode_cast(operand, dst_ty, encoded_lhs, ty, location)
                    }
                    ref rhs => {
                        unimplemented!("encoding of '{:?}'", rhs);
                    }
                }
            }

            ref x => unimplemented!("{:?}", x)
        };
        stmts
            .into_iter()
            .map(|s| {
                let expr_pos = self.encoder.error_manager().register(
                    stmt.source_info.span, ErrorCtxt::GenericExpression);
                let stmt_pos = self.encoder.error_manager().register(
                    stmt.source_info.span, ErrorCtxt::GenericStatement);
                s.set_default_expr_pos(
                    expr_pos
                ).set_default_pos(
                    stmt_pos
                )
            }
        ).collect()
    }

    /// Translate a borrowed place to a place that is currently usable
    fn translate_maybe_borrowed_place(&self, location: mir::Location, place: vir::Expr) -> vir::Expr {
        let (all_active_loans, _) = self.polonius_info.get_all_active_loans(location);
        let relevant_active_loan_places: Vec<_> = all_active_loans
            .iter()
            .flat_map(|p| self.polonius_info.get_loan_places(p))
            .filter(|loan_places| {
                let (_, encoded_source, _) = self.encode_loan_places(loan_places);
                place.has_prefix(&encoded_source)
            })
            .collect();
        if relevant_active_loan_places.len() == 1 {
            let loan_places = &relevant_active_loan_places[0];
            let (encoded_dest, encoded_source, _) = self.encode_loan_places(loan_places);
            // Recursive translation
            self.translate_maybe_borrowed_place(
                loan_places.location,
                place.replace_place(&encoded_source, &encoded_dest)
            )
        } else {
            place
        }
    }

    /// Encode the lhs and the rhs of the assignment that create the loan
    fn encode_loan_places(
        &self,
        loan_places: &LoanPlaces<'tcx>
    ) -> (vir::Expr, vir::Expr, bool) {
        debug!("encode_loan_rvalue '{:?}'", loan_places);
        let (expiring_base, expiring_ty, _) = self.mir_encoder.encode_place(&loan_places.dest);
        let encode = |rhs_place| {
            let (restored, _, _) = self.mir_encoder.encode_place(rhs_place);
            let ref_field = self.encoder.encode_value_field(expiring_ty);
            let expiring = expiring_base.clone().field(ref_field.clone());
            (expiring, restored, ref_field)
        };
        match loan_places.source {
            mir::Rvalue::Ref(_, mir_borrow_kind, ref rhs_place) => {
                let (expiring, restored, _) = encode(rhs_place);
                assert_eq!(expiring.get_type(), restored.get_type());
                let is_mut = match mir_borrow_kind {
                    mir::BorrowKind::Shared => false,
                    mir::BorrowKind::Unique => unimplemented!(),
                    mir::BorrowKind::Mut { .. } => true,
                };
                (expiring, restored, is_mut)
            }
            mir::Rvalue::Use(mir::Operand::Move(ref rhs_place)) => {
                let (expiring, restored_base, ref_field) = encode(rhs_place);
                let restored = restored_base.clone().field(ref_field);
                assert_eq!(expiring.get_type(), restored.get_type());
                (expiring, restored, true)
            }
            mir::Rvalue::Use(mir::Operand::Copy(ref rhs_place)) => {
                let (expiring, restored_base, ref_field) = encode(rhs_place);
                let restored = restored_base.clone().field(ref_field);
                assert_eq!(expiring.get_type(), restored.get_type());
                (expiring, restored, false)
            }

            ref x => unreachable!("Borrow restores rvalue {:?}", x)
        }
    }

    fn encode_transfer_permissions(
        &mut self,
        lhs: vir::Expr,
        rhs: vir::Expr,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        let mut stmts = if let Some(var) = self.old_to_ghost_var.get(&rhs) {
            vec![vir::Stmt::Assign(var.clone(), lhs.clone(), vir::AssignKind::Move)]
        } else {
            vec![vir::Stmt::TransferPerm(lhs.clone(), rhs.clone(), false)]
        };

        if self.check_fold_unfold_state {
            let pos = self.encoder.error_manager().register(
                self.mir.source_info(location).span,
                ErrorCtxt::Unexpected
            );
            stmts.push(
                vir::Stmt::Assert(
                    vir::Expr::eq_cmp(
                        lhs.clone().into(),
                        rhs.into()
                    ),
                    pos
                )
            );
        }


        stmts
    }

    fn encode_obtain(&mut self, expr: vir::Expr) -> Vec<vir::Stmt> {
        let mut stmts = vec![];

        stmts.push(
            vir::Stmt::Obtain(expr.clone())
        );

        if self.check_fold_unfold_state {
            let pos = self.encoder.error_manager().register(
                // TODO: use a better span
                self.mir.span,
                ErrorCtxt::Unexpected
            );
            stmts.push(
                vir::Stmt::Assert(
                    expr,
                    pos
                )
            );
        }

        stmts
    }

    /// A borrow is mutable if it was a MIR unique borrow, a move of
    /// a borrow, or a argument of a function.
    fn is_mutable_borrow(&self, location: mir::Location) -> bool {
        let mir::BasicBlockData { ref statements, .. } = self.mir[location.block];
        if location.statement_index == statements.len() {
            // It is not an assignment, so we assume that the borrow is mutable.
            true
        } else {
            let statement = &statements[location.statement_index];
            match statement.kind {
                mir::StatementKind::Assign(ref _lhs, ref rhs) => {
                    match rhs {
                        &mir::Rvalue::Ref(_, mir::BorrowKind::Shared, _) |
                        &mir::Rvalue::Use(mir::Operand::Copy(_)) => {
                            false
                        }
                        &mir::Rvalue::Ref(_, mir::BorrowKind::Mut { .. }, _) |
                        &mir::Rvalue::Use(mir::Operand::Move(_)) => {
                            true
                        }
                        x => unreachable!("{:?}", x),
                    }
                },
                ref x => unreachable!("{:?}", x),
            }
        }
    }

    fn construct_vir_reborrowing_dag(
        &mut self,
        loans: &[facts::Loan],
        zombie_loans: &[facts::Loan],
        location: mir::Location,
        end_location: Option<mir::Location>,
    ) -> vir::borrows::DAG {
        let mir_dag = self.polonius_info.construct_reborrowing_dag(
            &loans, &zombie_loans, location);
        debug!("construct_vir_reborrowing_dag mir_dag={}", mir_dag.to_string());
        let mut builder = vir::borrows::DAGBuilder::new();
        for node in mir_dag.iter() {
            let node = match node.kind {
                ReborrowingKind::Assignment { loan } => {
                    self.construct_vir_reborrowing_node_for_assignment(
                        &mir_dag, loan, node, location, end_location)
                }
                ReborrowingKind::Call { loan, .. } => {
                    self.construct_vir_reborrowing_node_for_call(&mir_dag, loan, node, location)
                }
                ReborrowingKind::ArgumentMove { loan } => {
                    let loan_location = self.polonius_info.get_loan_location(&loan);
                    let guard = self.construct_location_guard(loan_location);
                    vir::borrows::Node::new(
                        guard, node.loan,
                        node.reborrowing_loans.clone(), node.reborrowed_loans.clone(),
                        Vec::new(), Vec::new(), Vec::new(), Vec::new(), None,
                    )
                }
                ref x => unimplemented!("{:?}", x)
            };
            builder.add_node(node);
        }
        debug!("construct_vir_reborrowing_dag mir_dag={}", mir_dag.to_string());
        builder.finish()
    }

    fn construct_location_guard(&self, location: mir::Location) -> vir::Expr {
        let bbi = &location.block;
        let executed_flag_var = self.cfg_block_has_been_executed[bbi].clone();
        vir::Expr::local(executed_flag_var).into()
    }

    fn construct_vir_reborrowing_node_for_assignment(
        &mut self,
        mir_dag: &ReborrowingDAG,
        loan: facts::Loan,
        node: &ReborrowingDAGNode,
        location: mir::Location,
        end_location: Option<mir::Location>,
    ) -> vir::borrows::Node {
        let mut stmts: Vec<vir::Stmt> = Vec::new();
        let node_is_leaf = node.reborrowed_loans.is_empty();

        let loan_location = self.polonius_info.get_loan_location(&loan);
        let loan_places = self.polonius_info.get_loan_places(&loan).unwrap();
        let (expiring, restored, is_mut) = self.encode_loan_places(&loan_places);
        let borrowed_places = vec![restored.clone()];

        let mut used_lhs_label = false;

        // Move the permissions from the "in loans" ("reborrowing loans") to the current loan
        if node.incoming_zombies {
            let lhs_label = self.label_after_location.get(&loan_location).cloned().expect(
                &format!(
                    "No label has been saved for location {:?} ({:?})",
                    loan_location,
                    self.label_after_location
                )
            );
            for &in_loan in node.reborrowing_loans.iter() {
                let in_location = self.polonius_info.get_loan_location(&in_loan);
                let in_node = mir_dag.get_node(in_loan);
                let in_label = self.label_after_location.get(&in_location).cloned().expect(
                    &format!(
                        "No label has been saved for location {:?} ({:?})",
                        in_location,
                        self.label_after_location
                    )
                );
                if self.is_mutable_borrow(in_location) {
                    used_lhs_label = true;
                    stmts.extend(
                        self.encode_transfer_permissions(
                            expiring.clone().old(&in_label),
                            expiring.clone().old(&lhs_label),
                            loan_location
                        )
                    );
                }
            }
        }

        let lhs_place = if used_lhs_label {
            let lhs_label = self.label_after_location.get(&loan_location).expect(
                &format!(
                    "No label has been saved for location {:?} ({:?})",
                    loan_location,
                    self.label_after_location
                )
            );
            expiring.clone().old(lhs_label)
        } else {
            expiring.clone()
        };
        let rhs_place = match node.zombity {
            ReborrowingZombity::Zombie(rhs_location) if !node_is_leaf => {
                let rhs_label = self.label_after_location.get(&rhs_location).expect(
                    &format!(
                        "No label has been saved for location {:?} ({:?})",
                        rhs_location,
                        self.label_after_location
                    )
                );
                restored.clone().old(rhs_label)
            }

            _ => {
                restored
            }
        };

        if is_mut {
            stmts.extend(
                self.encode_transfer_permissions(
                    lhs_place.clone(),
                    rhs_place,
                    loan_location
                )
            );
        }

        let conflicting_loans = self.polonius_info.get_conflicting_loans(node.loan);
        let deaf_location = if let Some(end_location) = end_location {
            end_location
        } else {
            location
        };
        let alive_conflicting_loans = self.polonius_info.get_alive_conflicting_loans(
            node.loan, deaf_location);

        let guard = self.construct_location_guard(loan_location);
        vir::borrows::Node::new(
            guard, node.loan,
            node.reborrowing_loans.clone(), node.reborrowed_loans.clone(),
            stmts, borrowed_places, conflicting_loans, alive_conflicting_loans,
            Some(lhs_place.clone()))
    }

    fn construct_vir_reborrowing_node_for_call(
        &mut self,
        mir_dag: &ReborrowingDAG,
        loan: facts::Loan,
        node: &ReborrowingDAGNode,
        location: mir::Location
    ) -> vir::borrows::Node {

        let mut stmts: Vec<vir::Stmt> = Vec::new();

        let loan_location = self.polonius_info.get_loan_location(&loan);

        // Get the borrow information.
        let (contract, fake_exprs) = self.procedure_contracts[&loan_location].clone();
        let replace_fake_exprs = |mut expr: vir::Expr| -> vir::Expr {
            for (fake_arg, arg_expr) in fake_exprs.iter() {
                expr = expr.replace_place(&fake_arg, arg_expr);
            }
            expr
        };
        let borrow_infos = &contract.borrow_infos;
        assert_eq!(borrow_infos.len(), 1,
                   "We can have at most one magic wand in the postcondition.");
        let borrow_info = &borrow_infos[0];

        // Get the magic wand info.
        let (post_label, lhs, rhs) = self.magic_wand_at_location
            .get(&loan_location)
            .cloned()
            .map(|(post_label, lhs, rhs)| {
                let lhs = self.replace_old_places_with_ghost_vars(None, lhs);
                let rhs = self.replace_old_places_with_ghost_vars(None, rhs);
                (post_label, lhs, rhs)
            })
            .unwrap();

        // Obtain the LHS permission.
        for (path, _) in &borrow_info.blocking_paths {
            let (encoded_place, _, _) = self.encode_generic_place(path);
            let encoded_place = replace_fake_exprs(encoded_place);

            // Move the permissions from the "in loans" ("reborrowing loans") to the current loan
            if node.incoming_zombies {
                let lhs_label = self.label_after_location.get(&loan_location).cloned().expect(
                    &format!(
                        "No label has been saved for location {:?} ({:?})",
                        loan_location,
                        self.label_after_location
                    )
                );
                for &in_loan in node.reborrowing_loans.iter() {
                    let in_location = self.polonius_info.get_loan_location(&in_loan);
                    let in_node = mir_dag.get_node(in_loan);
                    let in_label = self.label_after_location.get(&in_location).cloned().expect(
                        &format!(
                            "No label has been saved for location {:?} ({:?})",
                            in_location,
                            self.label_after_location
                        )
                    );
                    stmts.extend(
                        self.encode_transfer_permissions(
                            encoded_place.clone().old(&in_label),
                            encoded_place.clone().old(&post_label),
                            loan_location
                        )
                    );
                }
            }
            if !node.incoming_zombies || node.reborrowing_loans.is_empty() {
                stmts.extend(
                    self.encode_transfer_permissions(
                        encoded_place.clone(),
                        encoded_place.old(&post_label),
                        loan_location
                    )
                );
            }
        }


        let pos = self.encoder.error_manager().register(
            //self.mir.span,
            // TODO change to where the loan expires?
            self.mir.source_info(loan_location).span, // the source of the ref
            ErrorCtxt::ApplyMagicWandOnExpiry
        );
        // Inhale the magic wand.
        let magic_wand = vir::Expr::MagicWand(
            box lhs.clone(), box rhs.clone(), Some(loan), pos.clone());
        stmts.push(vir::Stmt::Inhale(magic_wand));
        // Emit the apply statement.
        let statement = vir::Stmt::apply_magic_wand(lhs, rhs, loan, pos);
        debug!("{:?} at {:?}", statement, loan_location);
        stmts.push(statement);

        // Fix the permissions on rhs.
        if let Some(post_stmts) = self.magic_wand_apply_post.get(&loan_location) {
            stmts.extend(post_stmts.iter().cloned());
        }

        let guard = self.construct_location_guard(loan_location);
        vir::borrows::Node::new(
            guard, node.loan,
            node.reborrowing_loans.clone(), node.reborrowed_loans.clone(),
            stmts, Vec::new(), Vec::new(), Vec::new(), None)
    }

    fn encode_expiration_of_loans(
        &mut self,
        loans: Vec<facts::Loan>,
        zombie_loans: &[facts::Loan],
        location: mir::Location,
        end_location: Option<mir::Location>,
    ) -> Vec<vir::Stmt> {
        trace!("encode_expiration_of_loans '{:?}' '{:?}'", loans, zombie_loans);
        let mut stmts: Vec<vir::Stmt> = vec![];
        if loans.len() > 0 {
            let vir_reborrowing_dag = self.construct_vir_reborrowing_dag(
                &loans, &zombie_loans, location, end_location);
            stmts.push(vir::Stmt::ExpireBorrows(vir_reborrowing_dag));
        }
        stmts
    }

    fn encode_expiring_borrows_between(&mut self, begin_loc: mir::Location, end_loc: mir::Location) -> Vec<vir::Stmt> {
        debug!("encode_expiring_borrows_beteewn '{:?}' '{:?}'", begin_loc, end_loc);
        let (all_dying_loans, zombie_loans) = self.polonius_info.get_all_loans_dying_between(begin_loc, end_loc);
        // FIXME: is 'end_loc' correct here? What about 'begin_loc'?
        self.encode_expiration_of_loans(all_dying_loans, &zombie_loans, begin_loc, Some(end_loc))
    }

    fn encode_expiring_borrows_before(&mut self, location: mir::Location) -> Vec<vir::Stmt> {
        debug!("encode_expiring_borrows_before '{:?}'", location);
        let (all_dying_loans, zombie_loans) = self.polonius_info.get_all_loans_dying_before(location);
        self.encode_expiration_of_loans(all_dying_loans, &zombie_loans, location, None)
    }

    fn encode_expiring_borrows_at(&mut self, location: mir::Location) -> Vec<vir::Stmt> {
        debug!("encode_expiring_borrows_at '{:?}'", location);
        let (all_dying_loans, zombie_loans) = self.polonius_info.get_all_loans_dying_at(location);
        self.encode_expiration_of_loans(all_dying_loans, &zombie_loans, location, None)
    }

    fn encode_terminator(&mut self,
                         term: &mir::Terminator<'tcx>,
                         location: mir::Location,
                         cfg_blocks: &HashMap<BasicBlockIndex, CfgBlockIndex>,
                         return_cfg_block: CfgBlockIndex,
                         contract: &ProcedureContract<'tcx>) -> (Vec<vir::Stmt>, Successor) {
        debug!("Encode terminator '{:?}', span: {:?}", term.kind, term.source_info.span);
        let mut stmts: Vec<vir::Stmt> = vec![];

        match term.kind {
            TerminatorKind::Return => {

                // Package magic wands, if there is any
                stmts.extend(
                    self.encode_package_end_of_method(
                        contract, PRECONDITION_LABEL, POSTCONDITION_LABEL, location)
                );

                (stmts, Successor::Goto(return_cfg_block))
            }

            TerminatorKind::Goto { target } => {
                let target_cfg_block = cfg_blocks.get(&target).unwrap();
                (stmts, Successor::Goto(*target_cfg_block))
            }

            TerminatorKind::SwitchInt { ref targets, ref discr, ref values, switch_ty } => {
                trace!("SwitchInt ty '{:?}', discr '{:?}', values '{:?}'", switch_ty, discr, values);
                let mut cfg_targets: Vec<(vir::Expr, CfgBlockIndex)> = vec![];

                // Use a local variable for the discriminant (see issue #57)
                let discr_var = match switch_ty.sty {
                    ty::TypeVariants::TyBool => {
                        self.cfg_method.add_fresh_local_var(vir::Type::Bool)
                    }

                    ty::TypeVariants::TyInt(_) |
                    ty::TypeVariants::TyUint(_) |
                    ty::TypeVariants::TyChar => {
                        self.cfg_method.add_fresh_local_var(vir::Type::Int)
                    }

                    ref x => unreachable!("{:?}", x)
                };
                let encoded_discr = self.mir_encoder.encode_operand_expr(discr);
                stmts.push(
                    vir::Stmt::Assign(
                        discr_var.clone().into(),
                        if encoded_discr.is_place() {
                            self.translate_maybe_borrowed_place(location, encoded_discr)
                        } else{
                            encoded_discr
                        },
                        vir::AssignKind::Copy
                    )
                );

                for (i, &value) in values.iter().enumerate() {
                    let target = targets[i as usize];
                    // Convert int to bool, if required
                    let viper_guard = match switch_ty.sty {
                        ty::TypeVariants::TyBool => {
                            if value == 0 {
                                // If discr is 0 (false)
                                vir::Expr::not(discr_var.clone().into())
                            } else {
                                // If discr is not 0 (true)
                                discr_var.clone().into()
                            }
                        }

                        ty::TypeVariants::TyInt(_) |
                        ty::TypeVariants::TyUint(_) |
                        ty::TypeVariants::TyChar => {
                            vir::Expr::eq_cmp(
                                discr_var.clone().into(),
                                self.encoder.encode_int_cast(value, switch_ty)
                            )
                        }

                        ref x => unreachable!("{:?}", x)
                    };
                    let target_cfg_block = cfg_blocks.get(&target).unwrap();
                    cfg_targets.push((viper_guard, *target_cfg_block))
                }
                let default_target = targets[values.len()];
                let cfg_default_target = if let Some(cfg_target) =
                        cfg_blocks.get(&default_target) {
                    *cfg_target
                } else {
                    // Prepare a block that encodes the unreachable branch
                    assert!(
                        if let mir::TerminatorKind::Unreachable = self.mir[default_target].terminator.as_ref().unwrap().kind {
                            true
                        } else {
                            false
                        }
                    );
                    let unreachable_label = self.cfg_method.get_fresh_label_name();
                    let unreachable_block = self.cfg_method.add_block(&unreachable_label, vec![], vec![
                        vir::Stmt::comment(format!("========== {} ==========", &unreachable_label)),
                        vir::Stmt::comment(format!("Block marked as 'unreachable' by the compiler")),
                    ]);
                    // Asserting `false` here does not work. See issue #158
                    //if config::check_unreachable_terminators() {
                    //    let pos = self.encoder.error_manager().register(
                    //        term.source_info.span,
                    //        ErrorCtxt::UnreachableTerminator
                    //    );
                    //    self.cfg_method.add_stmt(
                    //        unreachable_block,
                    //        vir::Stmt::Assert(false.into(), pos)
                    //    );
                    //}
                    self.cfg_method.set_successor(unreachable_block, Successor::Return);
                    unreachable_block
                };

                (stmts, Successor::GotoSwitch(cfg_targets, cfg_default_target))
            }

            TerminatorKind::Unreachable => {
                // Asserting `false` here does not work. See issue #158
                //let pos = self.encoder.error_manager().register(
                //    term.source_info.span,
                //    ErrorCtxt::UnreachableTerminator
                //);
                //stmts.push(
                //    vir::Stmt::Inhale(false.into())
                //);
                (stmts, Successor::Return)
            }

            TerminatorKind::Abort => {
                let pos = self.encoder.error_manager().register(
                    term.source_info.span,
                    ErrorCtxt::AbortTerminator
                );
                stmts.push(
                    vir::Stmt::Assert(false.into(), pos)
                );
                (stmts, Successor::Return)
            }

            TerminatorKind::Drop { ref target, .. } => {
                let target_cfg_block = cfg_blocks.get(&target).unwrap();
                (stmts, Successor::Goto(*target_cfg_block))
            }

            TerminatorKind::FalseEdges { ref real_target, .. } => {
                let target_cfg_block = cfg_blocks.get(&real_target).unwrap();
                (stmts, Successor::Goto(*target_cfg_block))
            }

            TerminatorKind::FalseUnwind { ref real_target, .. } => {
                let target_cfg_block = cfg_blocks.get(&real_target).unwrap();
                (stmts, Successor::Goto(*target_cfg_block))
            }

            TerminatorKind::DropAndReplace { ref target, location: ref lhs, ref value, .. } => {
                let (encoded_lhs, _, _) = self.mir_encoder.encode_place(lhs);
                stmts.extend(
                    self.encode_assign_operand(&encoded_lhs, value, location)
                );
                let target_cfg_block = cfg_blocks.get(&target).unwrap();
                (stmts, Successor::Goto(*target_cfg_block))
            }

            TerminatorKind::Call {
                ref args,
                ref destination,
                func: mir::Operand::Constant(
                    box mir::Constant {
                        literal: mir::Literal::Value {
                            value: ty::Const {
                                ty: &ty::TyS {
                                    sty: ty::TyFnDef(def_id, substs),
                                    ..
                                },
                                ..
                            }
                        },
                        ..
                    }
                ),
                ..
            } => {
                let func_proc_name: &str = &self.encoder.env().tcx().absolute_item_path_str(def_id);

                let own_substs = ty::subst::Substs::identity_for_item(self.encoder.env().tcx(), def_id);

                {
                    // FIXME; hideous monstrosity...
                    let mut tymap_stack = self.encoder.typaram_repl.borrow_mut();
                    let mut tymap = HashMap::new();

                    for (kind1, kind2) in own_substs.iter().zip(substs) {
                        if let (ty::subst::UnpackedKind::Type(ty1), ty::subst::UnpackedKind::Type(ty2)) =
                                (kind1.unpack(), kind2.unpack()) {
                            tymap.insert(ty1, ty2);
                        }
                    }
                    tymap_stack.push(tymap);
                }

                match func_proc_name {
                    "std::rt::begin_panic" |
                    "std::panicking::begin_panic" => {
                        // This is called when a Rust assertion fails
                        // args[0]: message
                        // args[1]: position of failing assertions

                        // Example of args[0]: 'const "internal error: entered unreachable code"'
                        let panic_message = format!("{:?}", args[0]);

                        // Pattern match on the macro that generated the panic
                        // TODO: use a better approach to match macros
                        let macro_backtrace = term.source_info.span.macro_backtrace();
                        debug!("macro_backtrace: {:?}", macro_backtrace);

                        let panic_cause = if !macro_backtrace.is_empty() {
                            let macro_name = term.source_info.span.macro_backtrace()[0].macro_decl_name.clone();
                            // HACK to match the filename of the span
                            let def_site_span = format!("{:?}", term.source_info.span.macro_backtrace()[0].def_site_span);

                            match macro_name.as_str() {
                                "panic!" if def_site_span.contains("<panic macros>") => {
                                    if macro_backtrace.len() > 1 {
                                        let second_macro_name = term.source_info.span.macro_backtrace()[1].macro_decl_name.clone();
                                        // HACK to match the filename of the span
                                        let second_def_site_span = format!("{:?}", term.source_info.span.macro_backtrace()[1].def_site_span);

                                        match second_macro_name.as_str() {
                                            "panic!" if second_def_site_span.contains("<panic macros>") => PanicCause::Panic,
                                            "assert!" if second_def_site_span == "None" => PanicCause::Assert,
                                            "unreachable!" if second_def_site_span.contains("<unreachable macros>") => PanicCause::Unreachable,
                                            "unimplemented!" if second_def_site_span.contains("<unimplemented macros>") => PanicCause::Unimplemented,
                                            _ => PanicCause::Panic
                                        }
                                    } else {
                                        PanicCause::Panic
                                    }
                                }
                                _ => PanicCause::Unknown
                            }
                        } else {
                            // Something else called panic!()
                            PanicCause::Unknown
                        };
                        let pos = self.encoder.error_manager().register(
                            term.source_info.span,
                            ErrorCtxt::Panic(panic_cause)
                        );

                        if self.check_panics {
                            stmts.push(vir::Stmt::comment(format!("Rust panic - {}", panic_message)));
                            stmts.push(vir::Stmt::Assert(false.into(), pos));
                        } else {
                            debug!("Absence of panic will not be checked")
                        }
                    }

                    "<std::boxed::Box<T>>::new" => {
                        // This is the initialization of a box
                        // args[0]: value to put in the box
                        assert_eq!(args.len(), 1);

                        let &(ref target_place, _) = destination.as_ref().unwrap();
                        let (dst, dest_ty, _) = self.mir_encoder.encode_place(target_place);
                        let boxed_ty = dest_ty.boxed_ty();
                        let ref_field = self.encoder.encode_dereference_field(boxed_ty);

                        let box_content = dst.clone().field(ref_field.clone());

                        stmts.extend(
                            self.prepare_assign_target(
                                dst, ref_field, location, vir::AssignKind::Move)
                        );

                        // Allocate `box_content`
                        stmts.extend(
                            self.encode_havoc_and_allocation(&box_content)
                        );

                        // Initialize `box_content`
                        stmts.extend(
                            self.encode_assign_operand(&box_content, &args[0], location)
                        );
                    }

                    _ => {
                        let is_pure_function = self.encoder.env().has_attribute_name(def_id, "pure");
                        if is_pure_function {
                            let function_name = self.encoder.encode_pure_function_use(def_id);
                            debug!("Encoding pure function call '{}'", function_name);
                            assert!(destination.is_some());

                            let mut arg_exprs = vec![];
                            for operand in args.iter() {
                                let arg_expr = self.mir_encoder.encode_operand_expr(operand);
                                arg_exprs.push(arg_expr);
                            }

                            let return_type = self.encoder.encode_pure_function_return_type(def_id);
                            let formal_args: Vec<vir::LocalVar> = args
                                .iter()
                                .enumerate()
                                .map(
                                    |(i, arg)|
                                        vir::LocalVar::new(
                                            format!("x{}", i),
                                            self.mir_encoder.encode_operand_expr_type(arg)
                                        )
                                ).collect();

                            let pos = self.encoder.error_manager().register(
                                term.source_info.span,
                                ErrorCtxt::PureFunctionCall
                            );
                            let func_call = vir::Expr::func_app(
                                function_name,
                                arg_exprs,
                                formal_args,
                                return_type,
                                pos
                            );

                            let label = self.cfg_method.get_fresh_label_name();
                            stmts.push(vir::Stmt::Label(label.clone()));

                            // Havoc the content of the lhs
                            let (target_place, target_ty, _) = match destination.as_ref() {
                                Some((ref dst, _)) => self.mir_encoder.encode_place(dst),
                                None => unreachable!()
                            };
                            stmts.extend(self.encode_havoc(&target_place));
                            let type_predicate = self.mir_encoder.encode_place_predicate_permission(
                                target_place.clone(), vir::PermAmount::Write).unwrap();
                            stmts.push(vir::Stmt::Inhale(type_predicate));

                            // Initialize the lhs
                            let target_value = match destination.as_ref() {
                                Some((ref dst, _)) => self.mir_encoder.eval_place(dst),
                                None => unreachable!()
                            };
                            stmts.push(
                                vir::Stmt::Inhale(
                                    vir::Expr::eq_cmp(
                                        target_value.into(),
                                        func_call
                                    )
                                )
                            );

                            // Store a label for permissions got back from the call
                            debug!("Pure function call location {:?} has label {}", location, label);
                            self.label_after_location.insert(location, label.clone());

                            // Transfer the permissions for the arguments used in the call
                            for operand in args.iter() {
                                let operand_ty = self.mir_encoder.get_operand_ty(operand);
                                let operand_place = self.mir_encoder.encode_operand_place(operand);
                                match (operand_place, &operand_ty.sty) {
                                    (Some(ref place), ty::TypeVariants::TyRawPtr(ty::TypeAndMut { ty: ref inner_ty, .. })) |
                                    (Some(ref place), ty::TypeVariants::TyRef(_, ref inner_ty, _)) => {
                                        let ref_field = self.encoder.encode_dereference_field(inner_ty);
                                        let ref_place = place.clone().field(ref_field);
                                        stmts.extend(
                                            self.encode_transfer_permissions(
                                                ref_place.clone(),
                                                ref_place.clone().old(&label),
                                                location
                                            )
                                        );
                                    }
                                    _ => {} // Nothing
                                }
                            }

                            /*
                            // Hack to work around the missing loan for arguments moved to the function call
                            for operand in args.iter() {
                                if let Some(place) = self.mir_encoder.encode_operand_place(operand) {
                                    debug!("Put permission {:?} in postcondition", place);
                                    // Choose the label that corresponds to the creation of the loan
                                    let (loans, _) = self.polonius_info.get_all_active_loans(location);
                                    let source_loans: Vec<_> = loans.iter().filter(|loan| {
                                        let loan_places = self.polonius_info.get_loan_places(loan).unwrap();
                                        let (expiring, _, restored) = self.encode_loan_places(&loan_places);
                                        trace!("Try {:?} == {:?} | {:?}", expiring, place, restored);
                                        expiring.parent() == Some(&place)
                                    }).collect();
                                    if !source_loans.is_empty() {
                                        assert_eq!(source_loans.len(), 1, "The argument depends on a condition");
                                        let source_loan = &source_loans[0];
                                        let loan_loc = self.polonius_info.get_loan_location(&source_loan);
                                        let loan_label = &self.label_after_location[&loan_loc];
                                        stmts.push(vir::Stmt::TransferPerm(
                                            place.clone(),
                                            place.clone().old(&loan_label)
                                        ));
                                    }
                                }
                            }
                            */

                        } else {
                            debug!("Encoding non-pure function call '{}'", func_proc_name);
                            let mut stmts_after: Vec<vir::Stmt> = vec![];
                            let mut fake_exprs: HashMap<vir::Expr, vir::Expr> = HashMap::new();
                            let mut fake_vars = vec![];
                            let mut const_arg_vars: HashSet<vir::Expr> = HashSet::new();
                            let mut type_invs: HashMap<String, vir::Function> = HashMap::new();
                            let mut constant_args = Vec::new();

                            for operand in args.iter() {
                                let arg_ty = self.mir_encoder.get_operand_ty(operand);
                                let fake_arg = self.locals.get_fresh(arg_ty);
                                fake_vars.push(fake_arg.clone());
                                let encoded_local = self.encode_prusti_local(fake_arg);
                                let fake_arg_place = vir::Expr::local(encoded_local);
                                debug!("fake_arg: {:?} {}", fake_arg, fake_arg_place);
                                let inv_name = self.encoder.encode_type_invariant_use(arg_ty);
                                let arg_inv = self.encoder.encode_type_invariant_def(arg_ty);
                                type_invs.insert(inv_name, arg_inv);
                                match self.mir_encoder.encode_operand_place(operand) {
                                    Some(place) => {
                                        debug!("fake_arg: {} {}", fake_arg_place, place);
                                        fake_exprs.insert(fake_arg_place, place.into());
                                    }
                                    None => {
                                        // We have a constant.
                                        constant_args.push(fake_arg_place.clone());
                                        let arg_val_expr = self.mir_encoder.encode_operand_expr(operand);
                                        debug!("arg_val_expr: {} {}", fake_arg_place, arg_val_expr);
                                        let val_field = self.encoder.encode_value_field(arg_ty);
                                        fake_exprs.insert(
                                            fake_arg_place.clone().field(val_field),
                                            arg_val_expr);
                                        let in_loop = self.loop_encoder.get_loop_depth(location.block) > 0;
                                        if in_loop {
                                            const_arg_vars.insert(fake_arg_place);
                                            warn!("Please use a local variable as argument for function call '{}', and not a constant.", func_proc_name);
                                        }
                                    }
                                }
                            }

                            let (fake_target_local, real_target) = {
                                match destination.as_ref() {
                                    Some((ref target_place, _)) => {
                                        let (encoded_dst, ty, _) = self.mir_encoder.encode_place(target_place);
                                        let fake_target = self.locals.get_fresh(ty);
                                        fake_exprs.insert(
                                            vir::Expr::local(self.encode_prusti_local(fake_target)),
                                            encoded_dst.clone().into()
                                        );
                                        (fake_target, Some(encoded_dst))
                                    }
                                    None => {
                                        // The return type is Never
                                        // This means that the function call never returns
                                        // So, we `assume false` after the function call
                                        stmts_after.push(vir::Stmt::Inhale(false.into()));
                                        // Return a dummy local variable
                                        let never_ty = self.encoder.env().tcx().mk_ty(
                                            ty::TypeVariants::TyNever
                                        );
                                        (self.locals.get_fresh(never_ty), None)
                                    }
                                }
                            };

                            let replace_fake_exprs = |mut expr: vir::Expr| -> vir::Expr {
                                for (fake_arg, arg_expr) in fake_exprs.iter() {
                                    expr = expr.fold_expr(|orig_expr| {
                                        // Inline or skip usages of constant parameters
                                        // See issue #85
                                        match orig_expr {
                                            vir::Expr::FuncApp(ref name, ref args, _, _, _) => {
                                                if args.len() == 1 && args[0].is_local() && const_arg_vars.contains(&args[0]) {
                                                    // Inline type invariant
                                                    type_invs[name].inline_body(args.clone())
                                                } else {
                                                    orig_expr
                                                }
                                            }
                                            vir::Expr::PredicateAccessPredicate(_, ref arg, _, _) => {
                                                if arg.is_local() && const_arg_vars.contains(arg) {
                                                    // Skip predicate permission
                                                    true.into()
                                                } else {
                                                    orig_expr
                                                }
                                            }

                                            x => x
                                        }
                                    }).replace_place(&fake_arg, arg_expr);
                                }
                                expr
                            };

                            let procedure_contract = {
                                self.encoder.get_procedure_contract_for_call(
                                    def_id, &fake_vars, fake_target_local)
                            };

                            // Store a label for the pre state
                            let pre_label = self.cfg_method.get_fresh_label_name();
                            stmts.push(vir::Stmt::Label(pre_label.clone()));

                            // Havoc and inhale variables that store constants
                            for constant_arg in &constant_args {
                                stmts.extend(self.encode_havoc_and_allocation(constant_arg));
                            }

                            // Encode precondition.
                            let (pre_type_spec, pre_mandatory_type_spec, pre_invs_spec, pre_func_spec) =
                                self.encode_precondition_expr(&procedure_contract);
                            let pos = self.encoder.error_manager().register(
                                term.source_info.span,
                                ErrorCtxt::ExhaleMethodPrecondition
                            );
                            stmts.push(vir::Stmt::Assert(replace_fake_exprs(pre_func_spec), pos.clone()));
                            stmts.push(vir::Stmt::Assert(replace_fake_exprs(pre_invs_spec), pos.clone()));
                            let pre_perm_spec = replace_fake_exprs(pre_type_spec.clone());
                            stmts.push(vir::Stmt::Exhale(pre_perm_spec.remove_read_permissions(), pos.clone()));

                            // Move all read permissions that are taken by magic wands into pre
                            // state and exhale only before the magic wands are inhaled. In this
                            // way we can have specifications that link shared reference arguments
                            // and shared reference result.
                            let pre_mandatory_perms: Vec<_> = pre_mandatory_type_spec
                                .into_iter()
                                .map(&replace_fake_exprs)
                                .collect();
                            let mut pre_mandatory_perms_old = Vec::new();
                            for perm in pre_mandatory_perms {
                                let from_place = perm.get_place().unwrap().clone();
                                let to_place = from_place.clone().old(pre_label.clone());
                                let old_perm = perm.replace_place(&from_place, &to_place);
                                stmts.push(vir::Stmt::TransferPerm(from_place, to_place, true));
                                pre_mandatory_perms_old.push(old_perm);
                            }
                            let pre_mandatory_perm_spec = pre_mandatory_perms_old.into_iter().conjoin();

                            // Havoc the content of the lhs, if there is one
                            if let Some(ref target_place) = real_target {
                                stmts.extend(self.encode_havoc(target_place));
                            }

                            // Store a label for permissions got back from the call
                            debug!("Procedure call location {:?} has label {}", location, pre_label);
                            self.label_after_location.insert(location, pre_label.clone());

                            // Store a label for the post state
                            let post_label = self.cfg_method.get_fresh_label_name();

                            let loan = self.polonius_info.get_call_loan_at_location(location);
                            let (post_type_spec, return_type_spec, post_invs_spec,
                                 post_func_spec, magic_wands, read_transfer) =
                                self.encode_postcondition_expr(
                                    &procedure_contract, &pre_label, &post_label,
                                    Some((location, &fake_exprs)), real_target.is_none(), loan, false);
                            // We inhale the magic wand just before applying it because we need
                            // a magic wand that depends on the current value of ghost variables.
                            let _magic_wands: Vec<_> = magic_wands
                                .into_iter()
                                .map(|magic_wand| {
                                    self.replace_old_places_with_ghost_vars(
                                        Some(&post_label), magic_wand)
                                })
                                .collect();

                            let post_perm_spec = replace_fake_exprs(post_type_spec);
                            stmts.push(vir::Stmt::Inhale(post_perm_spec.remove_read_permissions()));
                            if let Some(access) = return_type_spec {
                                stmts.push(vir::Stmt::Inhale(replace_fake_exprs(access)));
                            }
                            for (from_place, to_place) in read_transfer {
                                stmts.push(vir::Stmt::TransferPerm(
                                    replace_fake_exprs(from_place),
                                    replace_fake_exprs(to_place),
                                    true));
                            }
                            stmts.push(vir::Stmt::Inhale(replace_fake_exprs(post_invs_spec)));
                            stmts.push(vir::Stmt::Inhale(replace_fake_exprs(post_func_spec)));

                            // Exhale the permissions that were moved into magic wands.
                            stmts.push(vir::Stmt::Exhale(pre_mandatory_perm_spec, pos));

                            // Emit the label and magic wands
                            stmts.push(vir::Stmt::Label(post_label.clone()));

                            stmts.extend(stmts_after);

                            self.procedure_contracts.insert(
                                location, (procedure_contract, fake_exprs));
                        }
                    }
                    // generic (pure on non-pure) function call
                }

                // FIXME; hideous monstrosity...
                {
                    let mut tymap_stack = self.encoder.typaram_repl.borrow_mut();
                    tymap_stack.pop();
                }

                if let &Some((_, target)) = destination {
                    let target_cfg_block = cfg_blocks.get(&target).unwrap();
                    (stmts, Successor::Goto(*target_cfg_block))
                } else {
                    // Encode unreachability
                    //stmts.push(
                    //    vir::Stmt::Inhale(false.into())
                    //);
                    (stmts, Successor::Return)
                }
            }

            TerminatorKind::Call { .. } => {
                // Other kind of calls?
                unimplemented!();
            }

            TerminatorKind::Assert { ref cond, expected, ref target, ref msg, .. } => {
                trace!("Assert cond '{:?}', expected '{:?}'", cond, expected);

                // Use local variables in the switch/if (see issue #57)
                let cond_var = self.cfg_method.add_fresh_local_var(vir::Type::Bool);
                stmts.push(
                    vir::Stmt::Assign(
                        cond_var.clone().into(),
                        self.mir_encoder.encode_operand_expr(cond),
                        vir::AssignKind::Copy
                    )
                );

                let viper_guard = if expected {
                    cond_var.into()
                } else {
                    vir::Expr::not(cond_var.into())
                };
                let target_cfg_block = *cfg_blocks.get(&target).unwrap();

                // Prepare a block that encodes the branch of the failure
                let failure_label = self.cfg_method.get_fresh_label_name();
                let failure_block = self.cfg_method.add_block(&failure_label, vec![], vec![
                    vir::Stmt::comment(format!("========== {} ==========", &failure_label)),
                    vir::Stmt::comment(format!("A Rust assertion failed: {}", msg.description())),
                    if self.check_panics {
                        vir::Stmt::Assert(
                            false.into(),
                            self.encoder.error_manager().register(
                                term.source_info.span,
                                ErrorCtxt::AssertTerminator(msg.description().to_string())
                            ),
                        )
                    } else {
                        vir::Stmt::comment("This assertion will not be checked")
                    }
                ]);
                self.cfg_method.set_successor(failure_block, Successor::Return);

                (stmts, Successor::GotoSwitch(vec![(viper_guard, target_cfg_block)], failure_block))
            }

            TerminatorKind::Resume |
            TerminatorKind::Yield { .. } |
            TerminatorKind::GeneratorDrop => unimplemented!("{:?}", term.kind),
        }
    }

    /// Encode permissions that are implicitly carried by the given local variable.
    fn encode_local_variable_permission(&self, local: Local) -> vir::Expr {
        match self.locals.get_type(local).sty {
            ty::TypeVariants::TyRawPtr(ty::TypeAndMut { ref ty, mutbl: mutability }) |
            ty::TypeVariants::TyRef(_, ref ty, mutability) => {
                // Use unfolded references.
                let encoded_local = self.encode_prusti_local(local);
                let field = self.encoder.encode_dereference_field(ty);
                let place = vir::Expr::from(encoded_local).field(field);
                let perm_amount = match mutability {
                    Mutability::MutMutable => vir::PermAmount::Write,
                    Mutability::MutImmutable => vir::PermAmount::Read,
                };
                vir::Expr::and(
                    vir::Expr::acc_permission(place.clone(), vir::PermAmount::Write),
                    vir::Expr::pred_permission(place, perm_amount).unwrap(),
                )
            }
            _ => {
                self.mir_encoder.encode_place_predicate_permission(
                    self.encode_prusti_local(local).into(),
                    vir::PermAmount::Write
                ).unwrap()
            }
        }
    }

    /// Encode the precondition with three expressions:
    /// - one for the type encoding
    /// - one for the type invariants
    /// - one for the functional specification.
    fn encode_precondition_expr(
        &self,
        contract: &ProcedureContract<'tcx>
    ) -> (vir::Expr, Vec<vir::Expr>, vir::Expr, vir::Expr) {

        let borrow_infos = &contract.borrow_infos;
        let maybe_blocked_paths = if !borrow_infos.is_empty() {
            assert_eq!(borrow_infos.len(), 1,
                       "We can have at most one magic wand in the postcondition.");
            let borrow_info = &borrow_infos[0];
            Some(&borrow_info.blocked_paths)
        } else {
            None
        };
        // Type spec in which read permissions can be removed.
        let mut type_spec = Vec::new();
        // Type spec containing the read permissions that must be exhaled because they were
        // moved into a magic wand.
        let mut mandatory_type_spec = Vec::new();
        fn is_blocked(maybe_blocked_paths: Option<&Vec<(Place, Mutability)>>, arg: Local) -> bool{
            if let Some(blocked_paths) = maybe_blocked_paths {
                for (blocked_place, _) in blocked_paths {
                    if blocked_place.is_root(arg) {
                        return true;
                    }
                }
            }
            false
        }
        for local in &contract.args {
            let mut add = |access: vir::Expr| {
                if is_blocked(maybe_blocked_paths, *local) &&
                        access.get_perm_amount() == vir::PermAmount::Read {
                    mandatory_type_spec.push(access);
                } else {
                    type_spec.push(access);
                }
            };
            let access = self.encode_local_variable_permission(*local);
            match access {
                vir::Expr::BinOp(vir::BinOpKind::And, box access1, box access2, _) => {
                    add(access1);
                    add(access2);
                },
                _ => add(access),
            };
        }

        let mut invs_spec: Vec<vir::Expr> = vec![];

        for arg in contract.args.iter() {
            invs_spec.push(
                self.encoder.encode_invariant_func_app(
                    self.locals.get_type(*arg),
                    self.encode_prusti_local(*arg).into()
                )
            );
        }

        let mut func_spec: Vec<vir::Expr> = vec![];

        // Encode functional specification
        let encoded_args: Vec<vir::Expr> = contract.args.iter()
            .map(|local| self.encode_prusti_local(*local).into())
            .collect();
        for item in contract.functional_precondition() {
            // FIXME
            //warn!("before: {:?}", &item.assertion);
            let value = self.encoder.encode_assertion(&item.assertion, &self.mir, &"", &encoded_args, None, false, None);
            //warn!("after:  {:?}", &value);
            func_spec.push(value);
        }

        (type_spec.into_iter().conjoin(),
         mandatory_type_spec,
         invs_spec.into_iter().conjoin(),
         func_spec.into_iter().conjoin())
    }

    /// Encode precondition inhale on the definition side.
    fn encode_preconditions(&mut self, start_cfg_block: CfgBlockIndex,
                            contract: &ProcedureContract<'tcx>) {
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::comment("Preconditions:"));
        let (type_spec, mandatory_type_spec, invs_spec, func_spec) =
            self.encode_precondition_expr(contract);
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::Inhale(type_spec));
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::Inhale(mandatory_type_spec.into_iter().conjoin()));
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::Inhale(invs_spec));
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::Inhale(func_spec));
        self.cfg_method.add_stmt(start_cfg_block, vir::Stmt::Label(PRECONDITION_LABEL.to_string()));
    }

    /// Encode permissions that are implicitly carried by the given place.
    /// `state_label` â the label of the state in which the place should
    /// be evaluated (the place expression is wrapped in the labelled old).
    fn encode_pred_permission(
        &self,
        place: &Place<'tcx>,
        state_label: Option<&str>
    ) -> vir::Expr {
        let (encoded_place, ty, _) = self.encode_generic_place(place);
        vir::Expr::pred_permission(
            encoded_place.maybe_old(state_label),
            vir::PermAmount::Write,
        ).unwrap()
    }

    /// Encode permissions that are implicitly carried by the given place.
    /// `state_label` â the label of the state in which the place should
    /// be evaluated (the place expression is wrapped in the labelled old).
    fn encode_acc_permission(&self, place: &Place<'tcx>) -> vir::Expr {
        let (encoded_place, _, _) = self.encode_generic_place(place);
        vir::Expr::acc_permission(
            encoded_place,
            vir::PermAmount::Write,
        )
    }

    /// Encode the magic wand used in the postcondition with its
    /// functional specification. Returns (lhs, rhs).
    fn encode_postcondition_magic_wand(
        &self,
        contract: &ProcedureContract<'tcx>,
        pre_label: &str,
        post_label: &str,
    ) -> Option<(vir::Expr, vir::Expr)> {

        // Encode args and return.
        let encoded_args: Vec<vir::Expr> = contract.args.iter()
            .map(|local| self.encode_prusti_local(*local).into())
            .collect();
        let encoded_return: vir::Expr = self.encode_prusti_local(contract.returned_value).into();

        // Encode magic wands
        let borrow_infos = &contract.borrow_infos;
        if !borrow_infos.is_empty() {
            assert_eq!(borrow_infos.len(), 1,
                       "We can have at most one magic wand in the postcondition.");
            let borrow_info = &borrow_infos[0];
            let mut pledges = contract.pledges();
            assert!(pledges.len() <= 1,
                    "There can be at most one pledge in the function postcondition.");
            debug!("borrow_info {:?}", borrow_info);
            let encode_place_perm = |place, mutability, label| {
                    let perm_amount = match mutability {
                        Mutability::MutImmutable => vir::PermAmount::Read,
                        Mutability::MutMutable => vir::PermAmount::Write,
                    };
                    let (place_expr, place_ty, _) = self.encode_generic_place(place);
                    let vir_access = vir::Expr::pred_permission(
                        place_expr.clone().old(label),
                        perm_amount,
                    ).unwrap();
                    let inv = self.encoder.encode_invariant_func_app(
                        place_ty,
                        place_expr.old(label)
                    );
                    vir::Expr::and(vir_access, inv)
            };
            let mut lhs: Vec<_> = borrow_info.blocking_paths
                .iter()
                .map(|(place, mutability)| {
                    encode_place_perm(place, *mutability, post_label)
                })
                .collect();
            let mut rhs: Vec<_> = borrow_info.blocked_paths
                .iter()
                .map(|(place, mutability)| {
                    encode_place_perm(place, *mutability, pre_label)
                })
                .collect();
            if let Some((reference, body_lhs, body_rhs)) = pledges.pop() {
                debug!("pledge reference={:?} lhs={:?} rhs={:?}", reference, body_lhs, body_rhs);
                assert!(reference.is_none(), "The reference should be none in postcondition.");
                let mut assertion_lhs = self.encoder.encode_assertion(
                    &body_lhs, &self.mir, pre_label, &encoded_args,
                    Some(&encoded_return), false, None);
                let mut assertion_rhs = self.encoder.encode_assertion(
                    &body_rhs, &self.mir, pre_label, &encoded_args,
                    Some(&encoded_return), false, None);
                assertion_lhs = self.wrap_arguments_into_old(
                    assertion_lhs, pre_label, contract, &encoded_args);
                assertion_rhs = self.wrap_arguments_into_old(
                    assertion_rhs, pre_label, contract, &encoded_args);
                let ty = self.locals.get_type(contract.returned_value);
                let (encoded_deref, ..) = self.mir_encoder.encode_deref(encoded_return.clone(), ty);
                let original_expr = encoded_deref;
                let old_expr = vir::Expr::labelled_old(post_label, original_expr.clone());
                // TODO ??
                assertion_lhs = assertion_lhs.replace_place(&original_expr, &old_expr);
                assertion_lhs = assertion_lhs.remove_redundant_old();
                assertion_rhs = assertion_rhs.replace_place(&original_expr, &old_expr);
                assertion_rhs = assertion_rhs.remove_redundant_old();
                lhs.push(assertion_lhs);
                rhs.push(assertion_rhs);
            }
            let lhs = lhs.into_iter().conjoin();
            let rhs = rhs.into_iter().conjoin();
            Some((lhs, rhs))
        } else {
            None
        }
    }

    /// Wrap function arguments used in the postcondition into ``old``:
    ///
    /// +   For references wrap the base ``_1.var_ref``.
    /// +   For non-references wrap the entire place into old.
    fn wrap_arguments_into_old(
        &self,
        mut assertion: vir::Expr,
        pre_label: &str,
        contract: &ProcedureContract<'tcx>,
        encoded_args: &[vir::Expr],
    ) -> vir::Expr {
        for (encoded_arg, &arg) in encoded_args.iter().zip(&contract.args) {
            let ty = self.locals.get_type(arg);
            if self.mir_encoder.is_reference(ty) {
                // If the argument is a reference, we wrap _1.val_ref into old.
                let (encoded_deref, ..) = self.mir_encoder.encode_deref(encoded_arg.clone(), ty);
                let original_expr = encoded_deref;
                let old_expr = vir::Expr::labelled_old(pre_label, original_expr.clone());
                assertion = assertion.replace_place(&original_expr, &old_expr);
            } else {
                // If the argument is not a reference, we wrap entire path into old.
                assertion = assertion.fold_places(
                    |place| {
                        let base: vir::Expr = place.get_base().into();
                        if encoded_arg == &base {
                            place.old(pre_label)
                        } else {
                            place
                        }
                    });
            }
        }
        assertion.remove_redundant_old()
    }

    /// Get the span of a postcondition.
    fn get_postcondition_span(
        &mut self,
        contract: &ProcedureContract<'tcx>,
    ) -> Vec<Span> {
        contract
            .functional_postcondition()
            .iter()
            .map(|spec| spec.assertion.get_spans())
            .fold(
                vec![],
                |mut a, b| { a.extend(b); a }
            )
    }

    /// Encode the postcondition with three expressions:
    /// - one for the type encoding
    /// - one for the type invariants
    /// - one for the functional specification.
    /// Also return the magic wands to be added to the postcondition.
    ///
    /// `function_end` â are we encoding the exhale of the postcondition
    /// at the end of the method?
    fn encode_postcondition_expr(
        &mut self,
        contract: &ProcedureContract<'tcx>,
        pre_label: &str,
        post_label: &str,
        magic_wand_store_info: Option<(mir::Location, &HashMap<vir::Expr, vir::Expr>)>,
        diverging: bool,
        loan: Option<facts::Loan>,
        function_end: bool
    ) -> (
        vir::Expr,                  // Returned permissions from types.
        Option<vir::Expr>,          // Permission of the return value.
        vir::Expr,                  // Invariants.
        vir::Expr,                  // Functional specification.
        Vec<vir::Expr>,             // Magic wands.
        Vec<(vir::Expr, vir::Expr)> // Read permissions that need to be transferred to a new place.
    ) {
        let mut type_spec = vec![];
        let mut invs_spec = vec![];
        let mut read_transfer = vec![];     // Permissions taken as read
                                            // references that need to
                                            // be transfered to old.

        // Encode the permissions got back and invariants for the arguments of type reference
        for (place, mutability) in contract.returned_refs.iter() {
            debug!("Put permission {:?} ({:?}) in postcondition", place, mutability);
            let (place_expr, place_ty, _) = self.encode_generic_place(place);
            let old_place_expr = place_expr.clone().old(pre_label);
            let mut add_type_spec = |perm_amount| {
                let permissions = vir::Expr::pred_permission(
                    old_place_expr.clone(),
                    perm_amount,
                ).unwrap();
                type_spec.push(permissions);
            };
            match mutability {
                Mutability::MutImmutable => {
                    if function_end {
                        add_type_spec(vir::PermAmount::Read);
                    }
                    read_transfer.push((place_expr, old_place_expr));
                }
                Mutability::MutMutable => {
                    add_type_spec(vir::PermAmount::Write);
                    let inv = self.encoder.encode_invariant_func_app(
                        place_ty,
                        old_place_expr,
                    );
                    invs_spec.push(inv);
                }
            };
        }

        // Encode args and return.
        let encoded_args: Vec<vir::Expr> = contract.args.iter()
            .map(|local| self.encode_prusti_local(*local).into())
            .collect();

        let encoded_return: vir::Expr = self.encode_prusti_local(contract.returned_value).into();

        let mut magic_wands = Vec::new();
        if let Some((mut lhs, mut rhs)) = self.encode_postcondition_magic_wand(
                contract, pre_label, post_label) {
            if let Some((location, fake_exprs)) = magic_wand_store_info {
                let replace_fake_exprs = |mut expr: vir::Expr| -> vir::Expr {
                    for (fake_arg, arg_expr) in fake_exprs.iter() {
                        expr = expr.replace_place(&fake_arg, arg_expr);
                    }
                    expr
                };
                lhs = replace_fake_exprs(lhs);
                rhs = replace_fake_exprs(rhs);
                debug!("Insert ({:?} {:?}) at {:?}", lhs, rhs, location);
                self.magic_wand_at_location.insert(
                    location, (post_label.to_string(), lhs.clone(), rhs.clone()));
            }
            magic_wands.push(vir::Expr::magic_wand(lhs, rhs, loan));
        }

        // Encode permissions for return type
        // TODO: Clean-up: remove unnecessary Option.
        let return_perm = Some(self.encode_local_variable_permission(contract.returned_value));

        // Encode invariant for return value
        // TODO put this in the above if?
        invs_spec.push(self.encoder.encode_invariant_func_app(
            self.locals.get_type(contract.returned_value),
            encoded_return.clone()
        ));

        // Encode functional specification
        let mut func_spec = vec![];
        for item in contract.functional_postcondition() {
            let mut assertion = self.encoder.encode_assertion(
                &item.assertion, &self.mir, pre_label, &encoded_args,
                Some(&encoded_return), false, None);
            assertion = self.wrap_arguments_into_old(
                assertion, pre_label, contract, &encoded_args);
            func_spec.push(assertion);
        }

        (type_spec.into_iter().conjoin(),
         return_perm,
         invs_spec.into_iter().conjoin(),
         func_spec.into_iter().conjoin(),
         magic_wands,
         read_transfer)
    }

    /// Modelling move as simple assignment on Viper level has a consequence
    /// that the assigned place changes. Therefore, if some value is
    /// moved into a borrow, the borrow starts pointing to a different
    /// memory location. As a result, we cannot use old expressions as
    /// roots for holding permissions because they always point to the
    /// same place. Instead, we replace them with ghost variables.
    ///
    /// This method replaces all places with `label` with ghost variables.
    fn replace_old_places_with_ghost_vars(
        &mut self,
        label: Option<&str>,
        expr: vir::Expr
    ) -> vir::Expr {
        struct OldReplacer<'a> {
            label: Option<&'a str>,
            old_to_ghost_var: &'a mut HashMap<vir::Expr, vir::Expr>,
            old_ghost_vars: &'a mut HashMap<String, vir::Type>,
            cfg_method: &'a mut vir::CfgMethod,
        }
        impl<'a> vir::ExprFolder for OldReplacer<'a> {
            fn fold_labelled_old(
                &mut self,
                label: String,
                base: Box<vir::Expr>,
                pos: vir::Position
            ) -> vir::Expr {
                let base = self.fold_boxed(base);
                let expr = vir::Expr::LabelledOld(label.clone(), base, pos.clone());
                debug!("replace_old_places_with_ghost_vars({:?}, {})", self.label, expr);
                if self.old_to_ghost_var.contains_key(&expr) {
                    debug!("found={}", self.old_to_ghost_var[&expr]);
                    self.old_to_ghost_var[&expr].clone().set_pos(pos)
                } else if self.label == Some(&label) {
                    let mut counter = 0;
                    let mut name = format!("_old${}${}", label, counter);
                    while self.old_ghost_vars.contains_key(&name) {
                        counter += 1;
                        name = format!("_old${}${}", label, counter);
                    }
                    let vir_type = expr.get_type().clone();
                    self.old_ghost_vars.insert(name.clone(), vir_type.clone());
                    self.cfg_method.add_local_var(&name, vir_type.clone());
                    let var: vir::Expr = vir::LocalVar::new(name, vir_type).into();
                    self.old_to_ghost_var.insert(expr, var.clone());
                    var
                } else {
                    debug!("not found");
                    expr
                }
            }
        }
        let mut replacer = OldReplacer {
            label: label,
            old_to_ghost_var: &mut self.old_to_ghost_var,
            old_ghost_vars: &mut self.old_ghost_vars,
            cfg_method: &mut self.cfg_method,
        };
        vir::ExprFolder::fold(&mut replacer, expr)
    }

    /// Encode the package statement of magic wands at the end of the method
    fn encode_package_end_of_method(
        &mut self,
        contract: &ProcedureContract<'tcx>,
        pre_label: &str,
        post_label: &str,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        let mut stmts = Vec::new();

        // Package magic wand(s)
        if let Some((lhs, rhs)) = self.encode_postcondition_magic_wand(contract, pre_label, post_label) {
            let blocker = mir::RETURN_PLACE;
            // TODO: Check if it really is always start and not the mid point.
            let start_point = self.polonius_info.get_point(location, facts::PointType::Start);

            let mut package_stmts = if let Some(region) = self.polonius_info.variable_regions.get(&blocker) {
                let (all_loans, zombie_loans) = self.polonius_info.get_all_loans_kept_alive_by(
                    start_point, *region);
                self.encode_expiration_of_loans(all_loans, &zombie_loans, location, None)
            } else {
                unreachable!(); // Really?
            };

            // We need to make sure that the lhs of the magic wand is
            // fully folded before the label.
            // To do so, we need to use the lhs without functional specification.
            let current_lhs = lhs
                .clone()
                .map_labels(|label| {
                    if label == post_label {
                        None
                    } else {
                        Some(label)
                    }
                })
                .filter_perm_conjunction();
            stmts.extend(self.encode_obtain(current_lhs));

            // lhs must be phrased in terms of post state.
            let post_label = post_label.to_string();
            stmts.push(vir::Stmt::Label(post_label.clone()));

            // Make the deref of reference arguments to be folded (see issue #47)
            package_stmts.push(vir::Stmt::comment("Fold predicates for &mut args"));
            for arg_index in self.mir.args_iter() {
                let arg_ty = self.mir.local_decls[arg_index].ty;
                if self.mir_encoder.is_reference(arg_ty) {
                    let encoded_arg = self.mir_encoder.encode_local(arg_index);
                    let (deref_place, ..) = self.mir_encoder.encode_deref(
                        encoded_arg.into(), arg_ty);
                    let old_deref_place = deref_place.clone().old(&pre_label);
                    let deref_pred = vir::Expr::pred_permission(
                        old_deref_place.clone(), vir::PermAmount::Write).unwrap();
                    package_stmts.extend(
                        self.encode_transfer_permissions(deref_place, old_deref_place.clone(), location)
                    );
                    let predicate = vir::Expr::pred_permission(
                        old_deref_place, vir::PermAmount::Write).unwrap();
                    package_stmts.extend(self.encode_obtain(predicate));
                }
            }

            // The fold-unfold algorithm will fill the body of the package statement
            let pos = self.encoder.error_manager().register(
                self.mir.span,
                ErrorCtxt::PackageMagicWandForPostcondition
            );
            let vars: Vec<_> = self.old_ghost_vars.iter()
                .map(|(name, typ)| {
                    vir::LocalVar::new(name.clone(), typ.clone())
                })
                .collect();
            stmts.push(vir::Stmt::package_magic_wand(lhs, rhs, package_stmts,
                                                     post_label.clone(), vars, pos));

            // We need to transfer all permissions from old[post](lhs) to lhs.
            let borrow_infos = &contract.borrow_infos;
            assert_eq!(borrow_infos.len(), 1,
                       "We can have at most one magic wand in the postcondition.");
            for (path, _) in &borrow_infos[0].blocking_paths {
                let (mut encoded_place, _, _) = self.encode_generic_place(path);
                let old_place = encoded_place.clone().old(post_label.clone());
                stmts.extend(self.encode_transfer_permissions(old_place, encoded_place, location));
            }
        }

        stmts
    }

    /// Encode postcondition exhale on the definition side.
    fn encode_postconditions(&mut self, return_cfg_block: CfgBlockIndex,
                             contract: &ProcedureContract<'tcx>) {
        self.cfg_method.add_stmt(return_cfg_block, vir::Stmt::comment("Exhale postcondition"));

        let (type_spec, return_type_spec, invs_spec, func_spec,
             magic_wands, _) = self.encode_postcondition_expr(
            contract, PRECONDITION_LABEL, POSTCONDITION_LABEL, None, false, None, true);

        // Find which arguments are blocked by the returned reference.
        let blocked_args: Vec<usize> = {
            let borrow_infos = &contract.borrow_infos;
            if !borrow_infos.is_empty() {
                assert_eq!(borrow_infos.len(), 1,
                           "We can have at most one magic wand in the postcondition.");
                let mut blocked_args = Vec::new();
                for (blocked_place, _) in &borrow_infos[0].blocked_paths {
                    for (i, arg) in contract.args.iter().enumerate() {
                        debug!("blocked_place={:?} i={:?} arg={:?}", blocked_place, i, arg);
                        if blocked_place.is_root(*arg) {
                            blocked_args.push(i);
                        }
                    }
                }
                blocked_args
            } else {
                Vec::new()
            }
        };

        // Transfer borrow permissions to old.
        self.cfg_method.add_stmt(
            return_cfg_block,
            vir::Stmt::comment("Fold predicates for &mut args and transfer borrow permissions to old"));
        for (i, &arg) in contract.args.iter().enumerate() {
            if blocked_args.contains(&i) {
                // Permissions of arguments that are blocked by the returned reference are not
                // added to the postcondition.
                continue;
            }
            let ty = self.locals.get_type(arg);
            if self.mir_encoder.is_reference(ty) {
                let encoded_arg: vir::Expr = self.encode_prusti_local(arg).into();
                let (encoded_deref, ..) = self.mir_encoder.encode_deref(encoded_arg.clone(), ty);

                // Fold argument.
                let deref_pred = self.mir_encoder.encode_place_predicate_permission(
                    encoded_deref.clone(), vir::PermAmount::Write).unwrap();
                for stmt in self.encode_obtain(deref_pred).drain(..) {
                    self.cfg_method.add_stmt(return_cfg_block, stmt);
                }

                // Transfer permissions.
                //
                // TODO: This version does not allow mutating function arguments.
                // A way to allow this would be for each reference typed
                // argument generate a fresh pure variable `v` and a
                // variable `b:=true` and add `old[pre](_1.val_ref)` to
                // the replacement map. Before each assignment that
                // assigns to the reference itself, emit `b:=false`.
                // After each assignment that assigns to the contents
                // the reference is pointing to emit:
                //
                //      if b {
                //          v := _1.val_ref;
                //      }
                let old_expr = encoded_deref.clone().old(PRECONDITION_LABEL);
                let name = format!("_old${}${}", PRECONDITION_LABEL, i);
                let vir_type = old_expr.get_type().clone();
                self.old_ghost_vars.insert(name.clone(), vir_type.clone());
                self.cfg_method.add_local_var(&name, vir_type.clone());
                let var: vir::Expr = vir::LocalVar::new(name, vir_type).into();
                self.old_to_ghost_var.insert(old_expr, var.clone());

                self.cfg_method.add_stmt(
                    return_cfg_block,
                    vir::Stmt::Assign(var, encoded_deref, vir::AssignKind::Move)
                );
            }
        }

        // Assert functional specification of postcondition
        let pos = self.encoder.error_manager().register(
            {
                let mut multi_span = MultiSpan::from_span(self.mir.span);
                for span in self.get_postcondition_span(contract).into_iter() {
                    multi_span.push_span_label(span, "".to_string());
                }
                multi_span
            },
            ErrorCtxt::AssertMethodPostcondition
        );
        let patched_func_spec = self.replace_old_places_with_ghost_vars(None, func_spec);
        self.cfg_method.add_stmt(return_cfg_block, vir::Stmt::Assert(patched_func_spec, pos));

        // Assert type invariants
        let pos = self.encoder.error_manager().register(
            self.mir.span,
            ErrorCtxt::AssertMethodPostconditionTypeInvariants
        );
        let patched_invs_spec = self.replace_old_places_with_ghost_vars(None, invs_spec);
        self.cfg_method.add_stmt(return_cfg_block, vir::Stmt::Assert(patched_invs_spec, pos));

        // Exhale permissions of postcondition
        let pos = self.encoder.error_manager().register(
            self.mir.span,
            ErrorCtxt::ExhaleMethodPostcondition
        );
        let patched_type_spec = self.replace_old_places_with_ghost_vars(None, type_spec);
        self.cfg_method.add_stmt(return_cfg_block,
                                 vir::Stmt::Exhale(patched_type_spec, pos.clone()));
        if let Some(access) = return_type_spec {
            self.cfg_method.add_stmt(return_cfg_block, vir::Stmt::Exhale(access, pos.clone()));
        }
        for magic_wand in magic_wands {
            self.cfg_method.add_stmt(return_cfg_block, vir::Stmt::Exhale(magic_wand, pos.clone()));
        }
    }

    fn get_pure_var_for_preserving_value(
        &mut self,
        loop_head: BasicBlockIndex,
        place: &vir::Expr
    ) -> vir::LocalVar {
        let loop_map = self.pure_var_for_preserving_value_map.get_mut(&loop_head).unwrap();
        if let Some(local_var) = loop_map.get(place) {
            local_var.clone()
        } else {
            let mut counter = 0;
            let mut name = format!("_preserve${}", counter);
            while self.auxiliar_local_vars.contains_key(&name) {
                counter += 1;
                name = format!("_preserve${}", counter);
            }
            let vir_type = vir::Type::TypedRef(String::from("AuxRef"));
            self.cfg_method.add_local_var(&name, vir_type.clone());
            self.auxiliar_local_vars.insert(name.clone(), vir_type.clone());
            let var = vir::LocalVar::new(name, vir_type);
            loop_map.insert(place.clone(), var.clone());
            var
        }
    }

    /// Since the loop invariant is taking all permission from the
    /// outer context, we need to preserve values of references by
    /// saving them in local variables.
    fn construct_value_preserving_equality(
        &mut self,
        loop_head: BasicBlockIndex,
        place: &vir::Expr
    ) -> vir::Expr {
        let tmp_var = self.get_pure_var_for_preserving_value(
            loop_head, place);
        vir::Expr::BinOp(
            vir::BinOpKind::EqCmp,
            box tmp_var.into(),
            box place.clone(),
            vir::Position::default(),
        )
    }

    /// `drop_read_references` â should we add permissions to read
    /// references? We drop permissions of read references from the
    /// exhale before the loop and inhale after the loop so that
    /// the knowledge about their values is not havocked.
    fn encode_loop_invariant_permissions(
        &mut self,
        loop_head: BasicBlockIndex,
        drop_read_references: bool
    ) -> Vec<vir::Expr> {
        trace!("[enter] encode_loop_invariant_permissions \
               loop_head={:?} drop_read_references={}",
               loop_head, drop_read_references);
        let permissions_forest = self.loop_encoder.compute_loop_invariant(loop_head);
        let loop_depth = self.loop_encoder.get_loop_depth(loop_head) as u32;
        debug!("permissions_forest: {:?}", permissions_forest);

        let mut permissions = vec![];
        for tree in permissions_forest.get_trees().iter() {
            for (kind, mir_place) in tree.get_permissions().into_iter() {
                if kind.is_none() {
                    continue;
                }
                let (encoded_place, ty, _) = self.mir_encoder.encode_place(&mir_place);
                debug!("kind={:?} mir_place={:?} ty={:?}", kind, mir_place, ty);
                if let ty::TypeVariants::TyClosure(..) = ty.sty {
                    // Do not encode closures
                    continue;
                }
                match kind {
                    /// Gives read permission to this node. It must not be a leaf node.
                    PermissionKind::ReadNode => {
                        let perm = vir::Expr::acc_permission(
                            encoded_place,
                            vir::PermAmount::Read,
                        );
                        permissions.push(perm);
                    }

                    /// Gives write permission to this node. It must not be a leaf node.
                    PermissionKind::WriteNode => {
                        let perm = vir::Expr::acc_permission(
                            encoded_place,
                            vir::PermAmount::Write
                        );
                        permissions.push(perm);
                    }

                    /// Gives read or write permission to the entire
                    /// subtree including this node. This must be a leaf
                    /// node.
                    PermissionKind::ReadSubtree |
                    PermissionKind::WriteSubtree => {
                        let perm_amount = match kind {
                            PermissionKind::WriteSubtree => vir::PermAmount::Write,
                            PermissionKind::ReadSubtree => vir::PermAmount::Read,
                            _ => unreachable!(),
                        };
                        let def_init = self.loop_encoder.is_definitely_initialised(
                            &mir_place, loop_head);
                        debug!("    perm_amount={} def_init={}", perm_amount, def_init);
                        if let mir::Place::Projection(
                            box mir::Projection { elem: mir::ProjectionElem::Deref, ref base }
                            ) = mir_place {
                            let (_, ref_ty, _) = self.mir_encoder.encode_place(base);
                            match ref_ty.sty {
                                ty::TypeVariants::TyRawPtr(ty::TypeAndMut { mutbl, .. }) |
                                ty::TypeVariants::TyRef(_, _, mutbl) => {
                                    if def_init {
                                        permissions.push(
                                            self.construct_value_preserving_equality(
                                                loop_head, &encoded_place));
                                    }
                                    if drop_read_references {
                                        if mutbl == Mutability::MutImmutable {
                                            continue;
                                        }
                                    }
                                }
                                ref x => unreachable!("{:?}", x),
                            }
                        }
                        match ty.sty {
                            ty::TypeVariants::TyRawPtr(ty::TypeAndMut { ref ty, mutbl }) |
                            ty::TypeVariants::TyRef(_, ref ty, mutbl) => {
                                debug!("encode_loop_invariant_permissions \
                                        mir_place={:?} mutability={:?} \
                                        drop_read_references={}",
                                        mir_place, mutbl, drop_read_references);
                                // Use unfolded references.
                                let field = self.encoder.encode_dereference_field(ty);
                                let field_place = vir::Expr::from(encoded_place).field(field);
                                permissions.push(vir::Expr::acc_permission(
                                    field_place.clone(), perm_amount));
                                if def_init {
                                    permissions.push(
                                        self.construct_value_preserving_equality(
                                            loop_head, &field_place));
                                }
                                if def_init &&
                                    !(mutbl == Mutability::MutImmutable && drop_read_references) {
                                    permissions.push(vir::Expr::pred_permission(
                                        field_place, perm_amount).unwrap());
                                }
                            },
                            _ => {
                                permissions.push(vir::Expr::pred_permission(
                                    encoded_place, perm_amount).unwrap());
                            }
                        }
                    }
                    /// This should be repalced with WriteNode and
                    /// WriteSubtree before this point.
                    PermissionKind::WriteNodeAndSubtree => {
                        unreachable!()
                    }
                    /// Give no permission to this node and the entire subtree. This
                    /// must be a leaf node.
                    PermissionKind::None => {
                        unreachable!()
                    }
                };
            }
        }

        trace!("[exit] encode_loop_invariant_permissions permissions={}",
               permissions.iter().map(|p| format!("{}, ", p)).collect::<String>());
        permissions
    }

    /// Get the basic blocks that encode the specification of a loop invariant
    fn get_loop_spec_blocks(&self, loop_head: BasicBlockIndex) -> Vec<BasicBlockIndex> {
        let mut res = vec![];
        for bbi in self.procedure.get_reachable_cfg_blocks() {
            if Some(loop_head) == self.loop_encoder.get_loop_head(bbi) && self.procedure.is_spec_block(bbi) {
                res.push(bbi)
            } else {
                debug!("bbi {:?} has head {:?} and 'is spec' is {}", bbi, self.loop_encoder.get_loop_head(bbi), self.procedure.is_spec_block(bbi));
            }
        }
        res
    }

    /// Encode the functional specification of a loop
    fn encode_loop_invariant_specs(&self, loop_head: BasicBlockIndex) -> Vec<vir::Expr> {
        let spec_blocks = self.get_loop_spec_blocks(loop_head);
        trace!("loop head {:?} has spec blocks {:?}", loop_head, spec_blocks);

        let mut spec_ids = vec![];
        for bbi in spec_blocks {
            for stmt in &self.mir.basic_blocks()[bbi].statements {
                if let mir::StatementKind::Assign(
                    _,
                    mir::Rvalue::Aggregate(
                        box mir::AggregateKind::Closure(cl_def_id, _),
                        _
                    )
                ) = stmt.kind {
                    debug!("cl_def_id: {:?}", cl_def_id);
                    if let Some(attr) = self.encoder.env().get_attr(cl_def_id, "__PRUSTI_LOOP_SPEC_ID") {
                        let spec_id: u64 = attr.parse().unwrap();
                        spec_ids.push(SpecID::from(spec_id));
                    }
                }
            }
        }
        trace!("spec_ids: {:?}", spec_ids);
        assert!(spec_ids.len() <= 1, "a loop has multiple specification ids");


        let mut encoded_specs = vec![];
        if !spec_ids.is_empty() {
            let encoded_args: Vec<vir::Expr> = self.mir.args_iter()
                .map(|local| self.mir_encoder.encode_local(local).into())
                .collect();
            for spec_id in &spec_ids {
                let spec_set = self.encoder.spec().get(spec_id).unwrap();
                match spec_set {
                    SpecificationSet::Loop(ref specs) => {
                        for spec in specs.iter() {
                            // TODO: Mmm... are these parameters correct?
                            let encoded_spec = self.encoder.encode_assertion(
                                &spec.assertion,
                                self.mir,
                                PRECONDITION_LABEL,
                                &encoded_args,
                                None,
                                false,
                                Some(loop_head)
                            );
                            encoded_specs.push(encoded_spec)
                        }
                    }
                    ref x => unreachable!("{:?}", x),
                }
            }
            trace!("encoded_specs: {:?}", encoded_specs);
        }

        encoded_specs
    }

    fn encode_loop_invariant_obtain(&mut self, loop_head: BasicBlockIndex) -> Vec<vir::Stmt> {
        trace!("[enter] encode_loop_invariant_obtain loop_head={:?}", loop_head);
        let permissions = self.encode_loop_invariant_permissions(loop_head, true);

        vec![
            vir::Stmt::comment(
                format!("Restore the fold/unfold state of the loop invariant of {:?}", loop_head)
            ),
            vir::Stmt::Obtain(
                permissions.into_iter().conjoin()
            )
        ]
    }

    fn encode_loop_invariant_exhale(
        &mut self,
        loop_head: BasicBlockIndex,
        after_loop_iteration: bool
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_loop_invariant_exhale loop_head={:?} \
                after_loop_iteration={}",
                loop_head, after_loop_iteration);
        if !after_loop_iteration {
            self.pure_var_for_preserving_value_map.insert(loop_head, HashMap::new());
        }
        let permissions = self.encode_loop_invariant_permissions(
            loop_head, !after_loop_iteration);
        let func_spec = self.encode_loop_invariant_specs(loop_head);

        // TODO: use different positions, and generate different error messages, for the exhale
        // before the loop and after the loop body

        let assert_pos = self.encoder.error_manager().register(
            // TODO: choose a proper error span
            self.mir.span,
            if after_loop_iteration {
                ErrorCtxt::AssertLoopInvariantAfterIteration
            } else {
                ErrorCtxt::AssertLoopInvariantOnEntry
            }
        );

        let exhale_pos = self.encoder.error_manager().register(
            // TODO: choose a proper error span
            self.mir.span,
            if after_loop_iteration {
                ErrorCtxt::ExhaleLoopInvariantAfterIteration
            } else {
                ErrorCtxt::ExhaleLoopInvariantOnEntry
            }
        );

        let permission_expr = permissions.into_iter().conjoin();

        let mut stmts = vec![
            vir::Stmt::comment(
                format!("Assert and exhale the loop invariant of block {:?}", loop_head)
            ),
        ];
        if !after_loop_iteration {
            for (place, field) in &self.pure_var_for_preserving_value_map[&loop_head] {
                stmts.push(
                    vir::Stmt::Assign(
                        field.into(),
                        place.clone(),
                        vir::AssignKind::Ghost,
                    )
                );
            }
        }
        stmts.push(
            vir::Stmt::Assert(
                func_spec.into_iter().conjoin(),
                assert_pos
            )
        );
        stmts.push(
            vir::Stmt::Exhale(
                permission_expr,
                exhale_pos
            )
        );
        stmts
    }

    fn encode_loop_invariant_inhale(
        &mut self,
        loop_head: BasicBlockIndex,
        after_loop: bool
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_loop_invariant_inhale loop_head={:?} after_loop={}",
                loop_head, after_loop);
        let permissions = self.encode_loop_invariant_permissions(loop_head, after_loop);
        let func_spec = self.encode_loop_invariant_specs(loop_head);

        let permission_expr = permissions.into_iter().conjoin();

        let mut stmts = vec![
            vir::Stmt::comment(
                format!("Inhale the loop invariant of block {:?}", loop_head),
            )
        ];
        if after_loop {
            stmts.push(vir::Stmt::EndFrame);
        }
        stmts.push(vir::Stmt::Inhale(permission_expr));
        stmts.push(vir::Stmt::Inhale(func_spec.into_iter().conjoin()));
        stmts
    }

    // TODO: What is this?
    fn encode_prusti_local(&self, local: Local) -> vir::LocalVar {
        let var_name = self.locals.get_name(local);
        let type_name = self.encoder.encode_type_predicate_use(self.locals.get_type(local));
        vir::LocalVar::new(var_name, vir::Type::TypedRef(type_name))
    }

    /// Returns
    /// - `vir::Expr`: the place of the projection;
    /// - `ty::Ty<'tcx>`: the type of the place;
    /// - `Option<usize>`: optionally, the variant of the enum.
    #[deprecated(note="please use `mir_encoder::encode_projection` instead")]
    fn encode_projection(&self, place_projection: &mir::PlaceProjection<'tcx>, root: Option<Local>)
                         -> (vir::Expr, ty::Ty<'tcx>, Option<usize>) {
        debug!("Encode projection {:?} {:?}", place_projection, root);
        let (encoded_base, base_ty, opt_variant_index) = self.encode_place_with_subst_root(
            &place_projection.base, root);
        match &place_projection.elem {
            &mir::ProjectionElem::Field(ref field, _) => {
                match base_ty.sty {
                    ty::TypeVariants::TyBool |
                    ty::TypeVariants::TyInt(_) |
                    ty::TypeVariants::TyUint(_) |
                    ty::TypeVariants::TyRawPtr(_) |
                    ty::TypeVariants::TyRef(_, _, _) => panic!("Type {:?} has no fields", base_ty),

                    ty::TypeVariants::TyTuple(elems) => {
                        let field_name = format!("tuple_{}", field.index());
                        let field_ty = elems[field.index()];
                        let encoded_field = self.encoder.encode_raw_ref_field(field_name, field_ty);
                        let encoded_projection = encoded_base.field(encoded_field);
                        (encoded_projection, field_ty, None)
                    }

                    ty::TypeVariants::TyAdt(ref adt_def, ref subst) if !adt_def.is_box() => {
                        debug!("subst {:?}", subst);
                        let num_variants = adt_def.variants.len();
                        // FIXME: why this can be None?
                        let variant_index = opt_variant_index.unwrap_or_else(|| {
                            assert_eq!(num_variants, 1);
                            0
                        });
                        let tcx = self.encoder.env().tcx();
                        let variant_def = &adt_def.variants[variant_index];
                        let encoded_variant = if num_variants != 1 {
                            encoded_base.variant(&variant_def.name.as_str())
                        } else {
                            encoded_base
                        };
                        let field = &variant_def.fields[field.index()];
                        let field_ty = field.ty(tcx, subst);
                        let encoded_field = self.encoder.encode_struct_field(&field.ident.as_str(), field_ty);
                        let encoded_projection = encoded_variant.field(encoded_field);
                        (encoded_projection, field_ty, None)
                    }

                    ref x => unimplemented!("{:?}", x),
                }
            }

            &mir::ProjectionElem::Deref => {
                self.mir_encoder.encode_deref(encoded_base, base_ty)
            }

            &mir::ProjectionElem::Downcast(ref adt_def, variant_index) => {
                debug!("Downcast projection {:?}, {:?}", adt_def, variant_index);
                (encoded_base, base_ty, Some(variant_index))
            }

            x => unimplemented!("{:?}", x),
        }
    }

    fn encode_generic_place(&self, place: &Place<'tcx>) -> (vir::Expr, ty::Ty<'tcx>, Option<usize>) {
        match place {
            &Place::NormalPlace(ref place) => {
                self.encode_place_with_subst_root(place, None)
            }
            &Place::SubstitutedPlace { substituted_root, ref place } => {
                self.encode_place_with_subst_root(place, Some(substituted_root))
            }
        }
    }

    /// Returns
    /// - `vir::Expr`: the expression of the projection;
    /// - `ty::Ty<'tcx>`: the type of the expression;
    /// - `Option<usize>`: optionally, the variant of the enum.
    fn encode_place_with_subst_root(&self, place: &mir::Place<'tcx>,
                                    root: Option<Local>) -> (vir::Expr, ty::Ty<'tcx>, Option<usize>) {
        match place {
            &mir::Place::Local(local) =>
                match root {
                    Some(root) => (
                        self.encode_prusti_local(root).into(),
                        self.locals.get_type(root),
                        None
                    ),
                    None => (
                        self.mir_encoder.encode_local(local).into(),
                        self.mir_encoder.get_local_ty(local),
                        None
                    ),
                },
            &mir::Place::Projection(ref place_projection) =>
                self.encode_projection(place_projection, root),
            x => unimplemented!("{:?}", x),
        }
    }

    /// Return type:
    /// - `Vec<vir::Stmt>`: the statements that encode the assignment of `operand` to `lhs`
    fn encode_assign_operand(
        &mut self,
        lhs: &vir::Expr,
        operand: &mir::Operand<'tcx>,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        debug!("[enter] encode_assign_operand(lhs={}, operand={:?}, location={:?})",
               lhs, operand, location);
        let stmts = match operand {

            &mir::Operand::Move(ref place) => {
                let (src, ty, _) = self.mir_encoder.encode_place(place);
                let mut stmts = match ty.sty {
                    ty::TypeVariants::TyRawPtr(..) |
                    ty::TypeVariants::TyRef(..) => {
                        // Reborrow.
                        let field = self.encoder.encode_value_field(ty);
                        let mut alloc_stmts = self.prepare_assign_target(
                            lhs.clone(), field.clone(), location, vir::AssignKind::Move);
                        alloc_stmts.push(
                            vir::Stmt::Assign(
                                lhs.clone().field(field.clone()),
                                src.field(field),
                                vir::AssignKind::Move)
                        );
                        alloc_stmts
                    }
                    _ => {
                        // Just move.
                        let move_assign = vir::Stmt::Assign(
                            lhs.clone(), src, vir::AssignKind::Move);
                        vec![move_assign]
                    }
                };

                // Store a label for this state
                let label = self.cfg_method.get_fresh_label_name();
                debug!("Current loc {:?} has label {}", location, label);
                self.label_after_location.insert(location, label.clone());
                stmts.push(vir::Stmt::Label(label.clone()));

                stmts
            }

            &mir::Operand::Copy(ref place) => {
                let (src, ty, _) = self.mir_encoder.encode_place(place);

                let mut stmts = if self.mir_encoder.is_reference(ty) {
                    let loan = self.polonius_info.get_loan_at_location(location);
                    let ref_field = self.encoder.encode_value_field(ty);
                    let mut stmts = self.prepare_assign_target(
                        lhs.clone(), ref_field.clone(), location,
                        vir::AssignKind::SharedBorrow(loan));
                    stmts.push(
                        vir::Stmt::Assign(
                            lhs.clone().field(ref_field.clone()),
                            src.field(ref_field),
                            vir::AssignKind::SharedBorrow(loan)
                        )
                    );
                    stmts
                } else {
                    self.encode_copy2(src, lhs.clone(), ty, location)
                };

                // Store a label for this state
                let label = self.cfg_method.get_fresh_label_name();
                debug!("Current loc {:?} has label {}", location, label);
                self.label_after_location.insert(location, label.clone());
                stmts.push(vir::Stmt::Label(label.clone()));

                stmts
            }

            &mir::Operand::Constant(box mir::Constant { ty, ref literal, .. }) => {
                let field = self.encoder.encode_value_field(ty);
                let mut stmts = self.prepare_assign_target(
                    lhs.clone(), field.clone(), location, vir::AssignKind::Copy);
                // Initialize the constant
                match literal {
                    mir::Literal::Value { value } => {
                        let const_val = self.encoder.encode_const_expr(value);
                        // Initialize value of lhs
                        stmts.push(
                            vir::Stmt::Assign(
                                lhs.clone().field(field),
                                const_val,
                                vir::AssignKind::Copy
                            )
                        );
                    }
                    mir::Literal::Promoted { index } => {
                        trace!("promoted constant literal {:?}: {:?}", index, ty);
                        trace!("{:?}", self.mir.promoted[*index].basic_blocks());
                        trace!("{:?}", self.mir.promoted[*index].basic_blocks().into_iter().next().unwrap().statements[0]);
                        // TODO: call eval_const
                        debug!("Encoding of promoted constant literal '{:?}: {:?}' is incomplete", index, ty);
                        // Workaround: do not initialize values
                    }
                }
                stmts
            }
        };
        debug!("[enter] encode_assign_operand(lhs={}, operand={:?}, location={:?}) = {}",
               lhs, operand, location, vir::stmts_to_str(&stmts));
        stmts
    }

    fn encode_assign_binary_op(
        &mut self,
        op: mir::BinOp,
        left: &mir::Operand<'tcx>,
        right: &mir::Operand<'tcx>,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_binary_op(op={:?}, left={:?}, right={:?})",
               op, left, right);
        let encoded_left = self.mir_encoder.encode_operand_expr(left);
        let encoded_right = self.mir_encoder.encode_operand_expr(right);
        let encoded_value = self.mir_encoder.encode_bin_op_expr(
            op, encoded_left, encoded_right, ty);
        self.encode_copy_value_assign(encoded_lhs, encoded_value, ty, location)
    }

    fn encode_copy_value_assign(
        &mut self,
        encoded_lhs: vir::Expr,
        encoded_rhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        let field = self.encoder.encode_value_field(ty);
        self.encode_copy_value_assign2(encoded_lhs, encoded_rhs, field, location)
    }

    fn encode_assign_checked_binary_op(
        &mut self,
        op: mir::BinOp,
        left: &mir::Operand<'tcx>,
        right: &mir::Operand<'tcx>,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_checked_binary_op(op={:?}, left={:?}, right={:?})",
               op, left, right);
        let operand_ty = if let ty::TypeVariants::TyTuple(ref types) = ty.sty {
            types[0].clone()
        } else {
            unreachable!()
        };
        let encoded_left = self.mir_encoder.encode_operand_expr(left);
        let encoded_right = self.mir_encoder.encode_operand_expr(right);
        let encoded_value = self.mir_encoder.encode_bin_op_expr(
            op, encoded_left.clone(), encoded_right.clone(), operand_ty);
        let encoded_check = self.mir_encoder.encode_bin_op_check(
            op, encoded_left, encoded_right, operand_ty);
        let field_types = if let ty::TypeVariants::TyTuple(ref x) = ty.sty {
            x
        } else {
            unreachable!()
        };
        let value_field = self.encoder.encode_raw_ref_field(
            "tuple_0".to_string(), field_types[0]);
        let value_field_value = self.encoder.encode_value_field(field_types[0]);
        let check_field = self.encoder.encode_raw_ref_field(
            "tuple_1".to_string(), field_types[1]);
        let check_field_value = self.encoder.encode_value_field(field_types[1]);
        let mut stmts = if !self.init_info.is_vir_place_accessible(&encoded_lhs, location) {
            let mut alloc_stmts = self.encode_havoc(&encoded_lhs);
            let mut inhale_acc = |place| {
                alloc_stmts.push(
                    vir::Stmt::Inhale(
                        vir::Expr::acc_permission(place, vir::PermAmount::Write)
                    )
                );
            };
            inhale_acc(encoded_lhs.clone().field(value_field.clone()));
            inhale_acc(encoded_lhs.clone().field(value_field.clone())
                                          .field(value_field_value.clone()));
            inhale_acc(encoded_lhs.clone().field(check_field.clone()));
            inhale_acc(encoded_lhs.clone().field(check_field.clone())
                                          .field(check_field_value.clone()));
            alloc_stmts
        } else {
            Vec::with_capacity(2)
        };
        // Initialize lhs.field
        stmts.push(
            vir::Stmt::Assign(
                encoded_lhs.clone()
                    .field(value_field)
                    .field(value_field_value),
                encoded_value,
                vir::AssignKind::Copy
            )
        );
        stmts.push(
            vir::Stmt::Assign(
                encoded_lhs
                    .field(check_field)
                    .field(check_field_value),
                encoded_check,
                vir::AssignKind::Copy
            )
        );
        stmts
    }

    fn encode_assign_unary_op(
        &mut self,
        op: mir::UnOp,
        operand: &mir::Operand<'tcx>,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_unary_op(op={:?}, operand={:?})", op, operand);
        let encoded_val = self.mir_encoder.encode_operand_expr(operand);
        let encoded_value = self.mir_encoder.encode_unary_op_expr(op, encoded_val);
        // Initialize `lhs.field`
        self.encode_copy_value_assign(encoded_lhs, encoded_value, ty, location)
    }

    fn encode_assign_nullary_op(
        &mut self,
        op: mir::NullOp,
        op_ty: ty::Ty<'tcx>,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_nullary_op(op={:?}, op_ty={:?})", op, op_ty);
        match op {
            mir::NullOp::Box => {
                assert_eq!(op_ty, ty.boxed_ty());
                let ref_field = self.encoder.encode_dereference_field(op_ty);
                let box_content = encoded_lhs.clone().field(ref_field.clone());

                let mut stmts = self.prepare_assign_target(
                    encoded_lhs, ref_field, location, vir::AssignKind::Move);

                // Allocate `box_content`
                stmts.extend(self.encode_havoc_and_allocation(&box_content));

                // Leave `box_content` uninitialized
                stmts
            }
            mir::NullOp::SizeOf => unimplemented!(),
        }
    }

    fn encode_assign_discriminant(
        &mut self,
        src: &mir::Place<'tcx>,
        location: mir::Location,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_discriminant(src={:?}, location={:?})", src, location);
        let (encoded_src, src_ty, _) = self.mir_encoder.encode_place(src);
        match src_ty.sty {
            ty::TypeVariants::TyAdt(ref adt_def, _) if !adt_def.is_box() => {
                let num_variants = adt_def.variants.len();
                // Initialize `lhs.int_field`
                // Note: in our encoding an enumeration with just one variant has
                // no discriminant
                if num_variants > 1 {
                    let encoded_rhs = self.encoder.encode_discriminant_func_app(
                        self.translate_maybe_borrowed_place(location, encoded_src),
                        adt_def
                    );
                    self.encode_copy_value_assign(encoded_lhs.clone(), encoded_rhs, ty, location)
                } else {
                    vec![]
                }
            }

            ty::TypeVariants::TyInt(_) |
            ty::TypeVariants::TyUint(_) => {
                let value_field = self.encoder.encode_value_field(src_ty);
                let discr_value: vir::Expr = self.translate_maybe_borrowed_place(
                    location,
                    encoded_src.field(value_field)
                );
                self.encode_copy_value_assign(encoded_lhs.clone(), discr_value, ty, location)
            }

            ref x => {
                debug!("The discriminant of type {:?} is not defined", x);
                vec![]
            }
        }
    }

    fn encode_assign_ref(
        &mut self,
        mir_borrow_kind: mir::BorrowKind,
        place: &mir::Place<'tcx>,
        location: mir::Location,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_assign_ref(mir_borrow_kind={:?}, place={:?}, location={:?})",
               mir_borrow_kind, place, location);
        let (encoded_value, _, _) = self.mir_encoder.encode_place(place);
        let loan = self.polonius_info.get_loan_at_location(location);
        let vir_assign_kind = match mir_borrow_kind {
            mir::BorrowKind::Shared => vir::AssignKind::SharedBorrow(loan),
            mir::BorrowKind::Unique => unimplemented!(),
            mir::BorrowKind::Mut { .. } => vir::AssignKind::MutableBorrow(loan),
        };
        // Initialize ref_var.ref_field
        let field = self.encoder.encode_value_field(ty);
        let mut stmts = self.prepare_assign_target(
            encoded_lhs.clone(), field.clone(), location, vir_assign_kind);
        stmts.push(
            vir::Stmt::Assign(
                encoded_lhs.field(field),
                encoded_value,
                vir_assign_kind,
            )
        );
        // Store a label for this state
        let label = self.cfg_method.get_fresh_label_name();
        debug!("Current loc {:?} has label {}", location, label);
        self.label_after_location.insert(location, label.clone());
        stmts.push(vir::Stmt::Label(label.clone()));
        stmts
    }

    fn encode_cast(
        &mut self,
        operand: &mir::Operand<'tcx>,
        dst_ty: ty::Ty<'tcx>,
        encoded_lhs: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_cast(operand={:?}, dst_ty={:?})", operand, dst_ty);
        let encoded_val = self.mir_encoder.encode_cast_expr(operand, dst_ty);
        self.encode_copy_value_assign(encoded_lhs, encoded_val, ty, location)
    }

    pub fn get_auxiliar_local_var(&mut self, suffix: &str, vir_type: vir::Type) -> vir::LocalVar {
        let name = format!("_aux_{}_{}", suffix, vir_type.name());
        if self.auxiliar_local_vars.contains_key(&name) {
            assert_eq!(self.auxiliar_local_vars[&name], vir_type);
        } else {
            self.cfg_method.add_local_var(&name, vir_type.clone());
            self.auxiliar_local_vars.insert(name.clone(), vir_type.clone());
        }
        vir::LocalVar::new(name, vir_type)
    }

    #[deprecated(note="please use `encode_havoc_content` instead")]
    fn encode_havoc(&mut self, dst: &vir::Expr) -> Vec<vir::Stmt> {
        debug!("Encode havoc {:?}", dst);
        // TODO: Can we encode the havoc with an exhale + inhale?
        let havoc_ref_method_name = self.encoder.encode_builtin_method_use(BuiltinMethodKind::HavocRef);
        if let &vir::Expr::Local(ref dst_local_var, ref _pos) = dst {
            vec![
                vir::Stmt::MethodCall(havoc_ref_method_name, vec![], vec![dst_local_var.clone()]),
            ]
        } else {
            let tmp_var = self.get_auxiliar_local_var("havoc", dst.get_type().clone());
            vec![
                vir::Stmt::MethodCall(havoc_ref_method_name, vec![], vec![tmp_var.clone()]),
                vir::Stmt::Assign(dst.clone().into(), tmp_var.into(), vir::AssignKind::Move),
            ]
        }
    }

    /// Havoc and assume permission on fields
    #[deprecated(note="please use `encode_havoc_content` instead")]
    fn encode_havoc_and_allocation(&mut self, dst: &vir::Expr) -> Vec<vir::Stmt> {
        debug!("Encode havoc and allocation {:?}", dst);

        let mut stmts = vec![];
        // Havoc `dst`
        stmts.extend(
            self.encode_havoc(dst)
        );
        // Allocate `dst`
        stmts.push(
            vir::Stmt::Inhale(
                self.mir_encoder.encode_place_predicate_permission(dst.clone(), vir::PermAmount::Write).unwrap()
            )
        );
        stmts
    }

    /// Havoc the content (Viper fields) of a place.
    /// The place itself (Viper reference) does not change.
    fn encode_havoc_content(&mut self, dst: &vir::Expr) -> Vec<vir::Stmt> {
        debug!("Encode havoc content {:?}", dst);
        let type_predicate = self.mir_encoder.encode_place_predicate_permission(dst.clone(), vir::PermAmount::Write).unwrap();
        let pos = self.encoder.error_manager().register(
            // TODO: choose a better error span
            self.mir.span,
            ErrorCtxt::Unexpected
        );
        vec![
            vir::Stmt::Exhale(type_predicate.clone(), pos),
            vir::Stmt::Inhale(type_predicate),
        ]
    }

    fn encode_spec_place_permission(&self, place: &vir::Expr) -> vir::Expr {
        if let Some(field_place) = place.try_deref() {
            vir::Expr::acc_permission(field_place, vir::PermAmount::Write)
        } else {
            self.mir_encoder.encode_place_predicate_permission(
                place.clone(), vir::PermAmount::Write).unwrap()
        }
    }

    /// Prepare the ``dst`` to be copy target:
    ///
    /// 1.  Havoc and allocate if it is not yet allocated.
    fn prepare_assign_target(
        &mut self,
        dst: vir::Expr,
        field: vir::Field,
        location: mir::Location,
        vir_assign_kind: vir::AssignKind,
    ) -> Vec<vir::Stmt> {
        trace!("[enter] prepare_assign_target(dst={}, field={}, location={:?})",
               dst, field, location);
        if !self.init_info.is_vir_place_accessible(&dst, location) {
            let mut alloc_stmts = self.encode_havoc(&dst);
            let dst_field = dst.clone().field(field.clone());
            let acc = vir::Expr::acc_permission(dst_field, vir::PermAmount::Write);
            alloc_stmts.push(vir::Stmt::Inhale(acc));
            match vir_assign_kind {
                vir::AssignKind::Copy => {
                    if field.typ.is_ref() {
                        unimplemented!("Inhale the predicate rooted at dst_field.");
                    }
                },
                vir::AssignKind::Move |
                vir::AssignKind::MutableBorrow(_) |
                vir::AssignKind::SharedBorrow(_) => {},
                vir::AssignKind::Ghost => unreachable!(),
            }
            debug!("alloc_stmts = {}", alloc_stmts.iter().to_string());
            alloc_stmts
        } else {
            Vec::with_capacity(1)
        }
    }

    /// Encode value copy assignment. Havoc and allocate the target if necessary.
    fn encode_copy_value_assign2(
        &mut self,
        lhs: vir::Expr,
        rhs: vir::Expr,
        field: vir::Field,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        let mut stmts = self.prepare_assign_target(
            lhs.clone(), field.clone(), location, vir::AssignKind::Copy);
        stmts.push(
            vir::Stmt::Assign(
                lhs.field(field),
                rhs,
                vir::AssignKind::Copy
            )
        );
        stmts
    }

    /// Copy a primitive value such as an integer. Allocate the target
    /// if necessary.
    fn encode_copy_primitive_value(
        &mut self,
        src: vir::Expr,
        dst: vir::Expr,
        ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        let field = self.encoder.encode_value_field(ty);
        self.encode_copy_value_assign2(dst, src.field(field.clone()), field, location)
    }

    fn encode_deep_copy_adt(
        &mut self,
        src: vir::Expr,
        dst: vir::Expr,
        adt_def: &ty::AdtDef,
        subst: &ty::Slice<ty::subst::Kind<'tcx>>,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        let mut stmts = self.encode_havoc(&dst);
        let pred = vir::Expr::pred_permission(dst.clone(), vir::PermAmount::Write).unwrap();
        stmts.push(vir::Stmt::Inhale(pred));
        let tcx = self.encoder.env().tcx();
        let num_variants = adt_def.variants.len();
        if num_variants == 1 {
            // A struct.
            let variant_def = &adt_def.variants[0];
            for field in &variant_def.fields {
                let field_name = &field.ident.as_str();
                let field_ty = field.ty(tcx, subst);
                let elem_field = self.encoder.encode_struct_field(field_name, field_ty);
                stmts.extend(
                    // Copy fields
                    // TODO: Refactor. encode_copy is old code that does not allocate the target.
                    self.encode_copy(
                        src.clone().field(elem_field.clone()),
                        dst.clone().field(elem_field.clone()),
                        field_ty,
                        false,
                        true,
                        location
                    )
                )
            }
        } else {
            // An enum.
            let discriminant_field = self.encoder.encode_discriminant_field();
            stmts.push(
                // Copy discriminant
                vir::Stmt::Assign(
                    dst.clone().field(discriminant_field.clone()),
                    src.clone().field(discriminant_field.clone()).into(),
                    vir::AssignKind::Copy
                )
            );
            for variant_def in adt_def.variants.iter() {
                let variant_name = &variant_def.name.as_str();
                for field in &variant_def.fields {
                    let field_name = &field.ident.as_str();
                    let field_ty = field.ty(tcx, subst);
                    let elem_field = self.encoder.encode_struct_field(field_name, field_ty);
                    stmts.extend(
                        // Copy fields
                        // TODO: Refactor. encode_copy is old code that does not allocate the target.
                        self.encode_copy(
                            src.clone().variant(variant_name).field(elem_field.clone()),
                            dst.clone().variant(variant_name).field(elem_field.clone()),
                            field_ty,
                            false,
                            true,
                            location
                        )
                    )
                }
            }
        }
        stmts
    }

    fn encode_deep_copy_tuple(
        &mut self,
        src: vir::Expr,
        dst: vir::Expr,
        elems: &ty::Slice<&'tcx ty::TyS<'tcx>>,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        let mut stmts = self.encode_havoc(&dst);
        for (field_num, ty) in elems.iter().enumerate() {
            let field_name = format!("tuple_{}", field_num);
            let field = self.encoder.encode_raw_ref_field(field_name, ty);
            let dst_field = dst.clone().field(field.clone());
            let acc = vir::Expr::acc_permission(dst_field.clone(), vir::PermAmount::Write);
            let pred = vir::Expr::pred_permission(dst_field.clone(), vir::PermAmount::Write).unwrap();
            stmts.push(vir::Stmt::Inhale(acc));
            stmts.push(vir::Stmt::Inhale(pred));

            stmts.extend(
                // Copy fields
                self.encode_copy(
                    src.clone().field(field.clone()),
                    dst_field,
                    ty,
                    false,
                    true,
                    location
                )
            );
        }
        stmts
    }

    fn encode_copy2(
        &mut self,
        src: vir::Expr,
        dst: vir::Expr,
        self_ty: ty::Ty<'tcx>,
        location: mir::Location,
    ) -> Vec<vir::Stmt> {
        let stmts = match self_ty.sty {
            ty::TypeVariants::TyBool |
            ty::TypeVariants::TyInt(_) |
            ty::TypeVariants::TyUint(_) |
            ty::TypeVariants::TyChar => {
                self.encode_copy_primitive_value(src, dst, self_ty, location)
            },
            ty::TypeVariants::TyAdt(adt_def, subst) if !adt_def.is_box() => {
                self.encode_deep_copy_adt(src, dst, adt_def, subst, location)
            }
            ty::TypeVariants::TyTuple(elems) => {
                self.encode_deep_copy_tuple(src, dst, elems, location)
            }
            ty::TypeVariants::TyParam(_) => {
                self.encode_havoc_and_allocation(&dst.clone())
            }

            ref x => unimplemented!("{:?}", x),
        };
        stmts
    }

    /// Encodes the copy of a structure, reading from a source `src` and using `dst` as target.
    /// The copy is neither shallow nor deep:
    /// - if a field encodes a Rust reference, the reference is copied (shallow copy);
    /// - if a field does not encode a Rust reference, but is a Viper reference, a recursive call
    ///   copies the content of the field (deep copy).
    /// - if a field does not encode a Rust reference and is not a Viper reference, the field is
    ///   copied.
    ///
    /// The `is_move` parameter is used just to assert that a reference is only copied when encoding
    /// a Rust move assignment, and not a copy assignment.
    fn encode_copy(
        &mut self,
        src: vir::Expr,
        dst: vir::Expr,
        self_ty: ty::Ty<'tcx>,
        is_move: bool,
        is_inner_ty: bool,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        trace!("[enter] encode_copy(src={}, dst={}, self_ty={:?}, is_move={}, \
                is_inner_ty={}, location={:?})",
               src, dst, self_ty, is_move, is_inner_ty, location);

        let stmts = match self_ty.sty {
            ty::TypeVariants::TyBool |
            ty::TypeVariants::TyInt(_) |
            ty::TypeVariants::TyUint(_) |
            ty::TypeVariants::TyChar => {
                let field = self.encoder.encode_value_field(self_ty);
                vec![
                    // Copy value
                    vir::Stmt::Assign(
                        dst.clone().field(field.clone()),
                        src.clone().field(field.clone()).into(),
                        vir::AssignKind::Copy
                    )
                ]
            }

            ty::TypeVariants::TyTuple(elems) => {
                let mut stmts: Vec<vir::Stmt> = vec![];
                for (field_num, ty) in elems.iter().enumerate() {
                    let field_name = format!("tuple_{}", field_num);
                    let field = self.encoder.encode_raw_ref_field(field_name, ty);
                    stmts.extend(
                        // Copy fields
                        self.encode_copy(
                            src.clone().field(field.clone()),
                            dst.clone().field(field.clone()),
                            ty,
                            is_move,
                            true,
                            location
                        )
                    );
                }
                stmts
            }

            ty::TypeVariants::TyAdt(ref adt_def, ref subst) if !adt_def.is_box() => {
                let mut stmts: Vec<vir::Stmt> = vec![];
                let tcx = self.encoder.env().tcx();
                let num_variants = adt_def.variants.len();
                if num_variants == 1 {
                    // A struct.
                    let variant_def = &adt_def.variants[0];
                    for field in &variant_def.fields {
                        let field_name = &field.ident.as_str();
                        let field_ty = field.ty(tcx, subst);
                        let elem_field = self.encoder.encode_struct_field(field_name, field_ty);
                        stmts.extend(
                            // Copy fields
                            self.encode_copy(
                                src.clone().field(elem_field.clone()),
                                dst.clone().field(elem_field.clone()),
                                field_ty,
                                is_move,
                                true,
                                location
                            )
                        )
                    }
                } else {
                    // An enum.
                    let discriminant_field = self.encoder.encode_discriminant_field();
                    stmts.push(
                        // Copy discriminant
                        vir::Stmt::Assign(
                            dst.clone().field(discriminant_field.clone()),
                            src.clone().field(discriminant_field.clone()).into(),
                            vir::AssignKind::Copy
                        )
                    );
                    for variant_def in adt_def.variants.iter() {
                        let variant_name = &variant_def.name.as_str();
                        for field in &variant_def.fields {
                            let field_name = &field.ident.as_str();
                            let field_ty = field.ty(tcx, subst);
                            let elem_field = self.encoder.encode_struct_field(field_name, field_ty);
                            stmts.extend(
                                // Copy fields
                                self.encode_copy(
                                    src.clone().variant(variant_name).field(elem_field.clone()),
                                    dst.clone().variant(variant_name).field(elem_field.clone()),
                                    field_ty,
                                    is_move,
                                    true,
                                    location
                                )
                            )
                        }
                    }
                }
                stmts
            }

            ty::TypeVariants::TyRawPtr(ty::TypeAndMut { ty, .. }) |
            ty::TypeVariants::TyRef(_, ty, _) => {
                unreachable!();
            }

            ty::TypeVariants::TyAdt(ref adt_def, ref subst) if adt_def.is_box() => {
                // Box type
                unreachable!();
            }

            ty::TypeVariants::TyParam(_) => {
                unreachable!();
            }

            ref x => unimplemented!("{:?}", x),
        };

        trace!("[exit] encode_copy(src={}, dst={}, self_ty={:?}, is_move={}, \
                is_inner_ty={}, location={:?}) = {}",
               src, dst, self_ty, is_move, is_inner_ty, location, vir::stmts_to_str(&stmts));
        stmts
    }

    fn encode_assign_aggregate(
        &mut self,
        dst: &vir::Expr,
        ty: ty::Ty<'tcx>,
        aggregate: &mir::AggregateKind<'tcx>,
        operands: &Vec<mir::Operand<'tcx>>,
        location: mir::Location
    ) -> Vec<vir::Stmt> {
        debug!("[enter] encode_assign_aggregate({:?}, {:?})", aggregate, operands);
        let mut stmts = self.encode_havoc_and_allocation(dst);
        // Initialize values
        match aggregate {
            &mir::AggregateKind::Tuple => {
                let field_types = if let ty::TypeVariants::TyTuple(ref x) = ty.sty { x } else { unreachable!() };
                for (field_num, operand) in operands.iter().enumerate() {
                    let field_name = format!("tuple_{}", field_num);
                    let encoded_field = self.encoder.encode_raw_ref_field(field_name, field_types[field_num]);
                    stmts.extend(
                        self.encode_assign_operand(&dst.clone().field(encoded_field), operand, location)
                    );
                }
                stmts
            }

            &mir::AggregateKind::Adt(adt_def, variant_index, subst, _) => {
                let num_variants = adt_def.variants.len();
                let variant_def = &adt_def.variants[variant_index];
                let mut dst_base = dst.clone();
                if num_variants != 1 {
                    // An enum.
                    let tcx = self.encoder.env().tcx();
                    let discr_field = self.encoder.encode_discriminant_field();
                    // Handle *signed* discriminats
                    let discr_value: vir::Expr = if let SignedInt(ity) = adt_def.repr.discr_type() {
                        let bit_size = layout::Integer::from_attr(
                            self.encoder.env().tcx(),
                            SignedInt(ity)
                        ).size().bits();
                        let shift = 128 - bit_size;
                        let unsigned_discr = adt_def.discriminant_for_variant(tcx, variant_index).val;
                        let casted_discr = unsigned_discr as i128;
                        // sign extend the raw representation to be an i128
                        ((casted_discr << shift) >> shift).into()
                    } else {
                        adt_def.discriminant_for_variant(tcx, variant_index).val.into()
                    };
                    stmts.push(
                        vir::Stmt::Assign(
                            dst.clone().field(discr_field).into(),
                            discr_value,
                            vir::AssignKind::Copy
                        )
                    );
                    let variant_name = &variant_def.name.as_str();
                    dst_base = dst_base.variant(variant_name);
                }
                for (field_index, field) in variant_def.fields.iter().enumerate() {
                    let operand = &operands[field_index];
                    let field_name = &field.ident.as_str();
                    let tcx = self.encoder.env().tcx();
                    let field_ty = field.ty(tcx, subst);
                    let encoded_field = self.encoder.encode_struct_field(field_name, field_ty);
                    stmts.extend(
                        self.encode_assign_operand(&dst_base.clone().field(encoded_field), operand, location)
                    );
                }
                stmts
            }

            ref x => unimplemented!("{:?}", x)
        }
    }

    fn check_vir(&self) {
        fn invalid(reson: String) {
            debug!("Invalid VIR: {}", reson);
            debug_assert!(false, "Invalid VIR: {}", reson);
        }

        let mut encoded_mir_locals = HashSet::new();
        for local in self.mir.local_decls.indices() {
            encoded_mir_locals.insert(
                self.mir_encoder.encode_local(local)
            );
        }
    }
}

