<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testing - Prusti user guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="../tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tour/setup.html"><strong aria-hidden="true">4.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../tour/getting-started.html"><strong aria-hidden="true">4.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../tour/new.html"><strong aria-hidden="true">4.3.</strong> New</a></li><li class="chapter-item expanded "><a href="../tour/push.html"><strong aria-hidden="true">4.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="../tour/pop.html"><strong aria-hidden="true">4.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="../tour/testing.html" class="active"><strong aria-hidden="true">4.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../tour/option.html"><strong aria-hidden="true">4.7.</strong> Option</a></li><li class="chapter-item expanded "><a href="../tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="../tour/pledges.html"><strong aria-hidden="true">4.10.</strong> Pledges (mutable peek)</a></li><li class="chapter-item expanded "><a href="../tour/final.html"><strong aria-hidden="true">4.11.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="../tour/loop_invariants.html"><strong aria-hidden="true">4.12.</strong> Loop Invariants</a></li><li class="chapter-item expanded "><a href="../tour/counterexamples.html"><strong aria-hidden="true">4.13.</strong> Counterexamples</a></li></ol></li><li class="chapter-item expanded "><a href="../verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="../verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="../verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="../verify/assert_refute_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions, refutations and assumptions</a></li><li class="chapter-item expanded "><a href="../verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="../verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="../verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="../verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="../verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="../verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="../verify/type_cond_spec.html"><strong aria-hidden="true">5.11.</strong> Type-conditional spec refinements</a></li><li class="chapter-item expanded "><a href="../verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="../verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="../verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="../verify/counterexample.html"><strong aria-hidden="true">5.15.</strong> Counterexamples</a></li><li class="chapter-item expanded "><a href="../verify/impl_block_specs.html"><strong aria-hidden="true">5.16.</strong> Specifications in trait impl blocks</a></li></ol></li><li class="chapter-item expanded "><a href="../syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-test.html">2.6: Testing</a>,</p>
</blockquote>
<p>The linked chapter in the "Learning Rust With Entirely Too Many Linked Lists" tutorial explains how testing normal Rust code works. In this chapter we will show some differences between testing and verification and of the guarantees that each provides.</p>
<p>Note: Normal tests (marked with <code>#[cfg(test)]</code> or <code>#[test]</code>) are currently <em><strong>not</strong></em> checked by Prusti, but this may be added in the future. If you remove the <code>test</code> markers, Prusti will check any test like it would a normal function.</p>
<h2 id="differing-guarantees-of-verification-and-testing"><a class="header" href="#differing-guarantees-of-verification-and-testing">Differing guarantees of verification and testing</a></h2>
<p>Static verification has stronger guarantees than testing.
Running tests is only be possible for a small subset of all possible input values.
Take as an example a function taking a single value of type <code>u64</code>. The range of potential inputs is <code>0</code> to <code>2^64 - 1</code>, or <code>2^64</code> total values. Assuming each value takes 1 nano-second to test, it would take approximately <code>584.5</code> years to exhaustively test just this single function.</p>
<!-- (2^64)/1000000000 / 60 / 60 / 24 / 365.25 = 584.54204609062639795168200370117 -->
<p>In contrast, a static verifier like Prusti is able to check the entire input space of a function with the help of the specifications of each function.</p>
<p>When verification succeeds, you are guaranteed to not have a bug like a crash, overflow, or return value not fitting the specification.
This assumes that you have manually verified any <code>#[trusted]</code> functions and have checked for correct termination of all functions.
If the verification fails, you may have a bug, or your specifications are not strong enough.</p>
<p>The guarantees of testing are different. If a test fails, you know that you have a bug (either in the code or the test), but if all your tests pass, you might still have some bugs, just not with the specific inputs used in the tests.</p>
<p>In other words: Testing can show the <em>presence</em> of bugs, verification can show the <em>absence</em> of bugs.</p>
<p>It might still be worth writing (and running) some unit tests even for verified code, as they can serve as documentation on using a function. If you made some mistake in both the code and the specification, you may notice it if you write a test for it or use that function in another verified function.</p>
<p>The next section shows some potential issues with specifications.</p>
<h2 id="examples-of-bugs-in-specifications"><a class="header" href="#examples-of-bugs-in-specifications">Examples of bugs in specifications</a></h2>
<!-- We have written some specifications in the previous chapters, but we didn't check if they are actually correct or useful. For example, a -->
<p>The specification for a function could have a precondition that is too restrictive. If you never use the function in another verified function, you may not notice this:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[requires(x == 10)] // Restrictive precondition
#[ensures(result == x * x)]
pub fn restrictive_square(x: i32) -&gt; i32 {
    x * x
}

fn test() {
    assert!(restrictive_square(10) == 100); // Works
    assert!(restrictive_square(5) == 25); //~ ERROR precondition might not hold.
}</code></pre>
<p>This function is correct (ignoring potential overflows), but it is not useful, since the input must be <code>10</code>.</p>
<p>Another potential problem could be an incomplete postcondition. The <code>abs</code> function below should return the absolute value of <code>x</code>, but it only works for positive values. The verification will still succeed, because the postcondition does not specify the result for <code>x &lt; 0</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[pure]
// Note that a postcondition is not actually needed here, since `abs` is #[pure]
#[ensures(x &gt;= 0 ==&gt; result == x)]
pub fn abs(x: i32) -&gt; i32 {
    x
}

fn test_abs() {
    prusti_assert!(abs(8) == 8); // Works
    prusti_assert!(abs(-10) == 10); //~ ERROR the asserted expression might not hold
}</code></pre>
<p>This bug will be noticed as soon as you try using <code>abs</code> with a negative input.
For functions internal to a project, you will likely notice mistakes in the specification when you try to use the function in other code. However, when you have public functions, like for example in a library, you might want to write some test functions for your specification. Specification errors sometimes only show up when they are actually used.</p>
<h2 id="testing-our-linked-list-specifications"><a class="header" href="#testing-our-linked-list-specifications">Testing our linked list specifications</a></h2>
<p>To check our specifications and code, we could write a function that relies on the expected behavior. We can create a new namespace for the test, here we call it <code>prusti_tests</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;

    fn _test_list(){
        let mut list = List::new(); // create an new, empty list
        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty

        list.push(5);
        list.push(10);
        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
        prusti_assert!(list.lookup(0) == 10); // head is 10
        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly

        let x = list.pop();
        prusti_assert!(x == 10); // pop returns the value that was added last

        match list.try_pop() {
            Some(y) =&gt; assert!(y == 5),
            None =&gt; unreachable!()
        }

        let z = list.try_pop();
        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
    }
<span class="boring">
</span><span class="boring">    // This shows a test that takes 2 lists as input parameters:
</span><span class="boring">    #[requires(list_0.len() &gt;= 4)]
</span><span class="boring">    #[requires(!list_1.is_empty())]
</span><span class="boring">    #[requires(list_0.lookup(1) == 42)]
</span><span class="boring">    #[requires(list_0.lookup(3) == list_1.lookup(0))]
</span><span class="boring">    fn _test_lists(list_0: &amp;mut List, list_1: &amp;mut List) {
</span><span class="boring">        let x0 = list_0.pop();
</span><span class="boring">
</span><span class="boring">        list_0.push(10);
</span><span class="boring">        prusti_assert!(list_0.len() &gt;= 4);
</span><span class="boring">        prusti_assert!(list_0.lookup(1) == 42);
</span><span class="boring">        assert!(list_0.pop() == 10); // Cannot be `prusti_assert`, `pop` changes the list
</span><span class="boring">
</span><span class="boring">        let x1 = list_0.pop();
</span><span class="boring">        let x2 = list_0.pop();
</span><span class="boring">        let x3 = list_0.pop();
</span><span class="boring">        prusti_assert!(x0 == old(snap(list_0)).lookup(0));
</span><span class="boring">        prusti_assert!(x1 == old(snap(list_0)).lookup(1) &amp;&amp; x1 == 42);
</span><span class="boring">        prusti_assert!(x2 == old(snap(list_0)).lookup(2));
</span><span class="boring">        prusti_assert!(x3 == old(snap(list_0)).lookup(3));
</span><span class="boring">        
</span><span class="boring">        let y0 = list_1.pop();
</span><span class="boring">        prusti_assert!(y0 == old(snap(list_1)).lookup(0));
</span><span class="boring">        prusti_assert!(y0 == x3);
</span><span class="boring">    }
</span>}
// Prusti: verifies</code></pre>
<!-- We can also have tests that take arguments and also have pre- and postconditions:

```rust,noplaypen
# // The next line is only required for doctests, you can ignore/remove it
# extern crate prusti_contracts;
# use prusti_contracts::*;
# 
# fn main() {}
# 
# pub struct List {
#     head: Link,
# }
# 
# enum Link {
#     Empty,
#     More(Box<Node>),
# }
# 
# struct Node {
#     elem: i32,
#     next: Link,
# }
# 
# #[extern_spec(std::mem)]
# #[ensures(snap(dest) === src)]
# #[ensures(result === old(snap(dest)))]
# fn replace<T>(dest: &mut T, src: T) -> T;
# 
# // Specs for std::option::Option<T>::unwrap(self) (and others) can be found here (work in progress):
# // https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
# 
# #[extern_spec]
# impl<T> std::option::Option<T> {
#     #[requires(self.is_some())]
#     #[ensures(old(self) === Some(result))]
#     pub fn unwrap(self) -> T;
#     
#     #[pure]
#     #[ensures(result == matches!(self, None))]
#     pub const fn is_none(&self) -> bool;
# 
#     #[pure]
#     #[ensures(result == matches!(self, Some(_)))]
#     pub const fn is_some(&self) -> bool;
# }
# 
# impl List {
#     #[pure]
#     pub fn len(&self) -> usize {
#         self.head.len()
#     }
# 
#     #[pure]
#     fn is_empty(&self) -> bool {
#         self.head.is_empty()
#     }
# 
#     #[ensures(result.len() == 0)]
#     pub fn new() -> Self {
#         List { head: Link::Empty }
#     }
# 
#     #[pure]
#     #[requires(index < self.len())]
#     pub fn lookup(&self, index: usize) -> i32 {
#         self.head.lookup(index)
#     }
# 
#     #[ensures(self.len() == old(self.len()) + 1)]
#     #[ensures(self.lookup(0) == elem)]
#     #[ensures(forall(|i: usize| (i < old(self.len())) ==>
#                  old(self.lookup(i)) == self.lookup(i + 1)))]
#     pub fn push(&mut self, elem: i32) {
#         let new_node = Box::new(Node {
#             elem,
#             next: std::mem::replace(&mut self.head, Link::Empty),
#         });
# 
#         self.head = Link::More(new_node);
#     }
# 
#     predicate! {
#         // two-state predicate to check if the head of a list was correctly removed
#         fn head_removed(&self, prev: &Self) -> bool {
#             self.len() == prev.len() - 1 // The length will decrease by 1
#             && forall(|i: usize| // Every element will be shifted forwards by one
#                 (1 <= i && i < prev.len())
#                     ==> prev.lookup(i) == self.lookup(i - 1))
#         }
#     }
# 
#     #[ensures(old(self.is_empty()) ==>
#         result.is_none() &&
#         self.is_empty()
#     )]
#     #[ensures(!old(self.is_empty()) ==>
#         self.head_removed(&old(snap(self)))
#         &&
#         result === Some(old(snap(self)).lookup(0))
#     )]
#     pub fn try_pop(&mut self) -> Option<i32> {
#         match std::mem::replace(&mut self.head, Link::Empty) {
#             Link::Empty => None,
#             Link::More(node) => {
#                 self.head = node.next;
#                 Some(node.elem)
#             }
#         }
#     }
# 
#     #[requires(!self.is_empty())]
#     #[ensures(self.head_removed(&old(snap(self))))]
#     #[ensures(result === old(snap(self)).lookup(0))]
#     pub fn pop(&mut self) -> i32 {
#         self.try_pop().unwrap()
#     }
# }
# 
# impl Link {
#     #[pure]
#     #[requires(index < self.len())]
#     pub fn lookup(&self, index: usize) -> i32 {
#         match self {
#             Link::More(node) => {
#                 if index == 0 {
#                     node.elem
#                 } else {
#                     node.next.lookup(index - 1)
#                 }
#             }
#             Link::Empty => unreachable!(),
#         }
#     }
# 
#     #[pure]
#     fn len(&self) -> usize {
#         match self {
#             Link::Empty => 0,
#             Link::More(node) => 1 + node.next.len(),
#         }
#     }
# 
#     #[pure]
#     fn is_empty(&self) -> bool {
#         matches!(self, Link::Empty)
#     }
# }
# 
#[cfg(prusti)]
mod prusti_tests {
    use super::*;

#     fn _test_list(){
#         let mut list = List::new(); // create an new, empty list
#         prusti_assert!(list.is_empty() && list.len() == 0); // list should be empty
# 
#         list.push(5);
#         list.push(10);
#         prusti_assert!(!list.is_empty() && list.len() == 2); // length correct
#         prusti_assert!(list.lookup(0) == 10); // head is 10
#         prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
# 
#         let x = list.pop();
#         prusti_assert!(x == 10); // pop returns the value that was added last
# 
#         match list.try_pop() {
#             Some(y) => assert!(y == 5),
#             None => unreachable!()
#         }
# 
#         let z = list.try_pop();
#         prusti_assert!(list.is_empty() && list.len() == 0); // length correct
#         prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
#     }
# 
    // This shows a test that takes 2 lists as input parameters:
    #[requires(list_0.len() >= 4)]
    #[requires(!list_1.is_empty())]
    #[requires(list_0.lookup(1) == 42)]
    #[requires(list_0.lookup(3) == list_1.lookup(0))]
    fn _test_lists(list_0: &mut List, list_1: &mut List) {
        let x0 = list_0.pop();

        list_0.push(10);
        prusti_assert!(list_0.len() >= 4);
        prusti_assert!(list_0.lookup(1) == 42);
        assert!(list_0.pop() == 10); // Cannot be `prusti_assert`, `pop` changes the list

        let x1 = list_0.pop();
        let x2 = list_0.pop();
        let x3 = list_0.pop();
        prusti_assert!(x0 == old(snap(list_0)).lookup(0));
        prusti_assert!(x1 == old(snap(list_0)).lookup(1) && x1 == 42);
        prusti_assert!(x2 == old(snap(list_0)).lookup(2));
        prusti_assert!(x3 == old(snap(list_0)).lookup(3));
        
        let y0 = list_1.pop();
        prusti_assert!(y0 == old(snap(list_1)).lookup(0));
        prusti_assert!(y0 == x3);
    }
}
// Prusti: verifies
``` -->
<p>Note the <code>#[cfg(prusti)]</code> on the module <code>prusti_tests</code>. This makes the module only available during verification, with no effect during normal compilation, similar to <code>#[cfg(test)]</code> for unit tests.</p>
<p>Our test code can be verified, so it appears that our specification is not too restrictive or incomplete.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tour/pop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tour/option.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tour/pop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tour/option.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
