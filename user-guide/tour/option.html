<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Option - Prusti user guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="../tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tour/setup.html"><strong aria-hidden="true">4.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../tour/getting-started.html"><strong aria-hidden="true">4.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../tour/new.html"><strong aria-hidden="true">4.3.</strong> New</a></li><li class="chapter-item expanded "><a href="../tour/push.html"><strong aria-hidden="true">4.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="../tour/pop.html"><strong aria-hidden="true">4.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="../tour/testing.html"><strong aria-hidden="true">4.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../tour/option.html" class="active"><strong aria-hidden="true">4.7.</strong> Option</a></li><li class="chapter-item expanded "><a href="../tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="../tour/pledges.html"><strong aria-hidden="true">4.10.</strong> Pledges (mutable peek)</a></li><li class="chapter-item expanded "><a href="../tour/final.html"><strong aria-hidden="true">4.11.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="../tour/loop_invariants.html"><strong aria-hidden="true">4.12.</strong> Loop Invariants</a></li><li class="chapter-item expanded "><a href="../tour/counterexamples.html"><strong aria-hidden="true">4.13.</strong> Counterexamples</a></li></ol></li><li class="chapter-item expanded "><a href="../verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="../verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="../verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="../verify/assert_refute_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions, refutations and assumptions</a></li><li class="chapter-item expanded "><a href="../verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="../verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="../verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="../verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="../verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="../verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="../verify/type_cond_spec.html"><strong aria-hidden="true">5.11.</strong> Type-conditional spec refinements</a></li><li class="chapter-item expanded "><a href="../verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="../verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="../verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="../verify/counterexample.html"><strong aria-hidden="true">5.15.</strong> Counterexamples</a></li><li class="chapter-item expanded "><a href="../verify/impl_block_specs.html"><strong aria-hidden="true">5.16.</strong> Specifications in trait impl blocks</a></li></ol></li><li class="chapter-item expanded "><a href="../syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="options"><a class="header" href="#options">Options</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/second.html">3: An Ok Single-Linked Stack</a>,
<a href="https://rust-unofficial.github.io/too-many-lists/second-option.html">3.1. Option</a></p>
</blockquote>
<p>Just like in the "Learning Rust With Entirely Too Many Linked Lists" tutorial, we can change our <code>enum Link</code> to use the <code>Option</code> type via a type alias instead of manually implementing <code>Empty</code> and <code>More</code>:</p>
<pre><code class="language-rust noplaypen ignore">type Link = Option&lt;Box&lt;Node&gt;&gt;;</code></pre>
<p>In order to use the <code>Option::take</code> function, we also have to implement the <code>extern_spec</code> for it. As you can see, it is quite similar to the <code>extern_spec</code> for <code>mem::replace</code>, since <code>take</code> does the same as <code>replace(&amp;mut self, None)</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[extern_spec(std::mem)]
#[ensures(snap(dest) === src)]
#[ensures(result === old(snap(dest)))]
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;

<span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span>#[extern_spec]
impl&lt;T&gt; std::option::Option&lt;T&gt; {
<span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span>    #[ensures(result === old(snap(self)))]
    #[ensures(self.is_none())]
    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Changing the <code>Link</code> type requires some adjustments of the code and specifications. With the new type alias for <code>Link</code>, we cannot have an <code>impl Link</code> block anymore, so our <code>lookup</code> and <code>len</code> functions on <code>Link</code> are now normal, free-standing functions:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        link_len(&amp;self.head)
    }

<span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span>    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        link_lookup(&amp;self.head, index)
    }
<span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span>#[pure]
#[requires(index &lt; link_len(link))]
fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
    match link {
        Some(node) =&gt; {
            if index == 0 {
                node.elem
            } else {
                link_lookup(&amp;node.next, index - 1)
            }
        }
        None =&gt; unreachable!(),
    }
}

#[pure]
fn link_len(link: &amp;Link) -&gt; usize {
    match link {
        None =&gt; 0,
        Some(node) =&gt; 1 + link_len(&amp;node.next),
    }
}
<span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Due to current limitations of Prusti, we cannot replace our <code>link_len</code> and <code>link_lookup</code> functions with loops:</p>
<!-- TODO: link capabilities/limitations chapter (loops in pure functions) -->
<pre><code class="language-rust noplaypen ignore"><span class="boring">// ignore-test: This code causes Prusti to panic
</span><span class="boring">// The next and previous line are only required for (doc)tests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    // Prusti cannot verify these functions at the moment,
    // since loops in pure functions are not yet supported:
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        let mut curr = &amp;self.head;
        let mut i = 0;
        while let Some(node) = curr {
            body_invariant!(true);
            i += 1;
            curr = &amp;node.next;
        }
        i
    }

    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        let mut curr = &amp;self.head;
        let mut i = index;
        while let Some(node) = curr {
            body_invariant!(true);
            if i == 0 {
                return node.elem;
            }
            i -= 1;
            curr = &amp;node.next;
        }
        unreachable!()
    }
}</code></pre>
<p>Since Prusti doesn't fully support closures yet, we also cannot do the rewrite to use the <code>Option::map</code> function:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span>    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() { // Replace mem::swap with the buildin Option::take
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
    
    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
    // // Currently you get this error:
    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    //     let tmp = self.head.take();
    //     tmp.map(move |node| {
    //         self.head = node.next;
    //         node.elem
    //     })
    // }
<span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>After all the changes done in this chapter, Prusti is still be able to verify the code, so we didn't break anything.
If you want to see the full code after all the changes, expand the following code block.</p>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tour/testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tour/generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tour/testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tour/generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
