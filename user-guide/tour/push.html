<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Push - Prusti user guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="../tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tour/setup.html"><strong aria-hidden="true">4.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../tour/getting-started.html"><strong aria-hidden="true">4.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../tour/new.html"><strong aria-hidden="true">4.3.</strong> New</a></li><li class="chapter-item expanded "><a href="../tour/push.html" class="active"><strong aria-hidden="true">4.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="../tour/pop.html"><strong aria-hidden="true">4.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="../tour/testing.html"><strong aria-hidden="true">4.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../tour/option.html"><strong aria-hidden="true">4.7.</strong> Option</a></li><li class="chapter-item expanded "><a href="../tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="../tour/pledges.html"><strong aria-hidden="true">4.10.</strong> Pledges (mutable peek)</a></li><li class="chapter-item expanded "><a href="../tour/final.html"><strong aria-hidden="true">4.11.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="../tour/loop_invariants.html"><strong aria-hidden="true">4.12.</strong> Loop Invariants</a></li><li class="chapter-item expanded "><a href="../tour/counterexamples.html"><strong aria-hidden="true">4.13.</strong> Counterexamples</a></li></ol></li><li class="chapter-item expanded "><a href="../verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="../verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="../verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="../verify/assert_refute_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions, refutations and assumptions</a></li><li class="chapter-item expanded "><a href="../verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="../verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="../verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="../verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="../verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="../verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="../verify/type_cond_spec.html"><strong aria-hidden="true">5.11.</strong> Type-conditional spec refinements</a></li><li class="chapter-item expanded "><a href="../verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="../verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="../verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="../verify/counterexample.html"><strong aria-hidden="true">5.15.</strong> Counterexamples</a></li><li class="chapter-item expanded "><a href="../verify/impl_block_specs.html"><strong aria-hidden="true">5.16.</strong> Specifications in trait impl blocks</a></li></ol></li><li class="chapter-item expanded "><a href="../syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="push"><a class="header" href="#push">Push</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a></p>
</blockquote>
<h2 id="informal-specifications"><a class="header" href="#informal-specifications">Informal specifications</a></h2>
<p>Our next goal is to implement and verify a method that pushes an integer onto a list.
In contrast to methods like <code>len</code>, <code>push</code> modifies the list; it thus takes
<code>&amp;mut self</code> as its first argument:</p>
<pre><code class="language-rust noplaypen ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}</code></pre>
<p>Since <code>push</code> modifies <code>self</code>, it cannot be marked as a <code>#[pure]</code> function (it has a side effect on <code>self</code>). This means we will not be able to use <code>push</code> inside specifications for other functions later.</p>
<p>Before we implement <code>push</code>, let us briefly think of possible specifications.
Ideally, our implementation satisfies at least the following properties:</p>
<ol>
<li>Executing <code>push</code> increases the length of the underlying list by one. <a href="push.html#first-property">(Chapter link)</a></li>
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>. <a href="push.html#second-property">(Chapter link)</a></li>
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged, but are moved back by 1 position. <a href="push.html#third-property">(Chapter link)</a></li>
</ol>
<h2 id="initial-code"><a class="header" href="#initial-code">Initial code</a></h2>
<p>We start out with an implementation of <code>push</code>. If you want to learn more about how this code works, you can read <a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a>, where it is explained in detail.</p>
<p>Here is our initial code:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem, // we can use `elem` instead of `elem: elem,` here, since the variable has the same name as the field
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="first-property"><a class="header" href="#first-property">First property</a></h2>
<p>The first property can easily be expressed as a postcondition that uses the
pure method <code>len</code> introduced in the <a href="new.html">previous chapter</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem,
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Even though the above implementation of <code>push</code> is correct, attempting to verify it with Prusti still yields a verification error:</p>
<pre><code class="language-plain">[Prusti: verification error] postcondition might not hold.
</code></pre>
<p>This error may look surprising at first:
We create a new list node that stores the the original list in its next field.
Why is Prusti unable to realize that the length of the resulting list
is one plus the length of the original list?</p>
<p>The explanation is that Prusti performs <em>function modular</em> verification,
that is, it only uses a function's specification (instead of also consulting the
function's implementation) whenever it encounters a function call.
The only exception are <em>pure</em> functions, such as <code>len</code>, where Prusti also takes the
function body into account.</p>
<h3 id="adding-external-specifications-to-library-code"><a class="header" href="#adding-external-specifications-to-library-code">Adding external specifications to library code</a></h3>
<p>In our case, the function <code>std::mem::replace</code> is neither marked as <code>pure</code> nor does it
come with a specification. Hence, Prusti assumes that it is memory safe and nothing else.
That is, Prusti uses <code>true</code> as both pre- and postcondition of <code>replace</code>,
which is too weak to prove the specification of <code>push</code>. According to its specification,
<code>replace</code> could arbitrarily change the original list and thus also its length.
Hence, we cannot conclude that the length the list returned by
<code>replace(&amp;mut self.head, Link::Empty)</code> coincides with the length of the original
list.</p>
<p>We can remedy this issue by strengthening the specification of <code>replace</code>.
In this tutorial, we will assume that the standard library is correct, that is, we
do not attempt to verify specifications for functions in external crates,
like <code>replace</code>. To this end, we have to add the specification to the function.
This can be done with another piece of Prusti syntax, the <a href="../verify/external.html">extern_spec</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[extern_spec(std::mem)]
#[ensures(snap(dest) === src)]
#[ensures(result === old(snap(dest)))]
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
<span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Let's break this snippet down step by step:</p>
<ul>
<li>First, we write the Prusti annotation <code>#[extern_spec]</code> to denote that we are writing an external specification. This requires <code>prusti_contracts::*</code> to be imported first.</li>
<li>Next, we need to declare where the original function is located. In this case it is the module <code>std::mem</code>, so we put its path in  the parameter: <code>#[extern_spec(std::mem)]</code></li>
<li>After a quick search for <em>"rust std mem replace"</em> we can find the <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">documentation for std::mem::replace</a>. Here we can get the function signature: <code>pub fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T</code>. We then write down the signature in the inner module, followed by a <code>;</code>.</li>
<li>Since there are no preconditions to <code>replace</code>, we can use the (implicit) default <code>#[requires(true)]</code>.</li>
<li>For writing the postcondition, we use four pieces of Prusti syntax:
<ul>
<li><a href="../syntax.html#snapshot-equality"><code>===</code></a> is called <strong>snapshot equality</strong> or <strong>logical equality</strong>. Is means that the left and right operands are structurally equal. <code>===</code> does not require the type of the compared elements to implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>, which would be required if we used the standard equality operator <code>==</code>.</li>
<li>The <a href="../syntax.html#snap-function"><code>snap()</code></a> function takes a snapshot of a reference. It has a similar functionality to the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>clone()</code></a> method, but does not require the type of the reference it is called on to implement the <code>Clone</code> trait. <code>snap</code> should only be used in specifications, since it ignores the borrow checker.</li>
<li>Lastly, we have the <a href="../syntax.html#old-expressions"><code>old()</code> function</a>, which denotes that we want to refer to the state of <code>snap(dest)</code> from before the function was called.</li>
<li>The identifier <a href="../syntax.html#result-variable"><code>result</code></a> is used to refer to the return parameter of the function.</li>
</ul>
</li>
<li>The postcondition consists of two parts, which can either be written in one condition with <code>&amp;&amp;</code>, or in multiple <code>#[ensures(...)]</code> annotations like in the example above.
<ul>
<li>The first condition <code>snap(dest) === src</code> means: <em>After the function returns, the location referenced by <code>dest</code> is structurally equal to the parameter <code>src</code></em></li>
<li>The second part of the postcondition is <code>result === old(snap(dest))</code>. This means: <em>The <code>result</code> returned by the function is structurally equal to the the element that was referenced by <code>dest</code> <strong>before</strong> the function was called.</em></li>
</ul>
</li>
</ul>
<p>Since <code>result</code> is structurally equal to <code>dest</code> from before the function call, Prusti knows that the pure function <code>len()</code> called on <code>result</code> returns the same value as it would have for <code>dest</code>.</p>
<p>An important thing to note here is that Prusti does <em><strong>not</strong></em> check if <code>replace</code> actually does what the external specification says it does. <code>#[extern_spec]</code> implicitly implies the <code>#[trusted]</code> annotation, which means that any postconditions are just accepted and used by Prusti.</p>
<h3 id="future"><a class="header" href="#future">Future</a></h3>
<p>There is currently new functionality planned for Prusti-assistant, which should enable the user to automatically generate parts of the <code>extern_spec</code> syntax.</p>
<p>There is also work being done for providing external specifications for the Rust standard library. Depending on when you are reading this, the <code>std::mem::replace</code> function might be annotated already, in that case this <code>extern_spec</code> may not be needed anymore.
You can track the progress and find some already completed specifications <a href="https://github.com/viperproject/prusti-dev/pull/1249">in this Pull Request</a>.</p>
<p>Specifications for the standard library should eventually be available in the <a href="https://crates.io/crates/prusti-std">prusti-std crate</a>. Any specifications in this crate will be available by adding it to your project's dependencies.</p>
<h2 id="trusted-functions"><a class="header" href="#trusted-functions">Trusted functions</a></h2>
<p>As mentioned above, <code>extern_specs</code> are implicitly <code>#[trusted]</code> by Prusti.
Trusted functions can be used for verifying projects containing external code that does not have Prusti annotations, or projects using Rust features that are not yet supported by Prusti.
An example is printing a string slice (not supported yet):</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
fn print(s: &amp;str) {
    println!("{s}");
}</code></pre>
<p>Prusti will <em><strong>not</strong></em> check trusted functions for correctness, so it is the programmers responsibility to check their the specification manually. <strong>A single incorrect specification of a trusted function can invalidate the correctness of Prusti as a whole!</strong>
Hence, trusted functions, like unsafe Rust code, need to be treated carefully and
require external justification.</p>
<p>For example, the following function will not cause the verification to fail:</p>
<pre><code class="language-rust noplaypen norun"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
fn incorrect_function() -&gt; i32 {
    panic!()
}</code></pre>
<p>This one is even worse, it will enable anything to be verified:</p>
<pre><code class="language-rust noplaypen norun"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
#[ensures(false)]
fn wrong() {}</code></pre>
<h3 id="checking-the-extern_spec"><a class="header" href="#checking-the-extern_spec">Checking the <code>extern_spec</code></a></h3>
<p>Let's get back to our code. After adding the external specification for <code>std::mem::replace</code>, we can finally verify the first property of our <code>push</code> function:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem,
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span>// Prusti: Verifies</code></pre>
<p>With this, the first of the three properties of <code>push</code> is verified, but we still have two more to prove.</p>
<h2 id="second-property"><a class="header" href="#second-property">Second property</a></h2>
<p>Recall the second property of our specification:</p>
<blockquote>
<ol start="2">
<li>After <code>push(elem)</code>, the first element of the list stores the value <code>elem</code>.</li>
</ol>
</blockquote>
<p>To formally specify the above property, we first introduce another pure function, called
<code>lookup</code>, that recursively traverses the list and returns its i-th element.
Our second desired property then corresponds to the postcondition
<code>self.lookup(0) == elem</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)] // 2. Property //~ ERROR postcondition might not hold
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}

impl Link {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::More(node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
            Link::Empty =&gt; unreachable!(), //~ ERROR: unreachable!(..) statement might be reachable
        }
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span>}</code></pre>
<p>Consider the <code>match</code> statement in the last function.
The Rust compiler will complain if we attempt to omit the case <code>Link::Empty</code>.
We have no sensible implementation of <code>lookup</code> if the underlying list is empty,
so we used the macro <code>unreachable!()</code>, which will crash the program with a panic.
Since nothing prevents us from calling <code>lookup</code> on an empty list, Prusti complains:</p>
<pre><code class="language-plain">unreachable!(..) statement might be reachable
</code></pre>
<p>We can specify that <code>lookup</code> should only be called with an <code>index</code> between <code>0</code> and <code>self.len()</code> (which implies that we cannot call lookup on an empty list: <code>0 &lt;= index &lt; self.len()</code> implies <code>0 &lt; self.len()</code>). We do this by adding the precondition <code>index &lt; self.len()</code> to <em>both</em> <code>lookup</code> functions.
This is sufficient to verify our second property for <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}

impl Link {
    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span>    }
}</code></pre>
<p>We don't need to add the condition <code>0 &lt;= index</code>, since <code>index</code> has the type <code>usize</code>, and unsigned integers are always non-negative. (If you don't want Prusti to add this condition automatically, you can add the line <code>encode_unsigned_num_constraint = false</code> to your <code>Prusti.toml</code> file).</p>
<p>After these changes, Prusti can successfully verify the code, so the first two properties of <code>push</code> are correct.</p>
<h2 id="third-property"><a class="header" href="#third-property">Third property</a></h2>
<p>The third and final property we will verify for <code>push</code> is that the original list
content is not modified:</p>
<blockquote>
<ol start="3">
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged (just shifted back by one).</li>
</ol>
</blockquote>
<p>To formalize the above property, we can reuse our pure function <code>lookup</code>,
<a href="../syntax.html#quantifiers">quantifiers</a>, and <a href="../syntax.html#old-expressions">old expressions</a>, that is, we add
the postcondition:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span>    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
                 old(self.lookup(i)) == self.lookup(i + 1)))] // 3. Property
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Let's break this expression down like before:</p>
<ul>
<li>We start with the <code>ensures</code> annotation, to denote a postcondition.</li>
<li><code>forall(..)</code> denotes a <a href="../syntax.html#quantifiers">quantifier</a>. The variables and body of a quantifier use a syntax similar to Rust <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">closures</a>.</li>
<li>The two vertical bars: <code>||</code> contain the variables that the quantifier quantifies over. Here we only have one parameter <code>i: usize</code>. The type of the quantifier body is <code>bool</code>. You can think of the <code>forall</code> expression as follows: <em>Any values chosen for the quantified variables should result in the expression evaluating to <code>true</code></em>.</li>
<li>In this case, the quantifier uses the <a href="../syntax.html#implications">implication operator <code>==&gt;</code></a>. It takes a left and right argument of type <code>bool</code> and is true if the left-hand side is false, or both sides are true.
<ul>
<li>The left-hand side of the implication is <code>(1 &lt;= i &amp;&amp; i &lt; self.len())</code>, which is the range where the right side must hold. If the index <code>i</code> is outside of this range, we don't care about it, so the condition will be false, making the entire implication true.</li>
<li>The right-hand side is the condition for everything being shifted back by one element: <code>old(self.lookup(i - 1)) == self.lookup(i)))</code>. Note that the right side is only evaluated if the left side is true, otherwise there would be an overflow in <code>i - 1</code> for <code>i == 0</code>, or a panic if <code>i</code> is out of bounds.</li>
</ul>
</li>
</ul>
<p>This code is verified successfully by Prusti, so we know that the <code>lookup</code> function satisfies the three postconditions!</p>
<h2 id="full-code-listing"><a class="header" href="#full-code-listing">Full code listing</a></h2>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))] // 3. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        // ...
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tour/new.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tour/pop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tour/new.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tour/pop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
