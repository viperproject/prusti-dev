<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prusti user guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="basic.html"><strong aria-hidden="true">3.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="tour/summary.html"><strong aria-hidden="true">4.</strong> Guided Tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tour/setup.html"><strong aria-hidden="true">4.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="tour/getting-started.html"><strong aria-hidden="true">4.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tour/new.html"><strong aria-hidden="true">4.3.</strong> New</a></li><li class="chapter-item expanded "><a href="tour/push.html"><strong aria-hidden="true">4.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="tour/pop.html"><strong aria-hidden="true">4.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="tour/testing.html"><strong aria-hidden="true">4.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="tour/option.html"><strong aria-hidden="true">4.7.</strong> Option</a></li><li class="chapter-item expanded "><a href="tour/generics.html"><strong aria-hidden="true">4.8.</strong> Generics</a></li><li class="chapter-item expanded "><a href="tour/peek.html"><strong aria-hidden="true">4.9.</strong> Peek</a></li><li class="chapter-item expanded "><a href="tour/pledges.html"><strong aria-hidden="true">4.10.</strong> Pledges (mutable peek)</a></li><li class="chapter-item expanded "><a href="tour/final.html"><strong aria-hidden="true">4.11.</strong> Final Code</a></li><li class="chapter-item expanded "><a href="tour/loop_invariants.html"><strong aria-hidden="true">4.12.</strong> Loop Invariants</a></li><li class="chapter-item expanded "><a href="tour/counterexamples.html"><strong aria-hidden="true">4.13.</strong> Counterexamples</a></li></ol></li><li class="chapter-item expanded "><a href="verify/summary.html"><strong aria-hidden="true">5.</strong> Verification Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="verify/panic.html"><strong aria-hidden="true">5.1.</strong> Absence of panics</a></li><li class="chapter-item expanded "><a href="verify/overflow.html"><strong aria-hidden="true">5.2.</strong> Overflow checks</a></li><li class="chapter-item expanded "><a href="verify/prepost.html"><strong aria-hidden="true">5.3.</strong> Pre- and postconditions</a></li><li class="chapter-item expanded "><a href="verify/assert_refute_assume.html"><strong aria-hidden="true">5.4.</strong> Assertions, refutations and assumptions</a></li><li class="chapter-item expanded "><a href="verify/trusted.html"><strong aria-hidden="true">5.5.</strong> Trusted functions</a></li><li class="chapter-item expanded "><a href="verify/pure.html"><strong aria-hidden="true">5.6.</strong> Pure functions</a></li><li class="chapter-item expanded "><a href="verify/predicate.html"><strong aria-hidden="true">5.7.</strong> Predicates</a></li><li class="chapter-item expanded "><a href="verify/external.html"><strong aria-hidden="true">5.8.</strong> External specifications</a></li><li class="chapter-item expanded "><a href="verify/loop.html"><strong aria-hidden="true">5.9.</strong> Loop body invariants</a></li><li class="chapter-item expanded "><a href="verify/pledge.html"><strong aria-hidden="true">5.10.</strong> Pledges</a></li><li class="chapter-item expanded "><a href="verify/type_cond_spec.html"><strong aria-hidden="true">5.11.</strong> Type-conditional spec refinements</a></li><li class="chapter-item expanded "><a href="verify/closure.html"><strong aria-hidden="true">5.12.</strong> Closures</a></li><li class="chapter-item expanded "><a href="verify/spec_ent.html"><strong aria-hidden="true">5.13.</strong> Specification entailments</a></li><li class="chapter-item expanded "><a href="verify/type-models.html"><strong aria-hidden="true">5.14.</strong> Type models</a></li><li class="chapter-item expanded "><a href="verify/counterexample.html"><strong aria-hidden="true">5.15.</strong> Counterexamples</a></li><li class="chapter-item expanded "><a href="verify/impl_block_specs.html"><strong aria-hidden="true">5.16.</strong> Specifications in trait impl blocks</a></li></ol></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">6.</strong> Specification Syntax</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prusti user guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is the user guide for <a href="https://github.com/viperproject/prusti-dev/">Prusti</a> - a Rust verifier built upon the the <a href="https://www.pm.inf.ethz.ch/research/viper.html">Viper verification infrastructure</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="prusti-assistant"><a class="header" href="#prusti-assistant">Prusti Assistant</a></h2>
<p>The easiest way to try out Prusti is by using the <a href="https://marketplace.visualstudio.com/items?itemName=viper-admin.prusti-assistant">"Prusti Assistant"</a> extension for <a href="https://code.visualstudio.com/">Visual Studio Code</a>. Please confer the extension's webpage for:</p>
<ul>
<li>Detailed installation and first usage instructions.</li>
<li>The description of the available commands, among which are commands to run and update the verifier.</li>
<li>The description of the configuration flags.</li>
<li>Troubleshooting instructions.</li>
</ul>
<blockquote>
<p><strong>Warning:</strong> Some of the Prusti-specific syntax described in this guide is currently only available in the "LatestDev" build channel, which corresponds to the latest development version of Prusti.
The settings for switching to this version in Prusti Assistant are found in
<code>File → Preferences → Settings → Prusti Assistant → Build Channel</code>.</p>
</blockquote>
<p>In case you experience difficulties or encounter bugs while using Prusti Assistant, please <a href="https://github.com/viperproject/prusti-assistant/issues">open an issue in Prusti Assistant's repository</a> or contact us in the <a href="https://prusti.zulipchat.com/">Zulip chat</a>.
Bugs with Prusti itself can be reported on the <a href="https://github.com/viperproject/prusti-dev/issues">prusti-dev repository</a>.</p>
<h2 id="command-line-setup"><a class="header" href="#command-line-setup">Command-line setup</a></h2>
<p>Alternatively, Prusti can be set up by downloading the <a href="https://github.com/viperproject/prusti-dev/releases">precompiled binaries</a> available from the project page. We currently provide binaries for Windows, macOS (Intel), and Ubuntu. Releases marked as "Pre-release" may contain unstable or experimental features.</p>
<p>For a command-line setup with Prusti built from source, please confer the <a href="https://viperproject.github.io/prusti-dev/dev-guide/development/setup.html">developer guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<h2 id="prusti-assistant-1"><a class="header" href="#prusti-assistant-1">Prusti Assistant</a></h2>
<p>When the Prusti Assistant extension is active, Rust files can be verified in one of the following ways:</p>
<ul>
<li>By clicking the "Verify with Prusti" button in the status bar.</li>
<li>By opening the <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">Command Palette</a> and running the command "Prusti: save and verify this file".</li>
<li>By saving a Rust document, if "Verify on save" is enabled.</li>
<li>By opening a Rust document, if "Verify on open" is enabled.</li>
</ul>
<p>See the <a href="verify/summary.html">Verification Features chapter</a> for a list of verification features available in Prusti.</p>
<h2 id="command-line"><a class="header" href="#command-line">Command line</a></h2>
<p>To run Prusti on a file using the command-line setup:</p>
<pre><code class="language-sh">prusti-rustc --edition=2018 path/to/file.rs
</code></pre>
<p>Run this command from a crate or workspace root directory to verify it:</p>
<pre><code class="language-sh">cargo-prusti
</code></pre>
<p>If Prusti is in <code>$PATH</code>, it can also be run as a <a href="https://doc.rust-lang.org/stable/book/ch14-05-extending-cargo.html">Cargo subcommand</a>:</p>
<pre><code class="language-sh">cargo prusti
</code></pre>
<h2 id="introductory-example"><a class="header" href="#introductory-example">Introductory example</a></h2>
<p>Let us verify that the function <code>max</code> below, which takes two integers and returns the greater one, is implemented correctly.</p>
<pre><code class="language-rust noplaypen">fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}</code></pre>
<p>When pasting the above code into a Rust file and then verifying it with Prusti (as outlined at the top of the page), Prusti should report that verification succeeded.
This tells us that</p>
<ol>
<li>the file consists of valid Rust code that can be compiled successfuly, and</li>
<li>no execution reaches a Rust panic (explicit call of the <a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!()</code></a> macro, a failed assertion, etc).</li>
</ol>
<p>To also verify that <code>max</code> indeed always returns the maximum of its two inputs, we have to add a corresponding specification, which states
that the return value of <code>max</code> is at least as large as both <code>a</code> and <code>b</code> and, additionally, coincides with <code>a</code> or <code>b</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span>use prusti_contracts::*;

#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}</code></pre>
<p>In the above program, the first line (<code>use prusti_contracts::*;</code>) simplifies writing Prusti-specific syntax for specifications; allowing us to write <code>#[ensures(...)]</code> instead of <code>#[prusti_contracts::ensures(...)]</code>.</p>
<blockquote>
<p><strong>Warning:</strong> Due to limitations in Rust procedural macros, <code>use prusti_contracts::*;</code> should <em>always</em> be used, and the Prusti specification attributes should not be imported with an alias.</p>
</blockquote>
<p>After that, we used <code>#[ensures(...)]</code> to attach two <a href="verify/prepost.html">postconditions</a> to the function <code>max</code>.
The syntax of specifications is a superset of Rust expressions, where <code>result</code> is a keyword referring to the function's return value.</p>
<p>Again, verifying the above code with Prusti should succeed.
Notice that Prusti assumes by default that integer types are bounded; it thus performs <a href="verify/overflow.html">overflow and underflow checks</a> unless corresponding options are provided.</p>
<p>Next, we add a second function <code>max3</code> which returns the maximum of three instead of two integers; we reuse the already verified function <code>max</code> in the new function's specification to show that this function is implemented correctly.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span>use prusti_contracts::*;

#[pure]
#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}

#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            b
        } else {
            c
        }
    }
}</code></pre>
<p>Again, Prusti should successfully verify the above program.
Notice that we additionally declared the function <code>max</code> as <a href="verify/pure.html">pure</a> such that it can be used within specifications.
If we omit this annotation, Prusti will complain that the postcondition of function <code>max3</code> is invalid because it uses an <code>impure</code> function, which may potentially have side-effects.</p>
<p>So far, we only considered programs that meet their specification and that, consequently, Prusti successfully verified.
To conclude this example, assume we accidentally return <code>c</code> instead of <code>b</code> if <code>b &gt; c</code> holds:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            c // ERROR
        } else {
            c
        }
    }
}</code></pre>
<p>In this case, Prusti will highlight the line with the error and report that the <code>postcondition might not hold</code>.</p>
<p>For debugging purposes, it is often useful to add <code>assert!(...)</code> macros to our code to locate the issue. For example, in the code below, we added an assertion that fails because <code>b &gt; c</code> and thus the maximum of <code>b</code> and <code>c</code> is <code>b</code> instead of <code>c</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span>use prusti_contracts::*;

#[pure]
#[ensures(result &gt;= a &amp;&amp; result &gt;= b)]
#[ensures(result == a || result == b)]
fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}

#[ensures(result == max(a, max(b, c)))]
fn max3(a: i32, b: i32, c: i32) -&gt; i32 {
    if a &gt; b &amp;&amp; a &gt; c {
        a
    } else {
        if b &gt; c {
            assert!(max(b, c) == c); // FAILS
            c
        } else {
            c
        }
    }
}</code></pre>
<p>When running Prusti on this example, it highlights the failing assertion and thus enables us to quickly locate and fix the issue.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Prusti offers a many flags to configure its behavior. See <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/providing.html">Providing Flags</a> for how to provide these flags and <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html">List of Configuration Flags</a> in the developer guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guided-tour"><a class="header" href="#guided-tour">Guided Tour</a></h1>
<blockquote>
<p><strong>Disclaimer:</strong> All code shown in this tutorial has been tested with
<a href="https://github.com/viperproject/prusti-dev/releases/tag/v-2023-01-26-1935">Prusti version 0.2.1, 2023-01-26</a></p>
<p>Unless stated otherwise, all code listings should be put in their own file
and can be verified with
<a href="https://marketplace.visualstudio.com/items?itemName=viper-admin.prusti-assistant">Prusti assistant</a>.</p>
</blockquote>
<p>In this chapter, we demonstrate Prusti's capabilities.
As a running example, we roughly follow the first chapters of the Rust tutorial
<a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust with Entirely Too Many Linked Lists</a>.
Linked lists turn out to be sufficiently complex that their implementation and verification covers most of Rust's and Prusti's essential concepts.
While the above tutorial explains in detail how linked lists are implemented in Rust, we additionally aim to verify that the implemented list operations are functionally correct.</p>
<p>While we assume basic familiarity with Rust, it is possible to learn both
Rust and Prusti at the same time by reading this tour and the
<a href="https://rust-unofficial.github.io/too-many-lists/">Rust tutorial</a>
that inspired it in an interleaved fashion.
We will provide pointers to the Rust tutorial for beginners to catch up where appropriate.</p>
<p>Throughout this tour, we will cover the following Prusti concepts:</p>
<ul>
<li>How Prusti reports errors and integrates into the development process</li>
<li>Runtime errors detected by Prusti</li>
<li>Writing function-modular specifications</li>
<li>Using <em>pure</em> functions and predicates in specifications</li>
<li>Writing loop invariants</li>
<li>Using <em>extern_spec</em> to deal with library code</li>
<li>Writing pledges for functions that return mutable references</li>
<li>Basic troubleshooting</li>
</ul>
<p>The individual chapters are found in the sidebar, which may be collapsed on mobile
devices.
As a quick reference, the main steps of this tour and the involved Prusti features
are as follows:</p>
<ol>
<li><a href="tour/setup.html">Setup</a>: Adding Prusti to a Rust project</li>
<li><a href="tour/getting-started.html">Getting Started</a>: Simple runtime errors caught by Prusti</li>
<li><a href="tour/new.html">New</a>: Postconditions, pure functions</li>
<li><a href="tour/push.html">Push</a>: Preconditions, external specifications, trusted functions, old expressions, quantifiers, snapshots, structural/snapshot equality</li>
<li><a href="tour/pop.html">Pop</a>: Similar concepts as in <a href="tour/push.html">Push</a>, predicates</li>
<li><a href="tour/testing.html">Testing</a>: Showing guarantees of verification vs running tests, and how to test specifications</li>
<li><a href="tour/option.html">Option</a>: Changing <code>Link</code> to use <code>Option</code> type</li>
<li><a href="tour/generics.html">Generics</a>: Prusti and generics</li>
<li><a href="tour/peek.html">Peek</a>: Verifying a <code>peek</code> function</li>
<li><a href="tour/pledges.html">Pledges (mutable peek)</a>: Demonstrating Prusti's pledges for functions returning mutable references</li>
<li><a href="tour/final.html">Final Code</a>: Final code for the verified linked list</li>
<li><a href="tour/loop_invariants.html">Loop Invariants</a>: Verifying code containing loops by writing loop invariants</li>
<li><a href="tour/counterexamples.html">Counterexamples</a>: Getting counterexamples for failing assertions</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>To get started, you can use an existing Rust project or create a new one with <a href="https://doc.rust-lang.org/cargo/">Cargo</a>:</p>
<pre><code class="language-sh">cargo new prusti_tutorial
</code></pre>
<p>Then you can change the current working directory to the project's directory:</p>
<pre><code class="language-sh">cd ./prusti_tutorial/
</code></pre>
<p>To use the additional syntax used for verification with Prusti, you need to add the <a href="https://crates.io/crates/prusti-contracts"><code>prusti-contracts</code></a> crate to your project. If you have at least Cargo version 1.62.0, you can use this command to add the dependency:</p>
<pre><code class="language-sh">cargo add prusti-contracts
</code></pre>
<p>For older versions of Rust, you can manually add the dependency in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
prusti-contracts = "0.1.6"
</code></pre>
<p>To use prusti-contracts in a Rust code file, just add the following line:</p>
<pre><code class="language-rust ignore">use prusti_contracts::*;</code></pre>
<p>To simplify the tutorial, overflow checks by Prusti will be disabled. To do that, create a file called <code>Prusti.toml</code> in your project's root directory (where <code>Cargo.toml</code> is located).
In this file, you can set <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html">configuration flags</a> used by Prusti. To disable overflow checking, add the following line:</p>
<pre><code class="language-toml">check_overflows = false
</code></pre>
<p><strong>Note</strong>: Creating a new project will create a <code>main.rs</code> file containing a <code>Hello World</code> program. Since Prusti does not yet support Strings, verification will fail on <code>main.rs</code>. To still verify the code, remove the line <code>println!("Hello, world!");</code>.</p>
<!-- TODO: link capabilities/limitations chapter (strings) -->
<h2 id="standard-library-annotations"><a class="header" href="#standard-library-annotations">Standard library annotations</a></h2>
<p>Annotations for functions and types in the Rust standard library will be available in the <a href="https://crates.io/crates/prusti-std"><code>prusti-std</code> crate</a> after <a href="https://github.com/viperproject/prusti-dev/pull/1249">this PR</a> is merged.</p>
<p>Adding this crate works the same as for the <code>prusti-contracts</code> crate:</p>
<pre><code class="language-sh">cargo add prusti-std
</code></pre>
<p>or:</p>
<pre><code class="language-toml">[dependencies]
prusti-std = "0.1.6"
</code></pre>
<p>You do not need to import anything to use the annotations in this crate in a file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Our first goal is to implement and verify a simple singly-linked stack that stores
32-bit integers <em>without</em> relying on existing data structures
provided by Rust's standard library.</p>
<p>For readers that are unfamiliar with Rust, this is a good time to additionally
read the introduction of the accompanying Rust tutorial
<a href="https://rust-unofficial.github.io/too-many-lists/index.html">Learn Rust With Entirely Too Many Linked Lists</a>,
which explains the Rust features covered by the tutorial and how to set up a
new project with Cargo.</p>
<p>From now on, we will simply provide links to the relevant parts of the
Rust tutorial together with a brief summary.
For example, reading up on possible data layouts for lists might be useful for beginners:</p>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-layout.html">2.1: Basic Data Layout</a></p>
<p>Discusses potential pitfalls and errors when setting up a singly-linked data structure in Rust.</p>
</blockquote>
<h2 id="stack-layout"><a class="header" href="#stack-layout">Stack layout</a></h2>
<p>Our naïve singly-linked stack is composed of a public structure <code>List</code> storing
the head of the list, an enum <code>Link</code> representing either an empty list or a heap-allocated
Node storing the payload—an integer—and the link to the next node:</p>
<pre><code class="language-rust noplaypen">pub struct List {
    head: Link,
}

enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}

struct Node {
    elem: i32,
    next: Link,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let test = Node {
</span><span class="boring">        elem: 17,
</span><span class="boring">        next: Link::Empty,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    if test.elem &gt; 23 {
</span><span class="boring">        panic!() // unreachable
</span><span class="boring">    }
</span><span class="boring">}
</span>// Prusti: VERIFIES</code></pre>
<p>As explained in the chapter <a href="https://rust-unofficial.github.io/too-many-lists/first-layout.html">2.1: Basic Data Layout</a>, this design avoids making both <code>Link</code> and <code>Node</code> public.
Moreover, it benefits from the Rust compiler's <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums">null-pointer optimization</a>
and makes sure that all list elements are uniformly allocated on the heap.</p>
<h2 id="absence-of-runtime-errors"><a class="header" href="#absence-of-runtime-errors">Absence of runtime errors</a></h2>
<p>Prusti automatically checks that no statement or macro that causes
an explicit runtime error, such as
<a href="https://doc.rust-lang.org/std/macro.panic.html"><code>panic!</code></a>,
<a href="https://doc.rust-lang.org/std/macro.unreachable.html"><code>unreachable!</code></a>,
<a href="https://doc.rust-lang.org/std/macro.unimplemented.html"><code>unimplemented!</code></a>,
<a href="https://doc.rust-lang.org/std/macro.todo.html"><code>todo!</code></a>, or
possibly a failing <a href="https://doc.rust-lang.org/std/macro.assert.html">assertion</a>,
is reachable. <a href="tour/../verify/assert_refute_assume.html">Prusti assertions</a> are also checked. These are like the normal <code>assert!</code> statements, but they can use the full Prusti specification syntax and will not result in any runtime checks or code when compiled normally.</p>
<p>For example, the following test function creates a node with no successor and panics
if the node's payload is greater than 23:</p>
<pre><code class="language-rust noplaypen"><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let test = Node {
        elem: 17,
        next: Link::Empty,
    };

    if test.elem &gt; 23 {
        panic!() // unreachable
    }
}
// Prusti: VERIFIES</code></pre>
<p>Prusti successfully verifies the above function
because it can statically guarantee that <code>test.elem &lt;= 23</code> holds
whenever execution reaches the <code>if</code> statement.</p>
<p>This is not the case for the following function in which the test node is initialized
with an arbitrary integer:</p>
<pre><code class="language-rust noplaypen"><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let test = Node {
</span><span class="boring">        elem: 17,
</span><span class="boring">        next: Link::Empty,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    if test.elem &gt; 23 {
</span><span class="boring">        panic!() // unreachable
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn test(x: i32) {
    let test = Node {
        elem: x, // unknown value
        next: Link::Empty,
    };

    if test.elem &gt; 23 {
        panic!() //~ ERROR panic!(..) statement might be reachable
    }
}
// Prusti: FAILS</code></pre>
<p>Prusti reports errors in the same fashion as the Rust compiler (with the prefix
<code>Prusti: verification error</code>). For example, the error produced for the above function
is:</p>
<pre><code class="language-plain">error: [Prusti: verification error] statement might panic
  --&gt; getting_started_failing.rs:33:9
   |
33 |         panic!()
   |         ^^^^^^^^
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new"><a class="header" href="#new">New</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-new.html">2.2: New</a>,
<a href="https://rust-unofficial.github.io/too-many-lists/first-ownership.html">2.3: Ownership 101</a></p>
<p>How to associate code with a type through <code>impl</code> blocks;
writing simple static functions;
Rust's ownership system.</p>
</blockquote>
<h2 id="implementing-new"><a class="header" href="#implementing-new">Implementing <code>new</code></a></h2>
<p>We first provide a static function to create empty lists:</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
// Prusti: VERIFIES</code></pre>
<h2 id="a-first-specification"><a class="header" href="#a-first-specification">A first specification</a></h2>
<p>What would be a sensible first specification for <code>new()</code>?
We could attempt to verify the list returned by <code>new()</code> is always empty.
In other words, the length of the returned list is always zero.
To express this property, we first implement a length method for lists which
itself calls an auxiliary length method implemented for <code>Link</code>.
For simplicity, we will not actually compute the length of a <code>Link</code> yet.
Rather, we will just always return 0. The return type for the <code>len</code> functions is <a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a>, which is a pointer-sized unsigned integer (e.g., 64 bits on a 64-bit computer). <code>usize</code> is also used in the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len"><code>Vec::len</code></a> function in the standard library.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    pub fn len(&amp;self) -&gt; usize {
        self.head.len()
    }
<span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)] //~ ERROR use of impure function "List::len" in pure code is not allowed
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}

impl Link {
    fn len(&amp;self) -&gt; usize {
        0
    }
}
// Prusti: VERIFIES</code></pre>
<p>Now that we have implemented a method for computing the length of a list, we can
write our first specification for <code>new()</code>: the returned list should always have length
zero.
That is, we attach the <a href="tour/../verify/prepost.html">postcondition</a>
<code>result.len() == 0</code> to the function <code>new()</code>. The special variable <a href="tour/../syntax.html#result-variable"><code>result</code></a> is used in Prusti specifications to refer to the value that is returned by a function:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span>    #[ensures(result.len() == 0)] //~ ERROR use of impure function "List::len" in pure code is not allowed
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        0
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Unfortunately, Prusti—or rather, the Rust compiler—will complain about
the postcondition:</p>
<pre><code class="language-plain">error: cannot find attribute `ensures` in this scope
  --&gt; list.rs:39:7
   |
39 |     #[ensures(result.len() == 0)]    
   |       ^^^^^^^
</code></pre>
<p>Prusti's specifications consist of Rust
<a href="https://doc.rust-lang.org/reference/procedural-macros.html">macros and attributes</a>
that are defined in a separate crate called <code>prusti-contracts</code>. To see how to add this crate to your project, see the <a href="tour/setup.html">Setup chapter</a>.
Before we can use these specifications, we need to make the path to these
macros and attributes visible:</p>
<pre><code class="language-rust noplaypen"><span class="boring">
</span><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span>use prusti_contracts::*;

<span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span>    #[ensures(result.len() == 0)] //~ ERROR use of impure function "List::len" in pure code is not allowed
    pub fn new() -&gt; Self {
        List { head: Link::Empty }
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        0
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Declaring that we use the <code>prusti_contracts</code> module removes the compiler error but
leads to a new error. This time it is an error raised by Prusti:</p>
<pre><code class="language-markdown">error: [Prusti: invalid specification] use of impure function "List::len" in pure code is not allowed
  --&gt; list.rs:34:15
   |
34 |     #[ensures(result.len() == 0)]    
   | 
</code></pre>
<p>Prusti complains about our use of the method <code>len()</code> in a postcondition because the
<a href="tour/../syntax.html">specification syntax</a> only admits calling so-called
<a href="tour/../verify/pure.html">pure functions</a>, that is, functions that are deterministic,
have no side effects, and always terminate.</p>
<p>While our implementation of <code>len()</code> clearly satisfies all of the above properties,
Prusti requires us to explicitly mark a function with the <code>#[pure]</code> attribute
before it considers a function pure.
After adding the <code>#[pure]</code> attribute to our <code>List::len()</code> method, it is allowed to
appear in Prusti specifications:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        self.head.len() //~ ERROR use of impure function "Link::len" in pure code is not allowed
    }
<span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)] //~ ERROR precondition of pure function call might not hold.
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        0
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>However, Prusti still won't verify! It produces the same error but now it refers
to the <em>body</em> of <code>len()</code>:</p>
<pre><code class="language-plain">error: [Prusti: invalid specification] use of impure function "Link::len" in pure code is not allowed
  --&gt; list.rs:30:9
   |
30 |         self.head.len() // (5)
   |         ^^^^
</code></pre>
<p>Whenever we add the attribute <code>#[pure]</code> to a function, Prusti will check whether that
function is indeed deterministic and side-effect free
(notice that termination is <em>not</em> checked); otherwise, it complains.
In this case, Prusti complains because we call an impure function,
namely <code>Link::len()</code>, within the body of the pure function <code>List::len()</code>.</p>
<!-- TODO: link capabilities/limitations chapter (termination) -->
<p>To fix this issue, it suffices to mark <code>Link::len()</code> as pure as well.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Link {
    #[pure]
    fn len(&amp;self) -&gt; usize {
        0
    }
}
// Prusti: VERIFIES</code></pre>
<pre><code class="language-plain">$ cargo prusti
// ...
Successful verification of 4 items
</code></pre>
<p>Prusti now manages to verify that <code>new()</code> always returns
a list for which the method <code>len()</code> returns 0. (notice
this is hardly surprising since <code>len()</code> ultimately always returns 0.)</p>
<h2 id="proper-implementation-of-len"><a class="header" href="#proper-implementation-of-len">Proper implementation of <code>len</code></a></h2>
<p>We will now properly implement <code>len()</code>, and while we're at it, <code>is_empty()</code> for <code>Link</code>. Both of them are pure functions, so we will add the <code>#[pure]</code> annotation. Both functions can be called without any restrictions, so they have the default postcondition <code>#[requires(true)]</code>, which we don't have to add manually. We also don't need to add any additional postconditions, since the body of pure functions is considered to be part of their contract.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Link {
    #[pure]
    fn len(&amp;self) -&gt; usize {
        match self {
            Link::Empty =&gt; 0,
            Link::More(node) =&gt; 1 + node.next.len(),
        }
    }

    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        matches!(self, Link::Empty)
    }
}
<span class="boring">
</span><span class="boring">fn test_len(link: &amp;Link) {
</span><span class="boring">    let link_is_empty = link.is_empty();
</span><span class="boring">    let link_len = link.len();
</span><span class="boring">    assert!(link_is_empty == (link_len == 0));
</span><span class="boring">}
</span><span class="boring"></span></code></pre>
<p>Here we use the <a href="https://doc.rust-lang.org/std/macro.matches.html"><code>matches!</code> macro</a> in <code>is_empty</code>, which is true if and only if the first argument matches the pattern in the second argument.</p>
<p>We can now check if the specification is working, by writing a function that panics if the specification is wrong:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn test_len(link: &amp;Link) {
    let link_is_empty = link.is_empty();
    let link_len = link.len();
    assert!(link_is_empty == (link_len == 0));
}
<span class="boring"></span></code></pre>
<p>The last line asserts that the <code>is_empty</code> function only returns <code>true</code> if the <code>len</code> function returns <code>0</code>.
And Prusti can verify it! Now we know that this assert statement holds for any <code>link</code> that is passed to the <code>test_len</code> function.
Note that we wrote this function only for demonstration purposes—the contract is checked even without the <code>test_len</code> function. We will consider the relationship between testing and static verification further in the <a href="tour/testing.html">Testing chapter</a>.</p>
<h3 id="overflow-checks"><a class="header" href="#overflow-checks">Overflow checks</a></h3>
<p>Here you can also see why we disabled overflow checking for this tutorial. If you remove the <code>check_overflows = false</code> flag in the <code>Prusti.toml</code> file, and then try to verify the crate again, you will get an error:</p>
<pre><code class="language-plain">[Prusti: verification error] assertion might fail with "attempt to add with overflow"
    Link::More(node) =&gt; 1 + node.next.len(),
                        ^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>This overflow could happen, if you call <code>len</code> on a list with more than <code>usize::MAX</code> elements. To prevent this verification error, we would have to constrain the maximum size of a <code>List</code>, which is beyond this tutorial.</p>
<h2 id="full-code-listing"><a class="header" href="#full-code-listing">Full code listing</a></h2>
<p>Before we continue, we provide the full code implemented in this chapter.
It should successfully verify with Prusti and we will further extend it throughout
the next chapters.</p>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn test_len(link: &amp;Link) {
</span><span class="boring">    let link_is_empty = link.is_empty();
</span><span class="boring">    let link_len = link.len();
</span><span class="boring">    assert!(link_is_empty == (link_len == 0));
</span><span class="boring">}
</span><span class="boring"></span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push"><a class="header" href="#push">Push</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a></p>
</blockquote>
<h2 id="informal-specifications"><a class="header" href="#informal-specifications">Informal specifications</a></h2>
<p>Our next goal is to implement and verify a method that pushes an integer onto a list.
In contrast to methods like <code>len</code>, <code>push</code> modifies the list; it thus takes
<code>&amp;mut self</code> as its first argument:</p>
<pre><code class="language-rust noplaypen ignore">impl List {
    pub fn push(&amp;mut self, elem: i32) {
        // TODO
    }
}</code></pre>
<p>Since <code>push</code> modifies <code>self</code>, it cannot be marked as a <code>#[pure]</code> function (it has a side effect on <code>self</code>). This means we will not be able to use <code>push</code> inside specifications for other functions later.</p>
<p>Before we implement <code>push</code>, let us briefly think of possible specifications.
Ideally, our implementation satisfies at least the following properties:</p>
<ol>
<li>Executing <code>push</code> increases the length of the underlying list by one. <a href="tour/push.html#first-property">(Chapter link)</a></li>
<li>After <code>push(elem)</code> the first element of the list stores the value <code>elem</code>. <a href="tour/push.html#second-property">(Chapter link)</a></li>
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged, but are moved back by 1 position. <a href="tour/push.html#third-property">(Chapter link)</a></li>
</ol>
<h2 id="initial-code"><a class="header" href="#initial-code">Initial code</a></h2>
<p>We start out with an implementation of <code>push</code>. If you want to learn more about how this code works, you can read <a href="https://rust-unofficial.github.io/too-many-lists/first-push.html">2.4: Push</a>, where it is explained in detail.</p>
<p>Here is our initial code:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem, // we can use `elem` instead of `elem: elem,` here, since the variable has the same name as the field
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="first-property"><a class="header" href="#first-property">First property</a></h2>
<p>The first property can easily be expressed as a postcondition that uses the
pure method <code>len</code> introduced in the <a href="tour/new.html">previous chapter</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem,
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Even though the above implementation of <code>push</code> is correct, attempting to verify it with Prusti still yields a verification error:</p>
<pre><code class="language-plain">[Prusti: verification error] postcondition might not hold.
</code></pre>
<p>This error may look surprising at first:
We create a new list node that stores the the original list in its next field.
Why is Prusti unable to realize that the length of the resulting list
is one plus the length of the original list?</p>
<p>The explanation is that Prusti performs <em>function modular</em> verification,
that is, it only uses a function's specification (instead of also consulting the
function's implementation) whenever it encounters a function call.
The only exception are <em>pure</em> functions, such as <code>len</code>, where Prusti also takes the
function body into account.</p>
<h3 id="adding-external-specifications-to-library-code"><a class="header" href="#adding-external-specifications-to-library-code">Adding external specifications to library code</a></h3>
<p>In our case, the function <code>std::mem::replace</code> is neither marked as <code>pure</code> nor does it
come with a specification. Hence, Prusti assumes that it is memory safe and nothing else.
That is, Prusti uses <code>true</code> as both pre- and postcondition of <code>replace</code>,
which is too weak to prove the specification of <code>push</code>. According to its specification,
<code>replace</code> could arbitrarily change the original list and thus also its length.
Hence, we cannot conclude that the length the list returned by
<code>replace(&amp;mut self.head, Link::Empty)</code> coincides with the length of the original
list.</p>
<p>We can remedy this issue by strengthening the specification of <code>replace</code>.
In this tutorial, we will assume that the standard library is correct, that is, we
do not attempt to verify specifications for functions in external crates,
like <code>replace</code>. To this end, we have to add the specification to the function.
This can be done with another piece of Prusti syntax, the <a href="tour/../verify/external.html">extern_spec</a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[extern_spec(std::mem)]
#[ensures(snap(dest) === src)]
#[ensures(result === old(snap(dest)))]
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
<span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Let's break this snippet down step by step:</p>
<ul>
<li>First, we write the Prusti annotation <code>#[extern_spec]</code> to denote that we are writing an external specification. This requires <code>prusti_contracts::*</code> to be imported first.</li>
<li>Next, we need to declare where the original function is located. In this case it is the module <code>std::mem</code>, so we put its path in  the parameter: <code>#[extern_spec(std::mem)]</code></li>
<li>After a quick search for <em>"rust std mem replace"</em> we can find the <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">documentation for std::mem::replace</a>. Here we can get the function signature: <code>pub fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T</code>. We then write down the signature in the inner module, followed by a <code>;</code>.</li>
<li>Since there are no preconditions to <code>replace</code>, we can use the (implicit) default <code>#[requires(true)]</code>.</li>
<li>For writing the postcondition, we use four pieces of Prusti syntax:
<ul>
<li><a href="tour/../syntax.html#snapshot-equality"><code>===</code></a> is called <strong>snapshot equality</strong> or <strong>logical equality</strong>. Is means that the left and right operands are structurally equal. <code>===</code> does not require the type of the compared elements to implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">PartialEq</a>, which would be required if we used the standard equality operator <code>==</code>.</li>
<li>The <a href="tour/../syntax.html#snap-function"><code>snap()</code></a> function takes a snapshot of a reference. It has a similar functionality to the <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>clone()</code></a> method, but does not require the type of the reference it is called on to implement the <code>Clone</code> trait. <code>snap</code> should only be used in specifications, since it ignores the borrow checker.</li>
<li>Lastly, we have the <a href="tour/../syntax.html#old-expressions"><code>old()</code> function</a>, which denotes that we want to refer to the state of <code>snap(dest)</code> from before the function was called.</li>
<li>The identifier <a href="tour/../syntax.html#result-variable"><code>result</code></a> is used to refer to the return parameter of the function.</li>
</ul>
</li>
<li>The postcondition consists of two parts, which can either be written in one condition with <code>&amp;&amp;</code>, or in multiple <code>#[ensures(...)]</code> annotations like in the example above.
<ul>
<li>The first condition <code>snap(dest) === src</code> means: <em>After the function returns, the location referenced by <code>dest</code> is structurally equal to the parameter <code>src</code></em></li>
<li>The second part of the postcondition is <code>result === old(snap(dest))</code>. This means: <em>The <code>result</code> returned by the function is structurally equal to the the element that was referenced by <code>dest</code> <strong>before</strong> the function was called.</em></li>
</ul>
</li>
</ul>
<p>Since <code>result</code> is structurally equal to <code>dest</code> from before the function call, Prusti knows that the pure function <code>len()</code> called on <code>result</code> returns the same value as it would have for <code>dest</code>.</p>
<p>An important thing to note here is that Prusti does <em><strong>not</strong></em> check if <code>replace</code> actually does what the external specification says it does. <code>#[extern_spec]</code> implicitly implies the <code>#[trusted]</code> annotation, which means that any postconditions are just accepted and used by Prusti.</p>
<h3 id="future"><a class="header" href="#future">Future</a></h3>
<p>There is currently new functionality planned for Prusti-assistant, which should enable the user to automatically generate parts of the <code>extern_spec</code> syntax.</p>
<p>There is also work being done for providing external specifications for the Rust standard library. Depending on when you are reading this, the <code>std::mem::replace</code> function might be annotated already, in that case this <code>extern_spec</code> may not be needed anymore.
You can track the progress and find some already completed specifications <a href="https://github.com/viperproject/prusti-dev/pull/1249">in this Pull Request</a>.</p>
<p>Specifications for the standard library should eventually be available in the <a href="https://crates.io/crates/prusti-std">prusti-std crate</a>. Any specifications in this crate will be available by adding it to your project's dependencies.</p>
<h2 id="trusted-functions"><a class="header" href="#trusted-functions">Trusted functions</a></h2>
<p>As mentioned above, <code>extern_specs</code> are implicitly <code>#[trusted]</code> by Prusti.
Trusted functions can be used for verifying projects containing external code that does not have Prusti annotations, or projects using Rust features that are not yet supported by Prusti.
An example is printing a string slice (not supported yet):</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
fn print(s: &amp;str) {
    println!("{s}");
}</code></pre>
<p>Prusti will <em><strong>not</strong></em> check trusted functions for correctness, so it is the programmers responsibility to check their the specification manually. <strong>A single incorrect specification of a trusted function can invalidate the correctness of Prusti as a whole!</strong>
Hence, trusted functions, like unsafe Rust code, need to be treated carefully and
require external justification.</p>
<p>For example, the following function will not cause the verification to fail:</p>
<pre><code class="language-rust noplaypen norun"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
fn incorrect_function() -&gt; i32 {
    panic!()
}</code></pre>
<p>This one is even worse, it will enable anything to be verified:</p>
<pre><code class="language-rust noplaypen norun"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[trusted]
#[ensures(false)]
fn wrong() {}</code></pre>
<h3 id="checking-the-extern_spec"><a class="header" href="#checking-the-extern_spec">Checking the <code>extern_spec</code></a></h3>
<p>Let's get back to our code. After adding the external specification for <code>std::mem::replace</code>, we can finally verify the first property of our <code>push</code> function:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem,
            next: std::mem::replace(&amp;mut self.head, Link::Empty),
        });

        self.head = Link::More(new_node);
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span>// Prusti: Verifies</code></pre>
<p>With this, the first of the three properties of <code>push</code> is verified, but we still have two more to prove.</p>
<h2 id="second-property"><a class="header" href="#second-property">Second property</a></h2>
<p>Recall the second property of our specification:</p>
<blockquote>
<ol start="2">
<li>After <code>push(elem)</code>, the first element of the list stores the value <code>elem</code>.</li>
</ol>
</blockquote>
<p>To formally specify the above property, we first introduce another pure function, called
<code>lookup</code>, that recursively traverses the list and returns its i-th element.
Our second desired property then corresponds to the postcondition
<code>self.lookup(0) == elem</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.head.lookup(index)
    }

    #[ensures(self.len() == old(self.len()) + 1)]
    #[ensures(self.lookup(0) == elem)] // 2. Property //~ ERROR postcondition might not hold
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}

impl Link {
    #[pure]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        match self {
            Link::More(node) =&gt; {
                if index == 0 {
                    node.elem
                } else {
                    node.next.lookup(index - 1)
                }
            }
            Link::Empty =&gt; unreachable!(), //~ ERROR: unreachable!(..) statement might be reachable
        }
    }
<span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span>}</code></pre>
<p>Consider the <code>match</code> statement in the last function.
The Rust compiler will complain if we attempt to omit the case <code>Link::Empty</code>.
We have no sensible implementation of <code>lookup</code> if the underlying list is empty,
so we used the macro <code>unreachable!()</code>, which will crash the program with a panic.
Since nothing prevents us from calling <code>lookup</code> on an empty list, Prusti complains:</p>
<pre><code class="language-plain">unreachable!(..) statement might be reachable
</code></pre>
<p>We can specify that <code>lookup</code> should only be called with an <code>index</code> between <code>0</code> and <code>self.len()</code> (which implies that we cannot call lookup on an empty list: <code>0 &lt;= index &lt; self.len()</code> implies <code>0 &lt; self.len()</code>). We do this by adding the precondition <code>index &lt; self.len()</code> to <em>both</em> <code>lookup</code> functions.
This is sufficient to verify our second property for <code>push</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}

impl Link {
    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        // ...
<span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span>    }
}</code></pre>
<p>We don't need to add the condition <code>0 &lt;= index</code>, since <code>index</code> has the type <code>usize</code>, and unsigned integers are always non-negative. (If you don't want Prusti to add this condition automatically, you can add the line <code>encode_unsigned_num_constraint = false</code> to your <code>Prusti.toml</code> file).</p>
<p>After these changes, Prusti can successfully verify the code, so the first two properties of <code>push</code> are correct.</p>
<h2 id="third-property"><a class="header" href="#third-property">Third property</a></h2>
<p>The third and final property we will verify for <code>push</code> is that the original list
content is not modified:</p>
<blockquote>
<ol start="3">
<li>After executing <code>push(elem)</code>, the elements of the original list remain unchanged (just shifted back by one).</li>
</ol>
</blockquote>
<p>To formalize the above property, we can reuse our pure function <code>lookup</code>,
<a href="tour/../syntax.html#quantifiers">quantifiers</a>, and <a href="tour/../syntax.html#old-expressions">old expressions</a>, that is, we add
the postcondition:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span>    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
                 old(self.lookup(i)) == self.lookup(i + 1)))] // 3. Property
    pub fn push(&amp;mut self, elem: i32) {
        // ...
<span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Let's break this expression down like before:</p>
<ul>
<li>We start with the <code>ensures</code> annotation, to denote a postcondition.</li>
<li><code>forall(..)</code> denotes a <a href="tour/../syntax.html#quantifiers">quantifier</a>. The variables and body of a quantifier use a syntax similar to Rust <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">closures</a>.</li>
<li>The two vertical bars: <code>||</code> contain the variables that the quantifier quantifies over. Here we only have one parameter <code>i: usize</code>. The type of the quantifier body is <code>bool</code>. You can think of the <code>forall</code> expression as follows: <em>Any values chosen for the quantified variables should result in the expression evaluating to <code>true</code></em>.</li>
<li>In this case, the quantifier uses the <a href="tour/../syntax.html#implications">implication operator <code>==&gt;</code></a>. It takes a left and right argument of type <code>bool</code> and is true if the left-hand side is false, or both sides are true.
<ul>
<li>The left-hand side of the implication is <code>(1 &lt;= i &amp;&amp; i &lt; self.len())</code>, which is the range where the right side must hold. If the index <code>i</code> is outside of this range, we don't care about it, so the condition will be false, making the entire implication true.</li>
<li>The right-hand side is the condition for everything being shifted back by one element: <code>old(self.lookup(i - 1)) == self.lookup(i)))</code>. Note that the right side is only evaluated if the left side is true, otherwise there would be an overflow in <code>i - 1</code> for <code>i == 0</code>, or a panic if <code>i</code> is out of bounds.</li>
</ul>
</li>
</ul>
<p>This code is verified successfully by Prusti, so we know that the <code>lookup</code> function satisfies the three postconditions!</p>
<h2 id="full-code-listing-1"><a class="header" href="#full-code-listing-1">Full code listing</a></h2>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] // 1. Property
</span><span class="boring">    #[ensures(self.lookup(0) == elem)] // 2. Property
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))] // 3. Property
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        // ...
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop"><a class="header" href="#pop">Pop</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-pop.html">2.5: Pop</a>,</p>
</blockquote>
<p>Let's continue with a function to remove and return the element at the head of a list. The way to write such a function is described in <a href="https://rust-unofficial.github.io/too-many-lists/first-pop.html">2.5: Pop</a>, we will focus on the verification in this chapter.</p>
<p>There is one change to the code from the original tutorial:
We will rename the <code>pop</code> function to <code>try_pop</code>. The return type is still <code>Option&lt;i32&gt;</code> and <code>try_pop</code> will return <code>Some(item)</code> if the list has elements, and <code>None</code> otherwise. We will then add a new <code>pop</code> function, which has the return type <code>i32</code>, and will panic if it is called with an empty list. However, by using the correct precondition, we can prevent the <code>pop</code> function from ever panicking! Here is the code:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] //~ ERROR postcondition might not hold
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match std::mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            },
        }
    }
    
<span class="boring">    #[requires(!self.is_empty())]
</span>    pub fn pop(&amp;mut self) -&gt; i32 {
        self.try_pop().unwrap()
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Link::Empty =&gt; unreachable!(),  
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>For the implementation of our <code>pop</code> method, we can reuse the implementation of <code>try_pop</code>. We call <code>try_pop</code> on the list, then call <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>unwrap</code></a> on the result. <code>unwrap</code> will return the inner value of the <code>Option</code> if it is <code>Some</code>, and will panic otherwise.
Normally, it is bad form to use <code>unwrap</code> in production code, where you should handle potential errors, instead of just panicking.
But, since we are verifying that there will never be <code>None</code> passed to <code>unwrap</code>, we should be able to get away with it here.</p>
<h2 id="properties-of-try_pop"><a class="header" href="#properties-of-try_pop">Properties of <code>try_pop</code></a></h2>
<p>Let's start by (informally) listing the properties we want our <code>try_pop</code> method to have.
We do not need a precondition for <code>try_pop</code>, since it can be called on any list.
This just leaves all the postconditions, which can be put into two categories:</p>
<ul>
<li>If the input list is empty before the call:
<ol>
<li>The <code>result</code> will be <code>None</code>.</li>
<li>The list will still be empty afterwards.</li>
</ol>
</li>
<li>If the input list is not empty before the call:
<ol>
<li>The <code>result</code> will be <code>Some(value)</code> and <code>value</code> is the element that was the first element of the list.</li>
<li>The length will get reduced by one.</li>
<li>All elements will be shifted forwards by one.</li>
</ol>
</li>
</ul>
<h2 id="properties-of-pop"><a class="header" href="#properties-of-pop">Properties of <code>pop</code></a></h2>
<p>For <code>pop</code>, we will add a precondition that the list is not empty.
The postconditions are similar to those of <code>try_pop</code>, but we can skip all those that only apply to empty lists.</p>
<h2 id="preparations"><a class="header" href="#preparations">Preparations</a></h2>
<h3 id="adding-listis_empty"><a class="header" href="#adding-listis_empty">Adding <code>List::is_empty</code></a></h3>
<p>Since we will need to check if a list is empty, we can implement a <code>#[pure]</code> function <code>is_empty</code> for <code>List</code>. It can just call the <code>is_empty</code> function on <code>self.head</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">    
</span>    #[pure]
    fn is_empty(&amp;self) -&gt; bool {
        self.head.is_empty()
    }
<span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] //~ ERROR postcondition might not hold
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Link::Empty =&gt; unreachable!(),  
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h3 id="writing-the-external-specifications-for-option"><a class="header" href="#writing-the-external-specifications-for-option">Writing the external specifications for <code>Option</code></a></h3>
<p>Since we use <code>Option::unwrap</code>, we will need an external specification for it. While we're at it, let's also write the <code>#[extern_spec]</code> for <code>Option::is_some</code> and <code>Option::is_none</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[extern_spec(std::mem)]
#[ensures(snap(dest) === src)]
#[ensures(result === old(snap(dest)))]
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;

// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49

#[extern_spec]
impl&lt;T&gt; std::option::Option&lt;T&gt; {
    #[requires(self.is_some())]
    #[ensures(old(self) === Some(result))]
    pub fn unwrap(self) -&gt; T;

    #[pure]
    #[ensures(result == matches!(self, None))]
    pub const fn is_none(&amp;self) -&gt; bool;

    #[pure]
    #[ensures(result == matches!(self, Some(_)))]
    pub const fn is_some(&amp;self) -&gt; bool;
}
<span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        // ...
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The syntax for writing external specifications for functions associated with <code>Option</code> is slightly different to that of <code>std::mem::replace</code>, which was a standalone function.</p>
<p>Note: In the future, you should just be able to import these external specifications using the <a href="https://crates.io/crates/prusti-std"><code>prusti-std</code> crate</a>. It should be available after <a href="https://github.com/viperproject/prusti-dev/pull/1249">this PR</a> is merged. Until then, you can find the work in progress specifications in the PR (e.g., for <a href="https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49"><code>Option::unwrap</code></a>).</p>
<h2 id="implementing-the-specification"><a class="header" href="#implementing-the-specification">Implementing the specification</a></h2>
<h3 id="writing-the-precondition"><a class="header" href="#writing-the-precondition">Writing the precondition</a></h3>
<p>Let's start our specification with the precondition of <code>pop</code>. Since the <code>unwrap</code> will panic if it is passed <code>None</code>, and <code>try_pop</code> returns <code>None</code> if the list is empty, we have to ensure that <code>pop</code> is only called on non-empty lists. Therefore we add it as a precondition:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List {
</span><span class="boring">            head: Link::Empty,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)] //~ ERROR postcondition might not hold
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span>    #[requires(!self.is_empty())]
    pub fn pop(&amp;mut self) -&gt; i32 {
        self.try_pop().unwrap()
    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            },
</span><span class="boring">            Link::Empty =&gt; unreachable!(),  
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>try_pop</code> does not require a precondition, since it will never panic.</p>
<h3 id="try_pop-postcondition-for-empty-lists"><a class="header" href="#try_pop-postcondition-for-empty-lists"><code>try_pop</code> postcondition for empty lists</a></h3>
<p>Now we will implement the two conditions that hold for <code>try_pop</code> if you pass an empty list to it.
To ensures that these are only checked for empty lists, we use the implication operator <a href="tour/../syntax.html#implications"><code>==&gt;</code></a>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    #[ensures(old(self.is_empty()) ==&gt;
        result.is_none() &amp;&amp;
        self.is_empty()
    )]
<span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span>    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        // ...
<span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        // ...
</span><span class="boring">        self.try_pop().unwrap()
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This specification ensures that for empty lists, the list will still be empty afterwards, and <code>try_pop</code> will return <code>None</code>.</p>
<h3 id="checking-if-the-correct-result-is-returned"><a class="header" href="#checking-if-the-correct-result-is-returned">Checking if the correct result is returned</a></h3>
<p>Now we can add the specification for checking if the correct result is returned. Like with <code>push</code>, we will use the <code>lookup</code> function to check that <code>result</code> was the first element of the list. For this we call <code>lookup(0)</code> on a snapshot of <code>self</code> before the function call: <code>old(snap(self)).lookup(0)</code>.</p>
<p>We can check this condition for snapshot equality (<a href="tour/../syntax.html#snapshot-equality"><code>===</code></a>) with <code>result</code>. This will always hold for <code>pop</code>, since the list is never empty:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span>    #[ensures(result === old(snap(self)).lookup(0))]
    pub fn pop(&amp;mut self) -&gt; i32 {
        // ...
<span class="boring">        self.try_pop().unwrap()
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>For <code>try_pop</code>, the condition only holds if the list was <em>not</em> empty before the call. In addition, the <code>result</code> is an <code>Option::Some</code>, so we will have to include this in our postcondition:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span>    #[ensures(!old(self.is_empty()) ==&gt;
<span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span>        result === Some(old(snap(self)).lookup(0))
    )]
    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        // ...
<span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        // ...
</span><span class="boring">        self.try_pop().unwrap()
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h3 id="using-predicate-to-reduce-code-duplication"><a class="header" href="#using-predicate-to-reduce-code-duplication">Using <code>predicate!</code> to reduce code duplication</a></h3>
<p>You may have noticed that the last two conditions for <code>pop</code> are the same as the last two of <code>try_pop</code>. We could just write the same conditions twice, but we can also place them in a Prusti <a href="tour/../verify/predicate.html"><code>predicate</code></a>, and then use that <code>predicate</code> in both specifications.</p>
<p>A <code>predicate</code> is basically just a <a href="tour/../verify/pure.html"><code>pure</code></a> function that returns a <code>bool</code>, but it can use all the additional syntax available in Prusti specifications. Let's look at an example:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>predicate! {
    fn larger_than_five(x: i32) -&gt; bool {
        x &gt; 5
    }
}

#[ensures(larger_than_five(result))]
fn ten() -&gt; i32 {
    10
}</code></pre>
<p>In our specific case, we want to have a predicate to compare the state of the list before the call to the state afterwards. The <code>old</code> function cannot be used inside a predicate, so we have to pass the two states as separate arguments. For this we write a <code>predicate</code> with two parameters, which represent the state before and after the function. Such a predicate is also called a "two-state predicate".
Note that we take both arguments by (immutable) reference, since we don't need the predicate to take ownership over the arguments:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>impl List {
    predicate! {
        // two-state predicate to check if the head of a list was correctly removed
        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
            // ...
        }
    }
}</code></pre>
<p>The two parameters are called <code>self</code> and <code>prev</code>, both with the type <code>&amp;Self</code>.</p>
<p>The goal of this predicate is to check if the head of a list was correctly removed.
For this we need check two properties:</p>
<ol>
<li>The new length is the old length minus one.</li>
<li>Each element is shifted forwards by one.</li>
</ol>
<p>We combine these two properties into a single expression using <code>&amp;&amp;</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span>    predicate! {
        // two-state predicate to check if the head of a list was correctly removed
        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
            self.len() == prev.len() - 1 // The length will decrease by 1
            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
                (1 &lt;= i &amp;&amp; i &lt; prev.len())
                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
        }
    }
<span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        // ...
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Here we are able to call <code>.len()</code> and <code>.lookup()</code> on both references, because they are pure functions.</p>
<p>To use this predicate, we call it on the list <code>self</code>, and then pass in a snapshot of the <code>self</code> from before the function call. Like with the condition for correctness of the <code>result</code>, we can just add this <code>predicate</code> to <code>pop</code>, but we need to restrict it to non-empty lists for <code>try_pop</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span>    #[ensures(!old(self.is_empty()) ==&gt;
        self.head_removed(&amp;old(snap(self)))
<span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span>    )]
    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        // ...
<span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

<span class="boring">    #[requires(!self.is_empty())]
</span>    #[ensures(self.head_removed(&amp;old(snap(self))))]
<span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span>    pub fn pop(&amp;mut self) -&gt; i32 {
        // ...
<span class="boring">        self.try_pop().unwrap()
</span>    }
}
<span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Prusti can now successfully verify the postconditions of both <code>try_pop</code> and <code>pop</code>, and ensure that they will not panic!
But there might still be a chance that our specifications don't fully match what we expect the code to do, so we will look at how to test specifications in the next chapter.</p>
<h2 id="full-code-listing-2"><a class="header" href="#full-code-listing-2">Full Code Listing</a></h2>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        // ...
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/first-test.html">2.6: Testing</a>,</p>
</blockquote>
<p>The linked chapter in the "Learning Rust With Entirely Too Many Linked Lists" tutorial explains how testing normal Rust code works. In this chapter we will show some differences between testing and verification and of the guarantees that each provides.</p>
<p>Note: Normal tests (marked with <code>#[cfg(test)]</code> or <code>#[test]</code>) are currently <em><strong>not</strong></em> checked by Prusti, but this may be added in the future. If you remove the <code>test</code> markers, Prusti will check any test like it would a normal function.</p>
<h2 id="differing-guarantees-of-verification-and-testing"><a class="header" href="#differing-guarantees-of-verification-and-testing">Differing guarantees of verification and testing</a></h2>
<p>Static verification has stronger guarantees than testing.
Running tests is only be possible for a small subset of all possible input values.
Take as an example a function taking a single value of type <code>u64</code>. The range of potential inputs is <code>0</code> to <code>2^64 - 1</code>, or <code>2^64</code> total values. Assuming each value takes 1 nano-second to test, it would take approximately <code>584.5</code> years to exhaustively test just this single function.</p>
<!-- (2^64)/1000000000 / 60 / 60 / 24 / 365.25 = 584.54204609062639795168200370117 -->
<p>In contrast, a static verifier like Prusti is able to check the entire input space of a function with the help of the specifications of each function.</p>
<p>When verification succeeds, you are guaranteed to not have a bug like a crash, overflow, or return value not fitting the specification.
This assumes that you have manually verified any <code>#[trusted]</code> functions and have checked for correct termination of all functions.
If the verification fails, you may have a bug, or your specifications are not strong enough.</p>
<p>The guarantees of testing are different. If a test fails, you know that you have a bug (either in the code or the test), but if all your tests pass, you might still have some bugs, just not with the specific inputs used in the tests.</p>
<p>In other words: Testing can show the <em>presence</em> of bugs, verification can show the <em>absence</em> of bugs.</p>
<p>It might still be worth writing (and running) some unit tests even for verified code, as they can serve as documentation on using a function. If you made some mistake in both the code and the specification, you may notice it if you write a test for it or use that function in another verified function.</p>
<p>The next section shows some potential issues with specifications.</p>
<h2 id="examples-of-bugs-in-specifications"><a class="header" href="#examples-of-bugs-in-specifications">Examples of bugs in specifications</a></h2>
<!-- We have written some specifications in the previous chapters, but we didn't check if they are actually correct or useful. For example, a -->
<p>The specification for a function could have a precondition that is too restrictive. If you never use the function in another verified function, you may not notice this:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[requires(x == 10)] // Restrictive precondition
#[ensures(result == x * x)]
pub fn restrictive_square(x: i32) -&gt; i32 {
    x * x
}

fn test() {
    assert!(restrictive_square(10) == 100); // Works
    assert!(restrictive_square(5) == 25); //~ ERROR precondition might not hold.
}</code></pre>
<p>This function is correct (ignoring potential overflows), but it is not useful, since the input must be <code>10</code>.</p>
<p>Another potential problem could be an incomplete postcondition. The <code>abs</code> function below should return the absolute value of <code>x</code>, but it only works for positive values. The verification will still succeed, because the postcondition does not specify the result for <code>x &lt; 0</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[pure]
// Note that a postcondition is not actually needed here, since `abs` is #[pure]
#[ensures(x &gt;= 0 ==&gt; result == x)]
pub fn abs(x: i32) -&gt; i32 {
    x
}

fn test_abs() {
    prusti_assert!(abs(8) == 8); // Works
    prusti_assert!(abs(-10) == 10); //~ ERROR the asserted expression might not hold
}</code></pre>
<p>This bug will be noticed as soon as you try using <code>abs</code> with a negative input.
For functions internal to a project, you will likely notice mistakes in the specification when you try to use the function in other code. However, when you have public functions, like for example in a library, you might want to write some test functions for your specification. Specification errors sometimes only show up when they are actually used.</p>
<h2 id="testing-our-linked-list-specifications"><a class="header" href="#testing-our-linked-list-specifications">Testing our linked list specifications</a></h2>
<p>To check our specifications and code, we could write a function that relies on the expected behavior. We can create a new namespace for the test, here we call it <code>prusti_tests</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Link {
</span><span class="boring">    Empty,
</span><span class="boring">    More(Box&lt;Node&gt;),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        self.head.len()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        self.head.is_empty()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: Link::Empty }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        self.head.lookup(index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: std::mem::replace(&amp;mut self.head, Link::Empty),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Link::More(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match std::mem::replace(&amp;mut self.head, Link::Empty) {
</span><span class="boring">            Link::Empty =&gt; None,
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Link {
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        match self {
</span><span class="boring">            Link::More(node) =&gt; {
</span><span class="boring">                if index == 0 {
</span><span class="boring">                    node.elem
</span><span class="boring">                } else {
</span><span class="boring">                    node.next.lookup(index - 1)
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            Link::Empty =&gt; unreachable!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn len(&amp;self) -&gt; usize {
</span><span class="boring">        match self {
</span><span class="boring">            Link::Empty =&gt; 0,
</span><span class="boring">            Link::More(node) =&gt; 1 + node.next.len(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self, Link::Empty)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;

    fn _test_list(){
        let mut list = List::new(); // create an new, empty list
        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty

        list.push(5);
        list.push(10);
        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
        prusti_assert!(list.lookup(0) == 10); // head is 10
        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly

        let x = list.pop();
        prusti_assert!(x == 10); // pop returns the value that was added last

        match list.try_pop() {
            Some(y) =&gt; assert!(y == 5),
            None =&gt; unreachable!()
        }

        let z = list.try_pop();
        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
    }
<span class="boring">
</span><span class="boring">    // This shows a test that takes 2 lists as input parameters:
</span><span class="boring">    #[requires(list_0.len() &gt;= 4)]
</span><span class="boring">    #[requires(!list_1.is_empty())]
</span><span class="boring">    #[requires(list_0.lookup(1) == 42)]
</span><span class="boring">    #[requires(list_0.lookup(3) == list_1.lookup(0))]
</span><span class="boring">    fn _test_lists(list_0: &amp;mut List, list_1: &amp;mut List) {
</span><span class="boring">        let x0 = list_0.pop();
</span><span class="boring">
</span><span class="boring">        list_0.push(10);
</span><span class="boring">        prusti_assert!(list_0.len() &gt;= 4);
</span><span class="boring">        prusti_assert!(list_0.lookup(1) == 42);
</span><span class="boring">        assert!(list_0.pop() == 10); // Cannot be `prusti_assert`, `pop` changes the list
</span><span class="boring">
</span><span class="boring">        let x1 = list_0.pop();
</span><span class="boring">        let x2 = list_0.pop();
</span><span class="boring">        let x3 = list_0.pop();
</span><span class="boring">        prusti_assert!(x0 == old(snap(list_0)).lookup(0));
</span><span class="boring">        prusti_assert!(x1 == old(snap(list_0)).lookup(1) &amp;&amp; x1 == 42);
</span><span class="boring">        prusti_assert!(x2 == old(snap(list_0)).lookup(2));
</span><span class="boring">        prusti_assert!(x3 == old(snap(list_0)).lookup(3));
</span><span class="boring">        
</span><span class="boring">        let y0 = list_1.pop();
</span><span class="boring">        prusti_assert!(y0 == old(snap(list_1)).lookup(0));
</span><span class="boring">        prusti_assert!(y0 == x3);
</span><span class="boring">    }
</span>}
// Prusti: verifies</code></pre>
<!-- We can also have tests that take arguments and also have pre- and postconditions:

```rust,noplaypen
# // The next line is only required for doctests, you can ignore/remove it
# extern crate prusti_contracts;
# use prusti_contracts::*;
# 
# fn main() {}
# 
# pub struct List {
#     head: Link,
# }
# 
# enum Link {
#     Empty,
#     More(Box<Node>),
# }
# 
# struct Node {
#     elem: i32,
#     next: Link,
# }
# 
# #[extern_spec(std::mem)]
# #[ensures(snap(dest) === src)]
# #[ensures(result === old(snap(dest)))]
# fn replace<T>(dest: &mut T, src: T) -> T;
# 
# // Specs for std::option::Option<T>::unwrap(self) (and others) can be found here (work in progress):
# // https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
# 
# #[extern_spec]
# impl<T> std::option::Option<T> {
#     #[requires(self.is_some())]
#     #[ensures(old(self) === Some(result))]
#     pub fn unwrap(self) -> T;
#     
#     #[pure]
#     #[ensures(result == matches!(self, None))]
#     pub const fn is_none(&self) -> bool;
# 
#     #[pure]
#     #[ensures(result == matches!(self, Some(_)))]
#     pub const fn is_some(&self) -> bool;
# }
# 
# impl List {
#     #[pure]
#     pub fn len(&self) -> usize {
#         self.head.len()
#     }
# 
#     #[pure]
#     fn is_empty(&self) -> bool {
#         self.head.is_empty()
#     }
# 
#     #[ensures(result.len() == 0)]
#     pub fn new() -> Self {
#         List { head: Link::Empty }
#     }
# 
#     #[pure]
#     #[requires(index < self.len())]
#     pub fn lookup(&self, index: usize) -> i32 {
#         self.head.lookup(index)
#     }
# 
#     #[ensures(self.len() == old(self.len()) + 1)]
#     #[ensures(self.lookup(0) == elem)]
#     #[ensures(forall(|i: usize| (i < old(self.len())) ==>
#                  old(self.lookup(i)) == self.lookup(i + 1)))]
#     pub fn push(&mut self, elem: i32) {
#         let new_node = Box::new(Node {
#             elem,
#             next: std::mem::replace(&mut self.head, Link::Empty),
#         });
# 
#         self.head = Link::More(new_node);
#     }
# 
#     predicate! {
#         // two-state predicate to check if the head of a list was correctly removed
#         fn head_removed(&self, prev: &Self) -> bool {
#             self.len() == prev.len() - 1 // The length will decrease by 1
#             && forall(|i: usize| // Every element will be shifted forwards by one
#                 (1 <= i && i < prev.len())
#                     ==> prev.lookup(i) == self.lookup(i - 1))
#         }
#     }
# 
#     #[ensures(old(self.is_empty()) ==>
#         result.is_none() &&
#         self.is_empty()
#     )]
#     #[ensures(!old(self.is_empty()) ==>
#         self.head_removed(&old(snap(self)))
#         &&
#         result === Some(old(snap(self)).lookup(0))
#     )]
#     pub fn try_pop(&mut self) -> Option<i32> {
#         match std::mem::replace(&mut self.head, Link::Empty) {
#             Link::Empty => None,
#             Link::More(node) => {
#                 self.head = node.next;
#                 Some(node.elem)
#             }
#         }
#     }
# 
#     #[requires(!self.is_empty())]
#     #[ensures(self.head_removed(&old(snap(self))))]
#     #[ensures(result === old(snap(self)).lookup(0))]
#     pub fn pop(&mut self) -> i32 {
#         self.try_pop().unwrap()
#     }
# }
# 
# impl Link {
#     #[pure]
#     #[requires(index < self.len())]
#     pub fn lookup(&self, index: usize) -> i32 {
#         match self {
#             Link::More(node) => {
#                 if index == 0 {
#                     node.elem
#                 } else {
#                     node.next.lookup(index - 1)
#                 }
#             }
#             Link::Empty => unreachable!(),
#         }
#     }
# 
#     #[pure]
#     fn len(&self) -> usize {
#         match self {
#             Link::Empty => 0,
#             Link::More(node) => 1 + node.next.len(),
#         }
#     }
# 
#     #[pure]
#     fn is_empty(&self) -> bool {
#         matches!(self, Link::Empty)
#     }
# }
# 
#[cfg(prusti)]
mod prusti_tests {
    use super::*;

#     fn _test_list(){
#         let mut list = List::new(); // create an new, empty list
#         prusti_assert!(list.is_empty() && list.len() == 0); // list should be empty
# 
#         list.push(5);
#         list.push(10);
#         prusti_assert!(!list.is_empty() && list.len() == 2); // length correct
#         prusti_assert!(list.lookup(0) == 10); // head is 10
#         prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
# 
#         let x = list.pop();
#         prusti_assert!(x == 10); // pop returns the value that was added last
# 
#         match list.try_pop() {
#             Some(y) => assert!(y == 5),
#             None => unreachable!()
#         }
# 
#         let z = list.try_pop();
#         prusti_assert!(list.is_empty() && list.len() == 0); // length correct
#         prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
#     }
# 
    // This shows a test that takes 2 lists as input parameters:
    #[requires(list_0.len() >= 4)]
    #[requires(!list_1.is_empty())]
    #[requires(list_0.lookup(1) == 42)]
    #[requires(list_0.lookup(3) == list_1.lookup(0))]
    fn _test_lists(list_0: &mut List, list_1: &mut List) {
        let x0 = list_0.pop();

        list_0.push(10);
        prusti_assert!(list_0.len() >= 4);
        prusti_assert!(list_0.lookup(1) == 42);
        assert!(list_0.pop() == 10); // Cannot be `prusti_assert`, `pop` changes the list

        let x1 = list_0.pop();
        let x2 = list_0.pop();
        let x3 = list_0.pop();
        prusti_assert!(x0 == old(snap(list_0)).lookup(0));
        prusti_assert!(x1 == old(snap(list_0)).lookup(1) && x1 == 42);
        prusti_assert!(x2 == old(snap(list_0)).lookup(2));
        prusti_assert!(x3 == old(snap(list_0)).lookup(3));
        
        let y0 = list_1.pop();
        prusti_assert!(y0 == old(snap(list_1)).lookup(0));
        prusti_assert!(y0 == x3);
    }
}
// Prusti: verifies
``` -->
<p>Note the <code>#[cfg(prusti)]</code> on the module <code>prusti_tests</code>. This makes the module only available during verification, with no effect during normal compilation, similar to <code>#[cfg(test)]</code> for unit tests.</p>
<p>Our test code can be verified, so it appears that our specification is not too restrictive or incomplete.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/second.html">3: An Ok Single-Linked Stack</a>,
<a href="https://rust-unofficial.github.io/too-many-lists/second-option.html">3.1. Option</a></p>
</blockquote>
<p>Just like in the "Learning Rust With Entirely Too Many Linked Lists" tutorial, we can change our <code>enum Link</code> to use the <code>Option</code> type via a type alias instead of manually implementing <code>Empty</code> and <code>More</code>:</p>
<pre><code class="language-rust noplaypen ignore">type Link = Option&lt;Box&lt;Node&gt;&gt;;</code></pre>
<p>In order to use the <code>Option::take</code> function, we also have to implement the <code>extern_spec</code> for it. As you can see, it is quite similar to the <code>extern_spec</code> for <code>mem::replace</code>, since <code>take</code> does the same as <code>replace(&amp;mut self, None)</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>#[extern_spec(std::mem)]
#[ensures(snap(dest) === src)]
#[ensures(result === old(snap(dest)))]
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;

<span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span>#[extern_spec]
impl&lt;T&gt; std::option::Option&lt;T&gt; {
<span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span>    #[ensures(result === old(snap(self)))]
    #[ensures(self.is_none())]
    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Changing the <code>Link</code> type requires some adjustments of the code and specifications. With the new type alias for <code>Link</code>, we cannot have an <code>impl Link</code> block anymore, so our <code>lookup</code> and <code>len</code> functions on <code>Link</code> are now normal, free-standing functions:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        link_len(&amp;self.head)
    }

<span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span>    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        link_lookup(&amp;self.head, index)
    }
<span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span>#[pure]
#[requires(index &lt; link_len(link))]
fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
    match link {
        Some(node) =&gt; {
            if index == 0 {
                node.elem
            } else {
                link_lookup(&amp;node.next, index - 1)
            }
        }
        None =&gt; unreachable!(),
    }
}

#[pure]
fn link_len(link: &amp;Link) -&gt; usize {
    match link {
        None =&gt; 0,
        Some(node) =&gt; 1 + link_len(&amp;node.next),
    }
}
<span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Due to current limitations of Prusti, we cannot replace our <code>link_len</code> and <code>link_lookup</code> functions with loops:</p>
<!-- TODO: link capabilities/limitations chapter (loops in pure functions) -->
<pre><code class="language-rust noplaypen ignore"><span class="boring">// ignore-test: This code causes Prusti to panic
</span><span class="boring">// The next and previous line are only required for (doc)tests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
    // Prusti cannot verify these functions at the moment,
    // since loops in pure functions are not yet supported:
    #[pure]
    pub fn len(&amp;self) -&gt; usize {
        let mut curr = &amp;self.head;
        let mut i = 0;
        while let Some(node) = curr {
            body_invariant!(true);
            i += 1;
            curr = &amp;node.next;
        }
        i
    }

    #[pure]
    #[requires(index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        let mut curr = &amp;self.head;
        let mut i = index;
        while let Some(node) = curr {
            body_invariant!(true);
            if i == 0 {
                return node.elem;
            }
            i -= 1;
            curr = &amp;node.next;
        }
        unreachable!()
    }
}</code></pre>
<p>Since Prusti doesn't fully support closures yet, we also cannot do the rewrite to use the <code>Option::map</code> function:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl List {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span>    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match self.head.take() { // Replace mem::swap with the buildin Option::take
            None =&gt; None,
            Some(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
    
    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
    // // Currently you get this error:
    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
    //     let tmp = self.head.take();
    //     tmp.map(move |node| {
    //         self.head = node.next;
    //         node.elem
    //     })
    // }
<span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>After all the changes done in this chapter, Prusti is still be able to verify the code, so we didn't break anything.
If you want to see the full code after all the changes, expand the following code block.</p>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List {
</span><span class="boring">    head: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link = Option&lt;Box&lt;Node&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node {
</span><span class="boring">    elem: i32,
</span><span class="boring">    next: Link,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(self.lookup(0) == elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) == self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: i32) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) == self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(old(snap(self)).lookup(0))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // // This will likely work in the future, but doesn't currently (even if you provide an `extern_spec` for `Option::map`):
</span><span class="boring">    // // Currently you get this error:
</span><span class="boring">    // //     [Prusti: unsupported feature] unsupported creation of unique borrows (implicitly created in closure bindings)
</span><span class="boring">    // pub fn try_pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
</span><span class="boring">    //     let tmp = self.head.take();
</span><span class="boring">    //     tmp.map(move |node| {
</span><span class="boring">    //         self.head = node.next;
</span><span class="boring">    //         node.elem
</span><span class="boring">    //     })
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; i32 {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup(link: &amp;Link, index: usize) -&gt; i32 {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len(link: &amp;Link) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">        prusti_assert!(list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="making-it-all-generic"><a class="header" href="#making-it-all-generic">Making it all Generic</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/second-generic.html">3.2: Generic</a></p>
</blockquote>
<p>Just like the corresponding chapter in the "Learning Rust With Entirely Too Many Linked Lists" book, we will change our list to have a generic element type <code>T</code>, not just <code>i32</code>. For this, we go through our code an add the generic parameter <code>T</code> where required. The compiler really helps for this, since it will mark where a generic parameter is needed.
If you do this process with Prusti, at some point you will encounter the following error:</p>
<pre><code class="language-plain">[E0369] binary operation `==` cannot be applied to type `T`.
</code></pre>
<p>This is because the generic type <code>T</code> might not implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> and thus not have an equality function <code>==</code> that could be called on it like <code>i32</code> does. Since we only used <code>==</code> inside of specifications, we can fix this problems by using <a href="tour/../syntax.html#snapshot-equality">snapshot equality <code>===</code></a> instead.</p>
<p>Here you can see where some of the changes were done (expand to see the full changes):</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>// Make the types generic:
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

<span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; List&lt;T&gt; {
    // ...

<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    // Return type is changed from `T` to `&amp;T`
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)] // Here we add a `snap`
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">        old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        // ...
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span>    // Return type changed from `Option&lt;i32&gt;`
    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        // ...
<span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }

<span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span>    // Return type changed from `i32`
    pub fn pop(&amp;mut self) -&gt; T {
        self.try_pop().unwrap()
    }
}

<span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">// Return type is changed from `T` to `&amp;T`
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                // Here we return a reference to `elem` instead of the `elem` itself
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;

<span class="boring">    fn _test_list(){
</span><span class="boring">        // ...
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        // Here we can just dereference the lookup with `*`, since `i32` is `Copy`:
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>This code still fails to compile, this time with an error from the function <code>link_lookup</code>:</p>
<pre><code class="language-plain">[E0507] cannot move out of `node.elem` which is behind a shared reference.
[Note] move occurs because `node.elem` has type `T`, which does not implement the `Copy` trait
</code></pre>
<p>To fix this, we will change <code>List::lookup</code> and <code>link_lookup</code> to return a reference to the element at index <code>i</code>, instead of the element itself. This was not needed for <code>i32</code>, since it implements the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> trait. For a general type <code>T</code>, returning it by value would move it out of the list, which we don't want. By returning a reference instead, the lookups will work for any type <code>T</code>, because the element stays in the list.</p>
<p>In addition to returning a reference, we will have to adjust some of the places where <code>lookup</code> is used, mostly by dereferencing or using <code>snap</code> on the returned reference:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// Make the types generic:
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; List&lt;T&gt; {
    // ...

<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span>    // Return type is changed from `T` to `&amp;T`
    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
        link_lookup(&amp;self.head, index)
    }
<span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span>    #[ensures(snap(self.lookup(0)) === elem)] // Here we add a `snap`
<span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">        old(self.lookup(i)) === self.lookup(i + 1)))]
</span>    pub fn push(&amp;mut self, elem: T) {
        // ...
<span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    // Return type changed from `Option&lt;i32&gt;`
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    // Return type changed from `i32`
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span>    }
}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span>// Return type is changed from `T` to `&amp;T`
fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
    match link {
        Some(node) =&gt; {
            if index == 0 {
                // Here we return a reference to `elem` instead of the `elem` itself
                &amp;node.elem
            } else {
                link_lookup(&amp;node.next, index - 1)
            }
        }
        None =&gt; unreachable!(),
    }
}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;

    fn _test_list(){
        // ...
<span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span>        // Here we can just dereference the lookup with `*`, since `i32` is `Copy`:
        prusti_assert!(*list.lookup(0) == 10); // head is 10
        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
<span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span>    }
}</code></pre>
<p>After all these changes, Prusti is able to verify the code again, so now our linked list can be used to store elements of any type, not just <code>i32</code>!
If you want to see the full code after all the changes, expand the following code block.</p>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// Make the types generic:
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    // ...
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    // Return type is changed from `T` to `&amp;T`
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)] // Here we add a `snap`
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">        old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        // ...
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    // Return type changed from `Option&lt;i32&gt;`
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        // ...
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    // Return type changed from `i32`
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">// Return type is changed from `T` to `&amp;T`
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                // Here we return a reference to `elem` instead of the `elem` itself
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        // ...
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        // Here we can just dereference the lookup with `*`, since `i32` is `Copy`:
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="peek"><a class="header" href="#peek">Peek</a></h1>
<blockquote>
<p><strong>Recommended reading:</strong>
<a href="https://rust-unofficial.github.io/too-many-lists/second-peek.html">3.3: Peek</a></p>
</blockquote>
<p>Ideally, we could implement <code>peek</code> and <code>try_peek</code> like we implemented <code>pop</code> and <code>try_pop</code> before. Like <code>pop</code>, <code>peek</code> can only be called if the list is non-empty, and it then always returns a reference to the element at the head of the list (type <code>&amp;T</code>). Similarly, <code>try_peek</code> can be called on any list, but returns an <code>Option&lt;&amp;T&gt;</code>. The latter is currently not possible in Prusti, since structures containing references are not supported at the moment.</p>
<!-- TODO: link capabilities/limitations chapter (refs in structs) -->
<p>We can still implement <code>peek</code>, but we just cannot do it by using <code>try_peek</code> like before in <code>pop</code>. Instead, we can reuse the already implemented and verified <code>lookup</code> function! Since <code>lookup</code> can return a reference to any element of the list, we can just call <code>self.lookup(0)</code> inside of <code>peek</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; List&lt;T&gt; {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span>    // // Not currently possible in Prusti
    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    //     todo!()
    // }

    #[pure]
    #[requires(!self.is_empty())]
    pub fn peek(&amp;self) -&gt; &amp;T {
        self.lookup(0)
    }
}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We can also write a test again, to see if our specification holds up in actual code:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;

<span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span>    fn _test_peek() {
        let mut list = List::new();
        list.push(16);
        prusti_assert!(list.peek() === list.lookup(0));
        prusti_assert!(*list.peek() == 16);
        
        list.push(5);
        prusti_assert!(*list.peek() == 5);

        list.pop();
        prusti_assert!(*list.peek() == 16);
    }
}</code></pre>
<p>This verifies too, so it appears our implementation of <code>peek</code> is correct.</p>
<p>The <code>peek</code> method only returns an immutable reference, but what if you want to get a mutable reference? We will see how in the next chapter.</p>
<p>Here you can see the full code we have now:</p>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pledges"><a class="header" href="#pledges">Pledges</a></h1>
<p>Now we will look at <a href="tour/../verify/pledge.html"><code>pledges</code></a>. Pledges are used for functions that return mutable references into some datastructure.
With a pledge you can explain to Prusti how the original object gets affected by changes to the returned reference.
We will demonstrate by implementing a function that gives you a mutable reference to the first element in the list.</p>
<h2 id="implementing-peek_mut"><a class="header" href="#implementing-peek_mut">Implementing <code>peek_mut</code></a></h2>
<p>The <code>peek_mut</code> will return a mutable reference of type <code>T</code>, so the precondition of the list requires it to be non-empty.
As a first postcondition, we want to ensure that the <code>result</code> of <code>peek_mut</code> points to the first element of the list.</p>
<p>In the code, we need to get a mutable reference to the type inside the <code>Link = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;</code>. This requires the use of the type <code>Option&lt;&amp;mut T&gt;</code>, which is a structure containing a reference, so it is not yet supported by Prusti. To still be able to verify <code>peek_mut</code>, we mark it as <code>trusted</code> for now:</p>
<!-- TODO: link capabilities/limitations chapter (refs in structs) -->
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span>impl&lt;T&gt; List&lt;T&gt; {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self))) &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() {
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // #[requires(index &lt; self.len())]
</span><span class="boring">    // pub fn lookup_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
</span><span class="boring">    //     let mut curr_node = &amp;mut self.head;
</span><span class="boring">    //     let mut index = index; // Workaround for Prusti not supporting mutable fn arguments
</span><span class="boring">    //     while index != 0 {
</span><span class="boring">    //         body_invariant!(true);
</span><span class="boring">    //         if let Some(next_node) = curr_node { // reference in enum
</span><span class="boring">    //             curr_node = &amp;mut next_node.next;
</span><span class="boring">    //         } else {
</span><span class="boring">    //             unreachable!();
</span><span class="boring">    //         }
</span><span class="boring">    //         index -= 1;
</span><span class="boring">    //     }
</span><span class="boring">    //     if let Some(node) = curr_node { // ERROR: [Prusti: unsupported feature] the creation of loans in this loop is not supported (ReborrowingDagHasNoMagicWands)
</span><span class="boring">    //         &amp;mut node.elem
</span><span class="boring">    //     } else {
</span><span class="boring">    //         unreachable!()
</span><span class="boring">    //     }
</span><span class="boring">    // }
</span><span class="boring">
</span>    #[trusted] // required due to unsupported reference in enum
    #[requires(!self.is_empty())]
    #[ensures(snap(result) === old(snap(self.peek())))]
    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
        // This does not work in Prusti at the moment:
        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
        // this then gets matched to "Some(node: &amp;mut T)"
        // References in enums are not yet supported, so this cannot be verified by Prusti
        if let Some(node) = &amp;mut self.head {
            &amp;mut node.elem
        } else {
            unreachable!()
        }
    }
}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2); //~ ERROR the asserted expression might not hold
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // this fails too
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // this fails too
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Note that <code>peek_mut</code> cannot be <code>#[pure]</code>, since it returns a mutable reference.</p>
<h2 id="writing-a-test-for-our-specification"><a class="header" href="#writing-a-test-for-our-specification">Writing a test for our specification</a></h2>
<p>Let's write a test to see if our specification works:</p>
<ul>
<li>Create a list with two elements: [16, 8]</li>
<li>Get a mutable reference to the first element (16)</li>
<li>Change the first element to 5</li>
<li>Check if the list still has the expected properties after <code>first</code> gets dropped
<ul>
<li>Is the length 2?</li>
<li>Is the first element 5?</li>
<li>Is the second element 8?</li>
</ul>
</li>
</ul>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self))) &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() {
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    // #[requires(index &lt; self.len())]
</span><span class="boring">    // pub fn lookup_mut(&amp;mut self, index: usize) -&gt; &amp;mut T {
</span><span class="boring">    //     let mut curr_node = &amp;mut self.head;
</span><span class="boring">    //     let mut index = index; // Workaround for Prusti not supporting mutable fn arguments
</span><span class="boring">    //     while index != 0 {
</span><span class="boring">    //         body_invariant!(true);
</span><span class="boring">    //         if let Some(next_node) = curr_node { // reference in enum
</span><span class="boring">    //             curr_node = &amp;mut next_node.next;
</span><span class="boring">    //         } else {
</span><span class="boring">    //             unreachable!();
</span><span class="boring">    //         }
</span><span class="boring">    //         index -= 1;
</span><span class="boring">    //     }
</span><span class="boring">    //     if let Some(node) = curr_node { // ERROR: [Prusti: unsupported feature] the creation of loans in this loop is not supported (ReborrowingDagHasNoMagicWands)
</span><span class="boring">    //         &amp;mut node.elem
</span><span class="boring">    //     } else {
</span><span class="boring">    //         unreachable!()
</span><span class="boring">    //     }
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[trusted] // required due to unsupported reference in enum
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(snap(result) === old(snap(self.peek())))]
</span><span class="boring">    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
</span><span class="boring">        // This does not work in Prusti at the moment:
</span><span class="boring">        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
</span><span class="boring">        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
</span><span class="boring">        // this then gets matched to "Some(node: &amp;mut T)"
</span><span class="boring">        // References in enums are not yet supported, so this cannot be verified by Prusti
</span><span class="boring">        if let Some(node) = &amp;mut self.head {
</span><span class="boring">            &amp;mut node.elem
</span><span class="boring">        } else {
</span><span class="boring">            unreachable!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(prusti)]
mod prusti_tests {
    use super::*;
<span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2); //~ ERROR the asserted expression might not hold
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // this fails too
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // this fails too
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>But this fails, Prusti cannot verify any of our last three <code>prusti_assert</code> statements. This is where pledges come in. We have to tell Prusti how the <code>result</code> affects the original list. Without this, Prusti assumes that changes to the reference can change every property of the original list, so nothing can be known about it after the reference gets dropped.</p>
<h2 id="writing-the-pledge"><a class="header" href="#writing-the-pledge">Writing the pledge</a></h2>
<p>The pledge is written using an annotation, like <code>ensures</code> and <code>requires</code>, but with the keyword <code>after_expiry</code>.
Inside we have all the conditions that hold after the returned reference gets dropped:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span>impl&lt;T&gt; List&lt;T&gt; {
<span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self))) &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() {
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[trusted] // required due to unsupported reference in enum
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(snap(result) === old(snap(self.peek())))]
</span>    #[after_expiry(
        old(self.len()) === self.len() // (1. condition)
        &amp;&amp; forall(|i: usize| 1 &lt;= i &amp;&amp; i &lt; self.len() // (2. condition)
            ==&gt; old(snap(self.lookup(i))) === snap(self.lookup(i)))
        &amp;&amp; snap(self.peek()) === before_expiry(snap(result)) // (3. condition)
    )]
    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
<span class="boring">        // This does not work in Prusti at the moment:
</span><span class="boring">        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
</span><span class="boring">        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
</span><span class="boring">        // this then gets matched to "Some(node: &amp;mut T)"
</span><span class="boring">        // References in enums are not yet supported, so this cannot be verified by Prusti
</span><span class="boring">        if let Some(node) = &amp;mut self.head {
</span><span class="boring">            &amp;mut node.elem
</span><span class="boring">        } else {
</span><span class="boring">            unreachable!()
</span><span class="boring">        }
</span>        // ...
    }
}
<span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2);
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // slot 0 is now `5`
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // slot 1 is unchanged
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>We have three properties here:</p>
<ol>
<li>The list will have the same length afterwards.</li>
<li>Any element of the list with index <code>1..list.len()</code> will not be changed.</li>
<li>The element at the head of the list is the value that was assigned to the returned reference. This is denoted with the <code>before_expiry</code> function.</li>
</ol>
<p>With these three properties specified, our test verifies successfully!</p>
<h2 id="assert-on-expiry"><a class="header" href="#assert-on-expiry">Assert on expiry</a></h2>
<p>Like <code>after_expiry</code>, there is also <code>assert_on_expiry</code>. It is used to check for conditions that have to be true when the returned reference expires, usually in order to uphold some type invariant.</p>
<p>As an example, we could use this to make sure that our list of <code>i32</code> can only contain elements between 0 and 16.
Given that this invariant held before the reference was given out, it will hold again only if the element, potentially changed by the caller, is still in the correct range:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self)))
</span><span class="boring">        &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() { // Replace mem::swap with the buildin Option::take
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[trusted] // required due to unsupported reference in enum
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(snap(result) === old(snap(self.peek())))]
</span><span class="boring">    #[after_expiry(
</span><span class="boring">        old(self.len()) === self.len() // (1.)
</span><span class="boring">        &amp;&amp; forall(|i: usize| 1 &lt;= i &amp;&amp; i &lt; self.len() // (2.)
</span><span class="boring">            ==&gt; old(snap(self.lookup(i))) === snap(self.lookup(i)))
</span><span class="boring">        &amp;&amp; snap(self.peek()) === before_expiry(snap(result)) // (3.)
</span><span class="boring">    )]
</span><span class="boring">    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
</span><span class="boring">        // This does not work in Prusti at the moment:
</span><span class="boring">        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
</span><span class="boring">        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
</span><span class="boring">        // this then gets matched to "Some(node: &amp;mut T)"
</span><span class="boring">        // References in enums are not yet supported, so this cannot be verified by Prusti
</span><span class="boring">        if let Some(node) = &amp;mut self.head {
</span><span class="boring">            &amp;mut node.elem
</span><span class="boring">        } else {
</span><span class="boring">            unreachable!()
</span><span class="boring">        }
</span><span class="boring">        // ...
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl List&lt;i32&gt; {
    predicate!{
        fn is_valid(&amp;self) -&gt; bool {
            forall(|i: usize| i &lt; self.len()
                ==&gt; *self.lookup(i) &gt;= 0 &amp;&amp; *self.lookup(i) &lt; 16)
        }
    }
    // ==&gt; { let value = *self.lookup(i);
    //     0 &lt;= value &amp;&amp; value &lt; 16 })

    #[trusted] // required due to unsupported reference in enum
    #[requires(!self.is_empty())]
    #[requires(self.is_valid())]
    #[ensures(snap(result) === old(snap(self.peek())))]
    #[assert_on_expiry(
        0 &lt;= *result &amp;&amp; *result &lt; 16,
        self.is_valid()
        &amp;&amp; old(self.len()) === self.len() // (1.)
        &amp;&amp; forall(|i: usize| 1 &lt;= i &amp;&amp; i &lt; self.len() // (2.)
            ==&gt; old(snap(self.lookup(i))) === snap(self.lookup(i)))
        &amp;&amp; snap(self.peek()) === before_expiry(snap(result)) // (3.)
    )]
    pub fn peek_mut_16(&amp;mut self) -&gt; &amp;mut i32 {
        if let Some(node) = &amp;mut self.head {
            &amp;mut node.elem
        } else {
            unreachable!()
        }
    }
}
<span class="boring">
</span><span class="boring">fn _test_assert_on_expiry() {
</span><span class="boring">    let mut list = List::new();
</span><span class="boring">    list.push(2);
</span><span class="boring">    list.push(1);
</span><span class="boring">    list.push(0);
</span><span class="boring">    {
</span><span class="boring">        let first = list.peek_mut_16();
</span><span class="boring">        // *first = 16; // This gives an error: [Prusti: verification error] obligation might not hold on borrow expiry
</span><span class="boring">        *first = 15;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2);
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // slot 0 is now `5`
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // slot 1 is unchanged
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The syntax here is <code>#[assert_on_expiry(condition, pledge)]</code>.
This means that <code>condition</code> is checked at the caller side <em>before</em> (or "when") the reference expires, and <code>pledge</code> must hold <em>after</em> the reference expires.</p>
<p>Note that for any assertion <code>A</code>, <code>after_expiry(A)</code> is equivalent to <code>assert_on_expiry(true, A)</code>.</p>
<h2 id="full-code"><a class="header" href="#full-code">Full Code</a></h2>
<pre><code class="language-rust noplaypen">// Expand to see full code up to this chapter
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self))) &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() {
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[trusted] // required due to unsupported reference in enum
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(snap(result) === old(snap(self.peek())))]
</span><span class="boring">    #[after_expiry(
</span><span class="boring">        old(self.len()) === self.len() // (1. condition)
</span><span class="boring">        &amp;&amp; forall(|i: usize| 1 &lt;= i &amp;&amp; i &lt; self.len() // (2. condition)
</span><span class="boring">            ==&gt; old(snap(self.lookup(i))) === snap(self.lookup(i)))
</span><span class="boring">        &amp;&amp; snap(self.peek()) === before_expiry(snap(result)) // (3. condition)
</span><span class="boring">    )]
</span><span class="boring">    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
</span><span class="boring">        // This does not work in Prusti at the moment:
</span><span class="boring">        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
</span><span class="boring">        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
</span><span class="boring">        // this then gets matched to "Some(node: &amp;mut T)"
</span><span class="boring">        // References in enums are not yet supported, so this cannot be verified by Prusti
</span><span class="boring">        if let Some(node) = &amp;mut self.head {
</span><span class="boring">            &amp;mut node.elem
</span><span class="boring">        } else {
</span><span class="boring">            unreachable!()
</span><span class="boring">        }
</span><span class="boring">        // ...
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2);
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // slot 0 is now `5`
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // slot 1 is unchanged
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-code"><a class="header" href="#final-code">Final Code</a></h1>
<p>Here you can see the full implementation we have thus far.</p>
<pre><code class="language-rust noplaypen">// Expand to see the full code
<span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">pub struct List&lt;T&gt; {
</span><span class="boring">    head: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;
</span><span class="boring">
</span><span class="boring">struct Node&lt;T&gt; {
</span><span class="boring">    elem: T,
</span><span class="boring">    next: Link&lt;T&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[extern_spec(std::mem)]
</span><span class="boring">#[ensures(snap(dest) === src)]
</span><span class="boring">#[ensures(result === old(snap(dest)))]
</span><span class="boring">fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T;
</span><span class="boring">
</span><span class="boring">// Specs for std::option::Option&lt;T&gt;::unwrap(self) (and others) can be found here (work in progress):
</span><span class="boring">// https://github.com/viperproject/prusti-dev/pull/1249/files#diff-bccda07f8a48357687e26408251041072c7470c188092fb58439de39974bdab5R47-R49
</span><span class="boring">
</span><span class="boring">#[extern_spec]
</span><span class="boring">impl&lt;T&gt; std::option::Option&lt;T&gt; {
</span><span class="boring">    #[requires(self.is_some())]
</span><span class="boring">    #[ensures(old(self) === Some(result))]
</span><span class="boring">    pub fn unwrap(self) -&gt; T;
</span><span class="boring">    
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, None))]
</span><span class="boring">    pub const fn is_none(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[ensures(result == matches!(self, Some(_)))]
</span><span class="boring">    pub const fn is_some(&amp;self) -&gt; bool;
</span><span class="boring">
</span><span class="boring">    #[ensures(result === old(snap(self)))]
</span><span class="boring">    #[ensures(self.is_none())]
</span><span class="boring">    pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;;
</span><span class="boring">}
</span><span class="boring">impl&lt;T&gt; List&lt;T&gt; {
</span><span class="boring">    #[pure]
</span><span class="boring">    pub fn len(&amp;self) -&gt; usize {
</span><span class="boring">        link_len(&amp;self.head)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    fn is_empty(&amp;self) -&gt; bool {
</span><span class="boring">        matches!(self.head, None)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(result.len() == 0)]
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        List { head: None }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(index &lt; self.len())]
</span><span class="boring">    pub fn lookup(&amp;self, index: usize) -&gt; &amp;T {
</span><span class="boring">        link_lookup(&amp;self.head, index)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(self.len() == old(self.len()) + 1)]
</span><span class="boring">    #[ensures(snap(self.lookup(0)) === elem)]
</span><span class="boring">    #[ensures(forall(|i: usize| (i &lt; old(self.len())) ==&gt;
</span><span class="boring">                 old(self.lookup(i)) === self.lookup(i + 1)))]
</span><span class="boring">    pub fn push(&amp;mut self, elem: T) {
</span><span class="boring">        let new_node = Box::new(Node {
</span><span class="boring">            elem,
</span><span class="boring">            next: self.head.take(),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        self.head = Some(new_node);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    predicate! {
</span><span class="boring">        // two-state predicate to check if the head of a list was correctly removed
</span><span class="boring">        fn head_removed(&amp;self, prev: &amp;Self) -&gt; bool {
</span><span class="boring">            self.len() == prev.len() - 1 // The length will decrease by 1
</span><span class="boring">            &amp;&amp; forall(|i: usize| // Every element will be shifted forwards by one
</span><span class="boring">                (1 &lt;= i &amp;&amp; i &lt; prev.len())
</span><span class="boring">                    ==&gt; prev.lookup(i) === self.lookup(i - 1))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[ensures(old(self.is_empty()) ==&gt;
</span><span class="boring">        result.is_none() &amp;&amp;
</span><span class="boring">        self.is_empty()
</span><span class="boring">    )]
</span><span class="boring">    #[ensures(!old(self.is_empty()) ==&gt;
</span><span class="boring">        self.head_removed(&amp;old(snap(self))) &amp;&amp;
</span><span class="boring">        result === Some(snap(old(snap(self)).lookup(0)))
</span><span class="boring">    )]
</span><span class="boring">    pub fn try_pop(&amp;mut self) -&gt; Option&lt;T&gt; {
</span><span class="boring">        match self.head.take() {
</span><span class="boring">            None =&gt; None,
</span><span class="boring">            Some(node) =&gt; {
</span><span class="boring">                self.head = node.next;
</span><span class="boring">                Some(node.elem)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(self.head_removed(&amp;old(snap(self))))]
</span><span class="boring">    #[ensures(result === old(snap(self)).lookup(0))]
</span><span class="boring">    pub fn pop(&amp;mut self) -&gt; T {
</span><span class="boring">        self.try_pop().unwrap()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // // Not currently possible in Prusti
</span><span class="boring">    // pub fn try_peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
</span><span class="boring">    //     todo!()
</span><span class="boring">    // }
</span><span class="boring">
</span><span class="boring">    #[pure]
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    pub fn peek(&amp;self) -&gt; &amp;T {
</span><span class="boring">        self.lookup(0)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[trusted] // required due to unsupported reference in enum
</span><span class="boring">    #[requires(!self.is_empty())]
</span><span class="boring">    #[ensures(snap(result) === old(snap(self.peek())))]
</span><span class="boring">    #[after_expiry(
</span><span class="boring">        old(self.len()) === self.len() // (1. condition)
</span><span class="boring">        &amp;&amp; forall(|i: usize| 1 &lt;= i &amp;&amp; i &lt; self.len() // (2. condition)
</span><span class="boring">            ==&gt; old(snap(self.lookup(i))) === snap(self.lookup(i)))
</span><span class="boring">        &amp;&amp; snap(self.peek()) === before_expiry(snap(result)) // (3. condition)
</span><span class="boring">    )]
</span><span class="boring">    pub fn peek_mut(&amp;mut self) -&gt; &amp;mut T {
</span><span class="boring">        // This does not work in Prusti at the moment:
</span><span class="boring">        // "&amp;mut self.head" has type "&amp;mut Option&lt;T&gt;"
</span><span class="boring">        // this gets auto-dereferenced by Rust into type: "Option&lt;&amp;mut T&gt;"
</span><span class="boring">        // this then gets matched to "Some(node: &amp;mut T)"
</span><span class="boring">        // References in enums are not yet supported, so this cannot be verified by Prusti
</span><span class="boring">        if let Some(node) = &amp;mut self.head {
</span><span class="boring">            &amp;mut node.elem
</span><span class="boring">        } else {
</span><span class="boring">            unreachable!()
</span><span class="boring">        }
</span><span class="boring">        // ...
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">#[requires(index &lt; link_len(link))]
</span><span class="boring">fn link_lookup&lt;T&gt;(link: &amp;Link&lt;T&gt;, index: usize) -&gt; &amp;T {
</span><span class="boring">    match link {
</span><span class="boring">        Some(node) =&gt; {
</span><span class="boring">            if index == 0 {
</span><span class="boring">                &amp;node.elem
</span><span class="boring">            } else {
</span><span class="boring">                link_lookup(&amp;node.next, index - 1)
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        None =&gt; unreachable!(),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[pure]
</span><span class="boring">fn link_len&lt;T&gt;(link: &amp;Link&lt;T&gt;) -&gt; usize {
</span><span class="boring">    match link {
</span><span class="boring">        None =&gt; 0,
</span><span class="boring">        Some(node) =&gt; 1 + link_len(&amp;node.next),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(prusti)]
</span><span class="boring">mod prusti_tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    fn _test_list(){
</span><span class="boring">        let mut list = List::new(); // create an new, empty list
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // list should be empty
</span><span class="boring">
</span><span class="boring">        list.push(5);
</span><span class="boring">        list.push(10);
</span><span class="boring">        prusti_assert!(!list.is_empty() &amp;&amp; list.len() == 2); // length correct
</span><span class="boring">
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 10); // head is 10
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 5); // 5 got pushed back correctly
</span><span class="boring">
</span><span class="boring">        let x = list.pop();
</span><span class="boring">        prusti_assert!(x == 10); // pop returns the value that was added last
</span><span class="boring">
</span><span class="boring">        match list.try_pop() {
</span><span class="boring">            Some(y) =&gt; assert!(y == 5),
</span><span class="boring">            None =&gt; unreachable!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let z = list.try_pop();
</span><span class="boring">        prusti_assert!(list.is_empty() &amp;&amp; list.len() == 0); // length correct
</span><span class="boring">        prusti_assert!(z.is_none()); // `try_pop` on an empty list should return `None`
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(16);
</span><span class="boring">        prusti_assert!(list.peek() === list.lookup(0));
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">        
</span><span class="boring">        list.push(5);
</span><span class="boring">        prusti_assert!(*list.peek() == 5);
</span><span class="boring">
</span><span class="boring">        list.pop();
</span><span class="boring">        prusti_assert!(*list.peek() == 16);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn _test_peek_mut() {
</span><span class="boring">        let mut list = List::new();
</span><span class="boring">        list.push(8);
</span><span class="boring">        list.push(16);
</span><span class="boring">
</span><span class="boring">        // Open a new scope using an opening bracket `{`
</span><span class="boring">        // `first` will get dropped at the closing bracket `}`
</span><span class="boring">        {
</span><span class="boring">            let first = list.peek_mut();
</span><span class="boring">            // `first` is a mutable reference to the first element of the list
</span><span class="boring">            // for as long as `first` is exists, `list` cannot be accessed
</span><span class="boring">            prusti_assert!(*first == 16);
</span><span class="boring">            *first = 5; // Write 5 to the first slot of the list
</span><span class="boring">            prusti_assert!(*first == 5);
</span><span class="boring">            // `first` gets dropped here, `list` can be accessed again
</span><span class="boring">        }
</span><span class="boring">        prusti_assert!(list.len() == 2);
</span><span class="boring">        prusti_assert!(*list.lookup(0) == 5); // slot 0 is now `5`
</span><span class="boring">        prusti_assert!(*list.lookup(1) == 8); // slot 1 is unchanged
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-invariants"><a class="header" href="#loop-invariants">Loop Invariants</a></h1>
<p>To show how to verify loops, we will use a different example than our linked list for simplicity.
We will write and verify a function that can add some value to every element of an array slice.</p>
<p>Let's write a function that takes an integer <code>x</code> and sums up all values from 0 to that value in a loop.
For non-negative inputs, the result will be equal to <code>x * (x + 1) / 2</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[requires(x &gt;= 0)]
#[ensures(result == x * (x + 1) / 2)] //~ ERROR postcondition might not hold
fn summation(x: i32) -&gt; i32 {
    let mut i = 1;
    let mut sum = 0;
    while i &lt;= x {
        sum += i;
        i += 1;
    }
    sum
}
// Prusti: fails</code></pre>
<p>We cannot verify this code yet, because Prusti does not know what the <code>while</code> loop does to <code>sum</code> and <code>i</code>. For that, we need to add a <a href="tour/../verify/loop.html"><code>body_invariant</code></a>. Body invariants are expressions that always hold at the beginning and end of the loop body. In our case, the invariant is that <code>sum</code> contains the sum of all values between 1 and <code>i</code>. Since <code>i</code> starts at 1 and not at 0, we have to slightly adjust the formula by using <code>i - 1</code> instead of <code>i</code>, so we get: <code>sum == (i - 1) * i / 2</code>.</p>
<p>After adding the <code>body_invariant</code>, we get this code:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[requires(x &gt;= 0)]
#[ensures(result == x * (x + 1) / 2)]
fn summation(x: i32) -&gt; i32 {
    let mut i = 1;
    let mut sum = 0;
    while i &lt;= x {
        body_invariant!(sum == (i - 1) * i / 2);
        sum += i;
        i += 1;
    }
    sum
}
// Prusti: verifies</code></pre>
<p>This body invariant is enough to verify the postcondition. After the loop, <code>i == x + 1</code> will hold. Plugging this into our <code>body_invariant!(sum == (i - 1) * i / 2)</code>, we get <code>sum == x * (x + 1) / 2</code>, which is our postcondition.</p>
<p>Note that we did not have to add <code>body_invariant!(1 &lt;= i &amp;&amp; i &lt;= x)</code>. In some cases, such as when the loop condition is side-effect free, Prusti adds the loop condition to the body invariant, as long as at least one <code>body_invariant</code> is syntactically present in the loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counterexamples"><a class="header" href="#counterexamples">Counterexamples</a></h1>
<p>Let's take the summation function from the <a href="tour/loop_invariants.html">Loop invariants</a> chapter, which adds up all the numbers from 1 to <code>x</code>. Let's suppose we forgot to add the non-negativity postcondition for <code>x</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// Note: counterexample = true
</span><span class="boring">
</span>// #[requires(x &gt;= 0)] // Forgot to add this condition
#[ensures(result == x * (x + 1) / 2)] //~ ERROR postcondition might not hold
fn summation(x: i32) -&gt; i32 {
    let mut i = 1;
    let mut sum = 0;
    while i &lt;= x {
        body_invariant!(sum == (i - 1) * i / 2);
        sum += i;
        i += 1;
    }
    sum
}</code></pre>
<p>Attempting to verify this file will result in an error:</p>
<pre><code class="language-plain">[Prusti: verification error] postcondition might not hold.
</code></pre>
<p>One way to help with debugging such a verification failure, is to have Prusti print a <strong>counterexample</strong>. This can be enabled by adding the <code>counterexample = true</code> flag in the <code>Prusti.toml</code> file.</p>
<p>A counterexample is any combination of values, which will cause some postcondition or assertion to fail (there are no guarantees on which values get chosen).</p>
<p>After running Prusti again with the new setting, we will get an error message like this one:</p>
<pre><code class="language-plain">[Prusti: verification error] postcondition might not hold.
    final_code.rs(12, 1): the error originates here
    final_code.rs(12, 14): counterexample for "x"
        initial value: ?
        final value: -2
    final_code.rs(13, 9): counterexample for "i"
        final value: 1
    final_code.rs(14, 9): counterexample for "sum"
        final value: 0
    final_code.rs(12, 25): counterexample for result
        final value: 0
</code></pre>
<p>Here we can see that the postcondition does not hold for <code>x == -2</code>, which will result in final values of <code>i == 1</code>, <code>sum == 0</code> and <code>result == 0</code>. This should help with finding wrong specifications or bugs in the code, which in this case is allowing negative numbers as an input.</p>
<p>Note that verification with <code>counterexample = true</code> is slower than normal verification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-features"><a class="header" href="#verification-features">Verification Features</a></h1>
<p>Even if no specifications are provided, Prusti is capable of verifying a few basic properties about the supplied Rust code.
These properties include:</p>
<ul>
<li><a href="verify/panic.html">Absence of panics</a></li>
<li><a href="verify/overflow.html">Overflow checks</a></li>
</ul>
<p>More intricate properties require users to write suitable <a href="verify/../syntax.html">specifications</a>.
The following features are either currently supported or planned to be supported in Prusti:</p>
<ul>
<li><a href="verify/prepost.html">Pre- and postconditions</a></li>
<li><a href="verify/assert_refute_assume.html">Assertions, refutations and assumptions</a></li>
<li><a href="verify/trusted.html">Trusted functions</a></li>
<li><a href="verify/pure.html">Pure functions</a></li>
<li><a href="verify/predicate.html">Predicates</a></li>
<li><a href="verify/external.html">External specifications</a></li>
<li><a href="verify/loop.html">Loop body invariants</a></li>
<li><a href="verify/pledge.html">Pledges</a></li>
<li><a href="verify/type_cond_spec.html">Type-conditional spec refinements</a></li>
<li><a href="verify/closure.html">Closures</a></li>
<li><a href="verify/spec_ent.html">Specification entailments</a></li>
<li><a href="verify/type-models.html">Type models</a></li>
<li><a href="verify/prusti-feature.html">Conditional compilation</a></li>
</ul>
<p>By default, Prusti only checks absence of panics.
Moreover, Prusti verifies <em>partial</em> correctness. That is, it only verifies that <em>terminating</em> program executions meet the supplied specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="absence-of-panics"><a class="header" href="#absence-of-panics">Absence of panics</a></h1>
<p>With the default settings, Prusti checks absence of panics. For example, consider the following program which always panics when executed:</p>
<pre><code class="language-rust noplaypen ignore">pub fn main() {
    unreachable!();
}</code></pre>
<p>When run on the previous program, Prusti reports a verification error:</p>
<pre><code class="language-plain">error[P0004]: unreachable!(..) statement might be reachable
 --&gt; src/lib.rs:2:5
  |
2 |     unreachable!();
  |     ^^^^^^^^^^^^^^^
  |
</code></pre>
<p>This message correctly points out that the <code>unreachable!()</code> statement might actually be reachable.</p>
<p>The message says "might" because Prusti is conservative, i.e., it reports a verification error <em>unless</em> it can prove that the statement is unreachable.
Hence, Prusti successfully verified the example below as it can rule out that the condition in the conditional statement, <code>a &lt;= 0</code>, holds.</p>
<pre><code class="language-rust noplaypen ignore">pub fn main() {
    let a = 5;
    if a &lt;= 0 {
        unreachable!();
    }
}</code></pre>
<p>Since Prusti is conservative, if it reports no verification errors then the program is provably correct <em>with regard to the checked properties.</em>
The last part is important because checks such as <a href="verify/overflow.html">overflow checks</a> may be disabled.
Furthermore, Prusti may verify a program although some (or even all) of its executions do not terminate because it verifies partial correctness properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow-checks-1"><a class="header" href="#overflow-checks-1">Overflow checks</a></h1>
<p>Overflow checks are enabled by default.</p>
<p>When overflow checks are enabled, Prusti models integers as bounded values with a range that depends on the type of the integer. Values of <code>u32</code> types, for example, would be modeled to be between <code>0</code> and <code>2^32 - 1</code>.</p>
<p>When overflow checks are disabled, Prusti models signed integers as unbounded integers.</p>
<p>Overflow checks can be disabled by setting the <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#check_overflows"><code>check_overflows</code></a> flag to <code>false</code>. See <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/providing.html">Providing Flags</a> in the developer guide for details.</p>
<p>By default, unsigned integers are modeled as being non-negative (<code>0 &lt;= i</code>), even with overflow checks disabled. They can also be modeled as unbounded integers by setting the <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#encode_unsigned_num_constraint"><code>encode_unsigned_num_constraint</code></a> flag to <code>false</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre--and-postconditions"><a class="header" href="#pre--and-postconditions">Pre- and postconditions</a></h1>
<p>In Prusti, the externally observable behaviour of a function can be specified with preconditions and postconditions. They can be provided using <a href="https://doc.rust-lang.org/reference/attributes.html">Rust attributes</a>:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[requires(...)]
#[ensures(...)]
fn example() { ... }</code></pre>
<p><code>#[requires(...)]</code> is a precondition, <code>#[ensures(...)]</code> is a postcondition. There can be any number (including none) of preconditions and postconditions attached to a function. When no precondition is specified, <code>#[requires(true)]</code> is assumed, and likewise for postconditions. The expression inside the parentheses of <code>requires</code> or <code>ensures</code> should be a <a href="verify/../syntax.html">Prusti specification</a>.</p>
<p>Preconditions are checked whenever the given function is called. Postconditions are checked at any exit point of the function, i.e. explicit <code>return</code> statements, as well as the end of the function body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions-refutations-and-assumptions"><a class="header" href="#assertions-refutations-and-assumptions">Assertions, Refutations and Assumptions</a></h1>
<p>You can use Prusti to verify that a certain property holds at a certain point
within the body of a function (via an assertion). It is also possible to
instruct Prusti to assume that a property holds at a certain point within a
function (via an assumption).</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>The macros <code>prusti_assert!</code>, <code>prusti_assert_eq!</code> and <code>prusti_assert_ne!</code> instruct Prusti to verify that a certain property holds at a specific point within the body of a function. In contrast to the <code>assert!</code>, <code>assert_eq!</code> and <code>assert_ne!</code> macros, which only accept Rust expressions, the Prusti variants accept <a href="verify/../syntax.html">specification</a> expressions as arguments. Therefore, <a href="verify/../syntax.html#quantifiers">quantifiers</a>, <a href="verify/../syntax.html#old-expressions"><code>old</code></a> expressions and other Prusti specification syntax is allowed within a call to <code>prusti_assert!</code>, as in the following example:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[requires(*x != 2)]
fn go(x: &amp;mut u32) {
   *x = 2;
   prusti_assert!(*x != old(*x));
}</code></pre>
<p>The two macros <code>prusti_assert_eq!</code> and <code>prusti_assert_ne!</code> are also slightly different than their standard counterparts, in that they use <a href="verify/../syntax.html#snapshot-equality">snapshot equality</a> <code>===</code> instead of <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">Partial Equality</a> <code>==</code>.</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[requires(a === b)]
fn equal(a: u64, b: u64) {
    // these 2 lines do the same:
    prusti_assert!(a === b);
    prusti_assert_eq!(a, b);
}

#[requires(a !== b)]
fn different(a: u64, b: u64) {
    // these 2 lines do the same:
    prusti_assert!(a !== b);
    prusti_assert_ne!(a, b);
}</code></pre>
<p>Note that the expression given to <code>prusti_assert!</code> must be side-effect free, since they will not result in any runtime code. Therefore, using code containing <a href="verify/../verify/pure.html">impure</a> functions will work in an <code>assert!</code>, but not within a <code>prusti_assert!</code>. For example:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span><span class="boring">fn test(map: std::collections::HashMap) {
</span>assert!(map.insert(5));
prusti_assert!(map.insert(5)); // error
<span class="boring">}</span></code></pre>
<p>Using Prusti assertions instead of normal assertions can speed up verification, because every <code>assert!</code> results in a branch in the code, while <code>prusti_assert!</code> does not.</p>
<h2 id="refutations"><a class="header" href="#refutations">Refutations</a></h2>
<blockquote>
<p>Refutation <strong>should not be relied upon for soundness</strong> as they may succeed even when expected to fail; Prusti may not be able to prove the property being refuted and thus won't complain even though the property actually holds (e.g. if the property is difficult to prove).</p>
</blockquote>
<p>The <code>prusti_refute!</code> macro is similar to <code>prusti_assert!</code> in its format, conditions of use and what expressions it accepts. It instructs Prusti to verify that a certain property at a specific point within the body of a function might hold in some, but not all cases. For example the following code will verify:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(val &lt; 0 ==&gt; result == -1)]
#[ensures(val == 0 ==&gt; result == 0)]
#[ensures(val &gt; 0 ==&gt; result == 1)]
fn sign(val: i32) -&gt; i32 {
  prusti_refute!(val &lt;= 0);
  prusti_refute!(val &gt;= 0);
  if val &lt; 0 {
    -1
  } else if val &gt; 0 {
    1
  } else {
    prusti_refute!(false);
    0
  }
}</code></pre>
<p>But the following function would not:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[requires(val &lt; 0 &amp;&amp; val &gt; 0)]
#[ensures(result == val/2)]
fn half(val: i32) -&gt; i32 {
  prusti_refute!(false);
  val/2
}</code></pre>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The <code>prusti_assume!</code> macro instructs Prusti to assume that a certain property
holds at a point within the body of a function. Of course, if used improperly,
this can be used to introduce unsoundness. For example, Prusti would verify the
following function:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">// The next line is only required for doctests, you can ignore/remove it
</span><span class="boring">extern crate prusti_contracts;
</span><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(p == np)]
fn proof(p: u32, np: u32) {
    prusti_assume!(false);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-functions-1"><a class="header" href="#trusted-functions-1">Trusted functions</a></h1>
<p>Sometimes specifications express a fact which is true about a function, but the verifier cannot prove it automatically, or it uses features not yet supported by Prusti. In such cases, it is possible to mark a function as <code>#[trusted]</code>:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[trusted]
#[ensures(*a == old(*b) &amp;&amp; *b == old(*a))]
fn xor_swap(a: &amp;mut i32, b: &amp;mut i32) {
    *a ^= *b;
    *b ^= *a;
    *a ^= *b;
}</code></pre>
<p>In the above example, the contract for <code>xor_swap</code> is correct, but Prusti would not be able to verify it because it uses currently unsupported XOR operations.</p>
<p>While a common application of <code>#[trusted]</code> is to wrap functions from the standard library or external libraries, note that <a href="verify/external.html">external specifications</a> provide a more robust solution for this use case.</p>
<h2 id="why-trusted-functions-are-dangerous"><a class="header" href="#why-trusted-functions-are-dangerous">Why trusted functions are dangerous</a></h2>
<p>When declaring a function as <code>#[trusted]</code>, Prusti ignores the function's body and assumes the provided pre- and postconditions have already been successfully verified.
As the example below demonstrates, a single wrong, yet trusted, specification may lead to wrong and unexpected verification results.
Hence, some care is needed to ensure that the specifications of trusted functions are indeed correct.</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[trusted]
#[ensures(42 == 23)] // assumed correct since we trust foo()
fn foo() { unreachable!() }

fn test() {
    foo();
    assert!(1 == 2); // verifies successfully
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pure-functions"><a class="header" href="#pure-functions">Pure functions</a></h1>
<p>Pure functions are functions which are deterministic and side-effect free. In Prusti, such functions can be marked with the <code>#[pure]</code> attribute. They can take shared references as arguments, but they cannot take mutable references, because modifying the heap is considered a side effect.</p>
<p>At the moment, it is up to the user to ensure that functions annotated with <code>#[pure]</code> always terminate. Non-terminating pure functions would allow to infer <code>false</code>.</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[pure]
#[ensures(result == *a + *b)]
fn pure_example(a: &amp;i32, b: &amp;i32) -&gt; i32 {
  *a + *b
}

#[ensures(*c == a + b)]
fn impure_example(a: &amp;i32, b: &amp;i32, c: &amp;mut i32) {
  *c = *a + *b
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates"><a class="header" href="#predicates">Predicates</a></h1>
<p>Predicates are similar to <a href="verify/pure.html">pure functions</a> in that they are deterministic and side-effect free and used in specifications.</p>
<p>They are more powerful than pure functions: inside predicate bodies the full <a href="verify/../syntax.html">Prusti specification syntax</a> is allowed. However, they are not usable in regular Rust code, as there are no direct Rust equivalents for specification constructs like <a href="verify/../syntax.html#quantifiers">quantifiers</a> or <a href="verify/../syntax.html#implications">implications</a>. Instead, predicates can only be called from within specifications and other predicates.</p>
<p>Predicates are declared using the <code>predicate!</code> macro on a function:</p>
<pre><code class="language-rust noplaypen ignore">predicate! {
    fn all_zeroes(a: &amp;MyArray) -&gt; bool {
        forall(|i: usize|
            (0 &lt;= i &amp;&amp; i &lt; a.len() ==&gt; a.lookup(i) == 0))
    }
}</code></pre>
<p>Within specifications, predicates can be called just like pure functions:</p>
<pre><code class="language-rust noplaypen ignore">#[ensures(all_zeros(a))]
fn zero(a: &amp;mut MyArray) { ... }</code></pre>
<p>The <code>predicate!</code> macro is incompatible with other Prusti specifications, i.e. a predicate function cannot have pre- or postconditions. The body of a predicate must be provided, so it cannot be <a href="verify/trusted.html"><code>#[trusted]</code></a>. Predicates are always considered pure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-specifications"><a class="header" href="#external-specifications">External specifications</a></h1>
<p>Since the Rust standard library and external libraries do not specify contracts for their functions, Prusti allows specifying the contract for functions separately from where they are implemented. Such a specification looks like a regular <code>impl</code>, with the exception that there are no bodies in the implementation functions, and that the <code>impl</code> has an <code>#[extern_spec]</code> attribute.</p>
<p>The standard library type <code>std::option::Option</code> could be specified as follows:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[extern_spec]
impl&lt;T&gt; std::option::Option&lt;T&gt; {
    #[pure]
    #[ensures(matches!(*self, Some(_)) == result)]
    pub fn is_some(&amp;self) -&gt; bool;

    #[pure]
    #[ensures(self.is_some() == !result)]
    pub fn is_none(&amp;self) -&gt; bool;

    #[requires(self.is_some())]
    pub fn unwrap(self) -&gt; T;

    // ...
}</code></pre>
<p>Any function in an external specification is implicitly <a href="verify/trusted.html">trusted</a> (as if marked with <code>#[trusted]</code>). It is possible to specify multiple <code>#[extern_spec]</code> implementations for the same type, but it is an error to externally specify the same function multiple times.</p>
<p>The <code>extern_spec</code> attribute accepts an optional argument to provide the module path to the function being specified. For example, to specify <code>std::mem::swap</code>, the argument is <code>std::mem</code>:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[extern_spec(std::mem)]
#[ensures(*a === old(snap(b)) &amp;&amp; *b === old(snap(a)))]
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-body-invariants"><a class="header" href="#loop-body-invariants">Loop body invariants</a></h1>
<p>To verify loops, including loops in which the loop condition has side effects, Prusti allows specifying the <em>invariant of the loop body</em> using the <code>body_invariant!(...);</code> statement. The expression inside the parentheses should be a <a href="verify/../syntax.html">Prusti specification</a>. There may be any number of body invariants in any given loop, but they must all be written next to each other.</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th></tr></thead><tbody>
<tr><td>Loop conditions without side-effects</td><td>Supported</td></tr>
<tr><td>Loop conditions with side-effects</td><td>Supported</td></tr>
<tr><td>Loops with <code>break</code>, <code>continue</code>, or <code>return</code> statements</td><td>Supported</td></tr>
<tr><td>Loans that cross a loop boundary (e.g. loans defined outside the loop, expiring in the loop)</td><td>Not supported yet</td></tr>
</tbody></table>
</div>
<p>In general, given the loop:</p>
<pre><code class="language-rust noplaypen ignore">while {
  G; // possibly side-effectful
  g // loop condition
} {
  body_invariant!(I); // loop body invariant
  B // loop body
}</code></pre>
<p>Prusti checks the following:</p>
<ol>
<li>The first time that <code>G</code> has been executed, if <code>g</code> evaluates to <code>true</code> then the property <code>I</code> must hold.</li>
<li>Assuming that the property <code>I</code> holds, after executing <code>B; G</code>, if <code>g</code> evaluates to <code>true</code> then <code>I</code> must hold (again).</li>
</ol>
<p>After the loop, Prusti knows that the program is in a state in which the loop condition evaluated to <code>false</code>. This can happen for two reasons:</p>
<ol>
<li>The loop body has never been executed, because the first evaluation of the loop condition resulted in <code>false</code>. In this case, the invariant in the loop body is never reached.</li>
<li>The loop executed at least one iteration, then after executing <code>B</code> the evaluation of <code>{ G; g }</code> resulted in <code>false</code>.</li>
</ol>
<p>Finally, the loop body invariant is not enforced when exiting from a loop with a <code>break</code> or <code>return</code> statement.</p>
<p>As an example, consider the following program. The loop condition calls <code>test_and_increment</code>, and the call has side effects:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[ensures(result == (old(*i) &gt;= 0))]
#[ensures(*i == 1 + old(*i))]
fn test_and_increment(i: &amp;mut usize) -&gt; bool {
    let old_i = *i;
    *i += 1;
    old_i &gt;= 0
}

#[requires(*i &gt; 0)]
fn work(i: &amp;mut usize) {
    // ...
}

fn main() {
    let mut i = 0;

    while test_and_increment(&amp;mut i) {
        body_invariant!(i &gt; 0);
        work(i);
    }

    assert!(i &lt;= 0);
}</code></pre>
<p>We can assert <code>i &lt;= 0</code> after the loop, because in the last evaluation of the loop condition <code>i &gt;= 0</code> was <code>false</code>, and <code>i</code> was then incremented by one.</p>
<p>Note that it would be wrong to assert <code>i &lt; 0</code> after the loop, because it is possible to have <code>i == 0</code>. Note also that the loop body invariant <code>i &gt;= 0</code> is not strong enough to verify the program, since <code>work</code> requires <code>i &gt; 0</code>. In fact, after <code>test_and_increment</code> returns <code>true</code>, <code>i</code> cannot be <code>0</code> because of the <code>+= 1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pledges-1"><a class="header" href="#pledges-1">Pledges</a></h1>
<p>Pledges are a construct that can be used to specify the behaviour of functions that reborrow. For example, pledges should be used for modelling an assignment to a vector element because, in Rust, <code>v[i] = 4</code> is not a method call <code>v.store(i, 4)</code> but rather <code>let tmp = v.get_mut(i); *tmp = 4</code>, where <code>get_mut</code> is a method that reborrows the <code>v</code> receiver to return a reference to a particular element.</p>
<p>As a full example, a wrapper around Rust <code>Vec&lt;i32&gt;</code> could be implemented as follows:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

pub struct VecWrapperI32 {
    v: Vec&lt;i32&gt;
}

impl VecWrapperI32 {
    #[trusted]
    #[pure]
    #[ensures(result &gt;= 0)]
    pub fn len(&amp;self) -&gt; usize {
        self.v.len()
    }

    /// A ghost function for specifying values stored in the vector.
    #[trusted]
    #[pure]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    pub fn lookup(&amp;self, index: usize) -&gt; i32 {
        self.v[index]
    }

    #[trusted]
    #[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
    #[ensures(*result == old(self.lookup(index)))]
    #[after_expiry(
        self.len() == old(self.len()) &amp;&amp;
        self.lookup(index) == before_expiry(*result) &amp;&amp;
        forall(
            |i: usize| (0 &lt;= i &amp;&amp; i &lt; self.len() &amp;&amp; i != index) ==&gt;
            self.lookup(i) == old(self.lookup(i))
        )
    )]
    pub fn index_mut(&amp;mut self, index: usize) -&gt; &amp;mut i32 {
        self.v.get_mut(index).unwrap()
    }
}</code></pre>
<p>The syntax for a pledge is <code>#[after_expiry(reference =&gt; condition)]</code> where
<code>reference</code> is the reborrowing reference (defaults to <code>result</code>, which is
currently the only thing one can write until we have support for
reference fields) and <code>condition</code> is a <a href="verify/../syntax.html">Prusti specification</a> that specifies how the borrowed data
structure will look once the borrow expires. To refer in the condition to the state that
a memory location pointed at by the reference has just before expiring,
use <code>before_expiry(*reference)</code>.</p>
<h2 id="run-assertions-when-reference-expires"><a class="header" href="#run-assertions-when-reference-expires">Run assertions when reference expires</a></h2>
<p>In some cases, a condition must be checked at the point of expiry, like for example a type invariant.
The syntax for this is <code>#[assert_on_expiry(condition, invariant)]</code>.
This means that the <code>invariant</code> holds, given that <code>condition</code> is true when the reference expires.</p>
<p>Note that for any assertion <code>A</code>, <code>after_expiry(A)</code> is equivalent to <code>assert_on_expiry(true, A)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conditional-spec-refinement"><a class="header" href="#type-conditional-spec-refinement">Type-Conditional Spec Refinement</a></h1>
<p>When specifying trait methods or generic functions, there is often a special case that allows for more complete specification. In these cases, you can attach a type-conditional spec refinement attribute to the function in question, spelled e.g. <code>#[refine_spec(where T: A + B, U: C, [requires(true), pure])]</code></p>
<p>For example, one could use this to specify a function like <code>core::mem::size_of</code> by defining a trait for types whose size we'd like to specify:</p>
<pre><code class="language-rust noplaypen ignore">#[pure]
#[refine_spec(where T: KnownSize, [
    ensures(result == T::size()),
])]
fn size_of&lt;T&gt;() -&gt; usize;

pub trait KnownSize {
    #[pure]
    fn size() -&gt; usize;
}</code></pre>
<blockquote>
<p>Note that the involved functions are marked as <code>pure</code>, allowing them to be used within specifications. This is another common use case, because functions can only be <code>pure</code> if their parameters and result are <code>Copy</code>, so it is often useful to specify something like <code>#[refine_spec(where T: Copy, [pure])]</code>.</p>
</blockquote>
<p>There are some marker traits which simply modify the behavior of methods in their super-traits. For instance, consider the <code>PartialEq&lt;T&gt;</code> and <code>Eq</code> traits. In order to consider this additional behavior for verification, we can refine the contract of <code>PartialEq::eq</code> when the type is known to be marked <code>Eq</code>:</p>
<pre><code class="language-rust noplaypen ignore">pub trait PartialEq&lt;Rhs: ?Sized = Self&gt; {
    #[refine_spec(where Self: Eq, [
        ensures(self == self), // reflexive
        // we could write more specs here
    ])]
    #[ensures(/* partial equivalence formulas */)]
    fn eq(&amp;self, other: &amp;Rhs) -&gt; bool;
}</code></pre>
<p>Thus, any client implementing <code>Eq</code> on a custom type can take advantage of the additional semantics of the total equivalence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<blockquote>
<p><strong>NOT YET SUPPORTED:</strong> This feature is not yet supported in Prusti. See <a href="https://github.com/viperproject/prusti-dev/pull/138">PR #138</a> for the status of this feature as well as a prototype. The syntax described here is subject to change.</p>
<p><strong>NOTE: The syntax for attaching specifications to closures is currently not working</strong></p>
</blockquote>
<p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Rust closures</a> can be given a specification using the <code>closure!(...)</code> syntax:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

fn main() {
    let cl = closure!(
        requires(a &gt; b),
        ensures(result &gt; b),
        |a: i32, b: i32| -&gt; i32 { a }
    );
}</code></pre>
<p><code>closure!</code> can have any number of pre- and postconditions. The arguments and return type for the closure must be given explicitly. See <a href="verify/spec_ent.html">specification entailments</a> for specifying the contract of a higher-order function (e.g. when taking a closure as an argument).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification-entailments"><a class="header" href="#specification-entailments">Specification entailments</a></h1>
<blockquote>
<p><strong>NOT YET SUPPORTED:</strong> This feature is not yet supported in Prusti. See <a href="https://github.com/viperproject/prusti-dev/pull/138">PR #138</a> for the status of this feature as well as a prototype. The syntax described here is subject to change.</p>
</blockquote>
<p>The contract for a closure or function pointer variable can be given using the specification entailment syntax:</p>
<pre><code class="language-rust noplaypen ignore">use prusti_contracts::*;

#[requires(
  f |= |a: i32, b: i32| [
    requires(a == 5),
    requires(b == 4),
    ensures(result &gt; 4)
  ]
)]
fn example&lt;F: Fn (i32, i32) -&gt; i32&gt; (f: F) { ... }</code></pre>
<p>In the above example, <code>f</code>, the argument to <code>example</code>, must be a function that takes two <code>i32</code> arguments. A call to <code>f</code> inside the body of <code>example</code> is only valid if the preconditions are satisfied, and the result of that call must satisfy the postcondition given.</p>
<blockquote>
<p>TODO:</p>
<ul>
<li>arrow syntax (<code>~~&gt;</code>)</li>
<li>ghost arguments</li>
<li>history invariants</li>
<li>multiple-call specification entailment</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-models"><a class="header" href="#type-models">Type Models</a></h1>
<p>Some structs, mostly non-local structs from other crates, contain non-public code which are essential for verification.
To provide a specification for such structs, you can add model fields to be used in specifications. To introduce a type
model for a struct, simply annotate it with the <code>#[model]</code> macro and declare the to-be-modelled fields inside the
struct:</p>
<pre><code class="language-rust noplaypen ignore">#[model]
struct SomeStruct {
    some_i32: i32,
    // ... more fields
}</code></pre>
<p>You then can use the model of <code>SomeStruct</code> inside specifications via the <code>.model()</code> function:</p>
<pre><code class="language-rust noplaypen ignore">#[requires(some_struct.model().some_i32 == 42)]
fn some_method(some_struct: &amp;SomeStruct) {
    // ...
}</code></pre>
<p>A model cannot be used outside of specification code, that is the following code will emit an error in Prusti and panic
when executed:</p>
<pre><code class="language-rust noplaypen ignore">fn some_client(some_struct: &amp;mut SomeStruct) {
    some_struct.model().some_i32 = 42;
}</code></pre>
<p>This means that a model cannot be instantiated or directly manipulated with runtime code. Instead, the <em>source</em> of a
model is always a <a href="verify/trusted.html">trusted function</a> or an <a href="verify/external.html">external specification</a>.</p>
<h2 id="further-remarks"><a class="header" href="#further-remarks">Further remarks</a></h2>
<ul>
<li>A model needs to be copyable, i.e. all fields need to be <code>Copy</code>. That also applies to type parameters where you need
to add the <code>Copy</code> trait as a bound.</li>
<li>When the modelled type has no fields, a warning will be emmitted. Using <code>.model()</code> on such types can lead to unsound
verification results. See below for an example.</li>
</ul>
<h3 id="modelled-types-should-have-fields"><a class="header" href="#modelled-types-should-have-fields">Modelled types should have fields</a></h3>
<p>Using models on types without fields can have unexpected verification behavior as shown in the code snippet below:</p>
<pre><code class="language-rust noplaypen ignore">struct A;

// no fields
#[model]
struct A {
    val: i32
}

#[trusted]
#[ensures(result.model().val == with_model_val)]
fn create_a(with_model_val: i32) -&gt; A { A {} }

fn main() {
    let a1 = create_a(42);
    let a2 = create_a(43);
    // Can prove: a1.model().val == x for any x
    // Can prove: a2.model().val == x for any x
}</code></pre>
<p>The reason for this is due to the encoding of <code>A</code> in Viper. When encoding the <code>main</code> function, Prusti creates two
snapshots for <code>a1</code> and <code>a2</code>. Since <code>A</code> has no fields, any two snapshots of <code>A</code> will be considered equal and thereafter,
their models too. When inhaling the two postconditions for the call to <code>create_a</code> in <code>main</code> Viper thus assumes that the
field <code>val</code> for the <em>same</em> model is <code>42</code> and <code>43</code>, a contradiction.</p>
<h2 id="example-stditeriter"><a class="header" href="#example-stditeriter">Example: <code>std::iter::Iter</code></a></h2>
<blockquote>
<p><strong>Caution</strong></p>
<p>As of yet, iterators are not fully supported in Prusti.
This example is a draft and is meant as a possible real-world usage of <code>#[model]</code> in the near future.</p>
</blockquote>
<p>An example where a type model comes in handy is the <code>std::slice::Iter</code> struct from the standard library. We would like
to provide a specification for the <code>Iterator</code>:</p>
<pre><code class="language-rust noplaypen ignore">impl&lt;T&gt; Iterator&lt;'a, T&gt; for std::slice::Iter&lt;'a, T&gt; {
    // ??? spec involving Iter ??? 
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}</code></pre>
<p>There is not really a way to provide a specification for this implementation, because <code>Iter</code>'s fields do not allow
a <a href="https://doc.rust-lang.org/src/core/slice/iter.rs.html#65-71">straightforward specification</a>.</p>
<p>We can instead provide a model for <code>Iter</code> in the following way, using the <code>#[model]</code> macro:</p>
<pre><code class="language-rust noplaypen ignore">use std::slice::Iter;

#[model]
struct Iter&lt;'a, #[generic] T: Copy&gt; {
    position: usize,
    len: usize,
    data: GhostSeq&lt;T&gt; // Note: Assuming this is defined somewhere
}</code></pre>
<p>This allows an instance of <code>Iter&lt;'_, T&gt;</code> to be modelled by the fields <code>position</code>, <code>len</code> and <code>data</code>.</p>
<p>The model can then be used in specifications:</p>
<pre><code class="language-rust noplaypen ignore">#[ensures(result.model().position == 0)]
#[ensures(result.model().len == slice.len())]
#[trusted]
fn create_iter&lt;T&gt;(slice: &amp;[T]) -&gt; std::slice::Iter&lt;'_, T&gt; {
    slice.iter()
}

#[extern_spec]
impl&lt;T&gt; Iterator for std::slice::Iter&lt;'a, T&gt; {
    type Item = T;

<span class="boring">    [ensures( self .model().data.len == old( self .model().data.len)) )]
</span>    #[ensures(old(self.model().pos) &lt; self.model().data.len == &gt;
    ( result.is_some() &amp;&amp;
    result.unwrap() == self.model().data.lookup(old(self.model().pos))))
    ]
    // ... more ...
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt;;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-counterexamples"><a class="header" href="#printing-counterexamples">Printing Counterexamples</a></h1>
<p>Prusti can print counterexamples for verification failures, i.e., values for variables that violate some assertion or pre-/postcondition.
This can be enabled by setting <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#counterexample"><code>counterexample = true</code></a> in the <code>Prusti.toml</code> file, or with the <code>PRUSTI_COUNTEREXAMPLES=true</code> environment variable.</p>
<p>For example:</p>
<pre><code class="language-rust noplaypen">fn test_assert(x: i32) {
    assert!(x &gt;= 10);
}</code></pre>
<p>This will result in an error like this one:</p>
<pre><code class="language-plain">[Prusti: verification error] the asserted expression might not hold
assert_counterexample.rs(3, 4): counterexample for "x"
initial value: 9
final value: 9
</code></pre>
<p>Note 1: There are no guarantees on which value gets returned for the counterexample. The result will be an arbitrary value that fails the assertion (in this case any value in the range <code>i32::MIN..=9</code>).
Note 2: Verification will be slower with <code>counterexamples = true</code>.</p>
<h1 id="customizable-counterexamples"><a class="header" href="#customizable-counterexamples">Customizable counterexamples</a></h1>
<p>A counterexample for structs and enums can be formatted by annotating the type with <code>#[print_counterexample(..)]</code>. This is only available if the <a href="https://viperproject.github.io/prusti-dev/dev-guide/config/flags.html#unsafe_core_proof"><code>unsafe_core_proof</code></a> flag is set to <code>true</code>.</p>
<h2 id="syntax-structs"><a class="header" href="#syntax-structs">Syntax structs</a></h2>
<p>If a struct is annotated, the macro must have at least one argument and the first argument must be of type String and can contain an arbitrary number of curly brackets. The number of curly brackets must match the number of the remaining arguments. The remaining arguments must either be a field name, if the fields are named, or an index, if the fields are unnamed. A field can be used multiple times.</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[print_counterexample("Custom message: {}, {}", field_1, field_2) ]
struct X {
    field_1: i32,
    field_2: i32,
}</code></pre>
<h2 id="syntax-enums"><a class="header" href="#syntax-enums">Syntax enums</a></h2>
<p>If an enum is annotated, the macro must not contain any arguments. Each variant can be annotated in the exact same way as previously described. Only annotating a variant without the enum itself will result in a compile time error.</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[print_counterexample()]
enum X {
    #[print_counterexample("Custom message: {}, {}", 0, 1)]
    Variant1(i32, i32),
    #[print_counterexample("Custom message")]
    Variant2,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="specifications-in-trait-impl-blocks"><a class="header" href="#specifications-in-trait-impl-blocks">Specifications in trait <code>impl</code> blocks</a></h2>
<p>Adding specifications to trait functions requires the <code>impl</code> block to be annotated with <code>#[refine_trait_spec]</code>:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>trait TestTrait {
    fn trait_fn(self) -&gt; i64;
}

#[refine_trait_spec] // &lt;== Add this annotation
impl TestTrait for i64 {

    // Cannot add these 2 specifications without `refine_trait_spec`:
    #[requires(true)]
    #[ensures(result &gt;= 0)]
    fn trait_fn(self) -&gt; i64 {
        5
    }
}</code></pre>
<p>Note: The current error message returned when <code>#[refine_trait_spec]</code> is missing does not hint at how to fix the issue. A message like this will be shown on either <code>requires</code> or <code>ensures</code>:</p>
<pre><code class="language-plain">[E0407]
method `prusti_pre_item_trait_fn_d5ce99cd719545e8adb9de778a953ec2`
is not a member of trait `TestTrait`.
</code></pre>
<p>See <a href="https://github.com/viperproject/prusti-dev/issues/625">issue #625</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification-syntax"><a class="header" href="#specification-syntax">Specification syntax</a></h1>
<p>Prusti specifications are a superset of Rust Boolean expressions. They must be deterministic and side-effect free. Therefore, they can call only <a href="verify/pure.html">pure functions</a> and <a href="verify/predicate.html">predicates</a>. The extensions to Rust expressions are summarized below:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Meaning</th></tr></thead><tbody>
<tr><td><a href="syntax.html#result-variable"><code>result</code></a></td><td>Function return value</td></tr>
<tr><td><a href="syntax.html#old-expressions"><code>old(...)</code></a></td><td>Value of expression in a previous state</td></tr>
<tr><td><a href="syntax.html#implications"><code>... ==&gt; ...</code></a></td><td>Right implication</td></tr>
<tr><td><a href="syntax.html#implications"><code>... &lt;== ...</code></a></td><td>Left implication</td></tr>
<tr><td><a href="syntax.html#implications"><code>... &lt;==&gt; ...</code></a></td><td>Biconditional</td></tr>
<tr><td><a href="syntax.html#snapshot-equality"><code>... === ...</code></a></td><td>Snapshot equality</td></tr>
<tr><td><a href="syntax.html#snapshot-equality"><code>... !== ...</code></a></td><td>Snapshot inequality</td></tr>
<tr><td><a href="syntax.html#snap-function"><code>snap(...)</code></a></td><td>Snapshot clone function</td></tr>
<tr><td><a href="syntax.html#quantifiers"><code>forall(...)</code></a></td><td>Universal quantifier</td></tr>
<tr><td><a href="syntax.html#quantifiers"><code>exists(...)</code></a></td><td>Existential quantifier</td></tr>
<tr><td><a href="syntax.html#specification-entailments"><code>... |= ...</code></a></td><td>Specification entailment</td></tr>
</tbody></table>
</div>
<h2 id="result-variable"><a class="header" href="#result-variable"><code>result</code> Variable</a></h2>
<p>When using Prusti, <code>result</code> is used to refer to what a function returns.
<code>result</code> can only be used inside a postcondition, meaning that function arguments called <code>result</code> need to be renamed.</p>
<p>Here is an example for returning an integer:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(result == 5)]
fn five() -&gt; i32 {
    5
}</code></pre>
<p>And an example for returning a tuple and accessing individual fields:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(result.0 / 2 == result.1 &amp;&amp; result.2 == 'a')]
fn tuple() -&gt; (i32, i32, char) {
    (10, 5, 'a')
}</code></pre>
<h2 id="old-expressions"><a class="header" href="#old-expressions">Old Expressions</a></h2>
<p>Old expressions are used to refer to the value that a memory location pointed at by a mutable reference had at the beginning of the function:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[ensures(*x == old(*x) + 1)]
pub fn inc(x: &amp;mut u32) {
    *x += 1;
}</code></pre>
<h2 id="implications"><a class="header" href="#implications">Implications</a></h2>
<p>Implications express a <a href="https://en.wikipedia.org/wiki/Material_conditional">relationship</a> between two Boolean expressions:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[pure]
#[ensures(result ==&gt; self.len() == 0)]
#[ensures(!result ==&gt; self.len() &gt; 0)]
pub fn is_empty(&amp;self) -&gt; bool {
    // ...
}</code></pre>
<p><code>a ==&gt; b</code> is equivalent to <code>!a || b</code> and <code>!(a &amp;&amp; !b)</code>. Here you can see a truth table for the implication operator:</p>
<div class="table-wrapper"><table><thead><tr><th><code>a</code></th><th><code>b</code></th><th><code>a ==&gt; b</code></th></tr></thead><tbody>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
</tbody></table>
</div>
<p>Note: The expression <code>b</code> is only evaluated if <code>a</code> is true (<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">Short-circuit evaluation</a>).</p>
<p>There is also syntax for a right-to-left implication:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[pure]
#[ensures(self.len() == 0 &lt;== result)]
#[ensures(self.len() &gt; 0 &lt;== !result)]
pub fn is_empty(&amp;self) -&gt; bool;</code></pre>
<p>There is also syntax for biconditionals ("if and only if"):</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[pure]
#[ensures(self.len() == 0 &lt;==&gt; result)]
pub fn is_empty(&amp;self) -&gt; bool {
    // ...
}</code></pre>
<p>Semantically, a biconditional is equivalent to a Boolean <code>==</code>. However, it has lower precedence than the <code>==</code> operator.</p>
<h2 id="snapshot-equality"><a class="header" href="#snapshot-equality">Snapshot Equality</a></h2>
<p>Snapshot equality (<code>===</code>) compares the
<a href="https://viperproject.github.io/prusti-dev/dev-guide/encoding/types-snap.html">snapshots</a>
of two values; essentially checking if the two values are structurally equal. In
contrast, the standard equality (<code>==</code>) between values is determined by the
implementation of
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>. These two
equalities do not necessarily coincide. For example, some types do not implement
<code>PartialEq</code>, or their implementation cannot be encoded as a pure function.
Nonetheless, snapshot equality could be used to compare values of such types, as
in the following code:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[requires(a === b)]
fn foo&lt;T&gt;(a: T, b: T) {}

struct X { a: i32 }

fn main() {
    foo(X { a: 1 }, X { a: 1 });
}</code></pre>
<p>There is also the counterpart for <code>!=</code> for checking structural inequality: <code>!==</code>.</p>
<h2 id="snap-function"><a class="header" href="#snap-function"><code>snap</code> Function</a></h2>
<p>The function <code>snap</code> can be used to take a snapshot of a reference in specifications.
Its functionality is similar to the <code>clone</code> function, but <code>snap</code> is only intended for use in specifications. It also does not require the type behind the reference to implement the <code>Clone</code> trait:</p>
<pre><code class="language-rust noplaypen ignore">fn snap&lt;T&gt;(input: &amp;T) -&gt; T {
    // ...
}</code></pre>
<p>The <code>snap</code> function enables writing specifications that would otherwise break Rusts ownership rules:</p>
<pre><code class="language-rust noplaypenm ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>struct NonCopyInt {
    value: i32
}

#[ensures(x === old(x))] // Error: Cannot borrow "*x" mutably
fn do_nothing_1(x: &amp;mut NonCopyInt) {}

#[ensures(snap(x) === old(snap(x)))]
fn do_nothing_2(x: &amp;mut NonCopyInt) {}</code></pre>
<p>In the first function, <code>x</code> will be borrowed by the <code>old</code> function, and can therefore not be used in the snapshot equality <code>===</code> at the same time.
Using <code>snap(x)</code> will create a snapshot of <code>x</code>, almost like using <code>x.clone()</code>, but only for specifications and even for <code>x</code> that cannot be cloned normally.</p>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<p>Quantifiers are typically used for describing how a method call changes a container such as a vector:</p>
<pre><code class="language-rust noplaypen ignore"><span class="boring">use prusti_contracts::*;
</span><span class="boring">
</span>#[requires(0 &lt;= index &amp;&amp; index &lt; self.len())]
#[ensures(self.len() == old(self.len()))]
#[ensures(self.lookup(index) == value)]
#[ensures(
    forall(|i: usize|
        (0 &lt;= i &amp;&amp; i &lt; self.len() &amp;&amp; i != index)
        ==&gt; (self.lookup(i) == old(self.lookup(i)))
    )
)]
pub fn store(&amp;mut self, index: usize, value: i32) {
    // ...
}</code></pre>
<p>There may be multiple bound variables:</p>
<pre><code class="language-plain">forall(|x: isize, y: isize| ...)
</code></pre>
<p>The syntax of universal quantifiers is:</p>
<pre><code class="language-plain">forall(|&lt;bound variable&gt;: &lt;bound variable type&gt;, ...| &lt;filter&gt; ==&gt; &lt;expression&gt;)
</code></pre>
<p>and the syntax of existential ones:</p>
<pre><code class="language-plain">exists(|&lt;bound variable&gt;: &lt;bound variable type&gt;, ...| &lt;expression&gt;)
</code></pre>
<h3 id="triggers"><a class="header" href="#triggers">Triggers</a></h3>
<p>To specify triggers for a quantifier, the syntax is <code>triggers=[..]</code>:</p>
<pre><code class="language-plain">forall(|&lt;bound variable&gt;: &lt;bound variable type&gt;, ...| &lt;filter&gt; ==&gt; &lt;expression&gt;, triggers=[&lt;trigger sets&gt;])
</code></pre>
<p>There may be multiple trigger sets. Each trigger set is a tuple of expressions. For example:</p>
<pre><code class="language-plain">forall(|x: usize| foo(x) ==&gt; bar(x), triggers=[(foo(x),), (bar(x),)])
</code></pre>
<h2 id="specification-entailments-1"><a class="header" href="#specification-entailments-1">Specification entailments</a></h2>
<p>Specification entailments provide the contract for a given closure or function variable. See the <a href="verify/spec_ent.html">specification entailments</a> chapter for more details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
