<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rustls - a modern TLS library"><meta name="keywords" content="rust, rustlang, rust-lang, rustls"><title>rustls - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../rustls/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../rustls/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate rustls</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.20.7</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#statics">Statics</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">rustls</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/rustls/lib.rs.html#1-529">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="rustls---a-modern-tls-library"><a href="#rustls---a-modern-tls-library">Rustls - a modern TLS library</a></h2>
<p>Rustls is a TLS library that aims to provide a good level of cryptographic security,
requires no configuration to achieve that security, and provides no unsafe features or
obsolete cryptography.</p>
<h3 id="current-features"><a href="#current-features">Current features</a></h3>
<ul>
<li>TLS1.2 and TLS1.3.</li>
<li>ECDSA, Ed25519 or RSA server authentication by clients.</li>
<li>ECDSA, Ed25519 or RSA server authentication by servers.</li>
<li>Forward secrecy using ECDHE; with curve25519, nistp256 or nistp384 curves.</li>
<li>AES128-GCM and AES256-GCM bulk encryption, with safe nonces.</li>
<li>ChaCha20-Poly1305 bulk encryption (<a href="https://tools.ietf.org/html/rfc7905">RFC7905</a>).</li>
<li>ALPN support.</li>
<li>SNI support.</li>
<li>Tunable fragment size to make TLS messages match size of underlying transport.</li>
<li>Optional use of vectored IO to minimise system calls.</li>
<li>TLS1.2 session resumption.</li>
<li>TLS1.2 resumption via tickets (<a href="https://tools.ietf.org/html/rfc5077">RFC5077</a>).</li>
<li>TLS1.3 resumption via tickets or session storage.</li>
<li>TLS1.3 0-RTT data for clients.</li>
<li>TLS1.3 0-RTT data for servers.</li>
<li>Client authentication by clients.</li>
<li>Client authentication by servers.</li>
<li>Extended master secret support (<a href="https://tools.ietf.org/html/rfc7627">RFC7627</a>).</li>
<li>Exporters (<a href="https://tools.ietf.org/html/rfc5705">RFC5705</a>).</li>
<li>OCSP stapling by servers.</li>
<li>SCT stapling by servers.</li>
<li>SCT verification by clients.</li>
</ul>
<h3 id="possible-future-features"><a href="#possible-future-features">Possible future features</a></h3>
<ul>
<li>PSK support.</li>
<li>OCSP verification by clients.</li>
<li>Certificate pinning.</li>
</ul>
<h3 id="non-features"><a href="#non-features">Non-features</a></h3>
<p>For reasons <a href="manual/index.html">explained in the manual</a>,
rustls does not and will not support:</p>
<ul>
<li>SSL1, SSL2, SSL3, TLS1 or TLS1.1.</li>
<li>RC4.</li>
<li>DES or triple DES.</li>
<li>EXPORT ciphersuites.</li>
<li>MAC-then-encrypt ciphersuites.</li>
<li>Ciphersuites without forward secrecy.</li>
<li>Renegotiation.</li>
<li>Kerberos.</li>
<li>Compression.</li>
<li>Discrete-log Diffie-Hellman.</li>
<li>Automatic protocol version downgrade.</li>
</ul>
<p>There are plenty of other libraries that provide these features should you
need them.</p>
<h4 id="platform-support"><a href="#platform-support">Platform support</a></h4>
<p>Rustls uses <a href="https://crates.io/crates/ring"><code>ring</code></a> for implementing the
cryptography in TLS. As a result, rustls only runs on platforms
<a href="https://github.com/briansmith/ring#online-automated-testing">supported by <code>ring</code></a>.
At the time of writing this means x86, x86-64, armv7, and aarch64.</p>
<h3 id="design-overview"><a href="#design-overview">Design Overview</a></h3><h4 id="rustls-does-not-take-care-of-network-io"><a href="#rustls-does-not-take-care-of-network-io">Rustls does not take care of network IO</a></h4>
<p>It doesn’t make or accept TCP connections, or do DNS, or read or write files.</p>
<p>There’s example client and server code which uses mio to do all needed network
IO.</p>
<h4 id="rustls-provides-encrypted-pipes"><a href="#rustls-provides-encrypted-pipes">Rustls provides encrypted pipes</a></h4>
<p>These are the <a href="server/struct.ServerConnection.html" title="ServerConnection"><code>ServerConnection</code></a> and <a href="client/struct.ClientConnection.html" title="ClientConnection"><code>ClientConnection</code></a> types.  You supply raw TLS traffic
on the left (via the <a href="enum.Connection.html#method.read_tls"><code>read_tls()</code></a> and <a href="enum.Connection.html#method.read_tls"><code>write_tls()</code></a> methods) and then read/write the
plaintext on the right:</p>
<div class="example-wrap"><pre class="language-text"><code>         TLS                                   Plaintext
         ===                                   =========
    read_tls()      +-----------------------+      reader() as io::Read
                    |                       |
          +---------&gt;   ClientConnection    +---------&gt;
                    |          or           |
          &lt;---------+   ServerConnection    &lt;---------+
                    |                       |
    write_tls()     +-----------------------+      writer() as io::Write
</code></pre></div><h4 id="rustls-takes-care-of-server-certificate-verification"><a href="#rustls-takes-care-of-server-certificate-verification">Rustls takes care of server certificate verification</a></h4>
<p>You do not need to provide anything other than a set of root certificates to trust.
Certificate verification cannot be turned off or disabled in the main API.</p>
<h3 id="getting-started"><a href="#getting-started">Getting started</a></h3>
<p>This is the minimum you need to do to make a TLS client connection.</p>
<p>First we load some root certificates.  These are used to authenticate the server.
The recommended way is to depend on the <code>webpki_roots</code> crate which contains
the Mozilla set of root certificates.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>root_store = rustls::RootCertStore::empty();
root_store.add_server_trust_anchors(
    webpki_roots::TLS_SERVER_ROOTS
        .<span class="number">0
        </span>.iter()
        .map(|ta| {
            rustls::OwnedTrustAnchor::from_subject_spki_name_constraints(
                ta.subject,
                ta.spki,
                ta.name_constraints,
            )
        })
);</code></pre></div>
<p>Next, we make a <code>ClientConfig</code>.  You’re likely to make one of these per process,
and use it for all connections made by that process.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>config = rustls::ClientConfig::builder()
    .with_safe_defaults()
    .with_root_certificates(root_store)
    .with_no_client_auth();</code></pre></div>
<p>Now we can make a connection.  You need to provide the server’s hostname so we
know what to expect to find in the server’s certificate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>rc_config = Arc::new(config);
<span class="kw">let </span>example_com = <span class="string">&quot;example.com&quot;</span>.try_into().unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>client = rustls::ClientConnection::new(rc_config, example_com);</code></pre></div>
<p>Now you should do appropriate IO for the <code>client</code> object.  If <code>client.wants_read()</code> yields
true, you should call <code>client.read_tls()</code> when the underlying connection has data.
Likewise, if <code>client.wants_write()</code> yields true, you should call <code>client.write_tls()</code>
when the underlying connection is able to send data.  You should continue doing this
as long as the connection is valid.</p>
<p>The return types of <code>read_tls()</code> and <code>write_tls()</code> only tell you if the IO worked.  No
parsing or processing of the TLS messages is done.  After each <code>read_tls()</code> you should
therefore call <code>client.process_new_packets()</code> which parses and processes the messages.
Any error returned from <code>process_new_packets</code> is fatal to the connection, and will tell you
why.  For example, if the server’s certificate is expired <code>process_new_packets</code> will
return <code>Err(WebPkiError(CertExpired, ValidateServerCert))</code>.  From this point on,
<code>process_new_packets</code> will not do any new work and will return that error continually.</p>
<p>You can extract newly received data by calling <code>client.reader()</code> (which implements the
<code>io::Read</code> trait).  You can send data to the peer by calling <code>client.writer()</code> (which
implements <code>io::Write</code> trait).  Note that <code>client.writer().write()</code> buffers data you
send if the TLS connection is not yet established: this is useful for writing (say) a
HTTP request, but this is buffered so avoid large amounts of data.</p>
<p>The following code uses a fictional socket IO API for illustration, and does not handle
errors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>rustls::Connection;

client.writer().write(<span class="string">b&quot;GET / HTTP/1.0\r\n\r\n&quot;</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>socket = connect(<span class="string">&quot;example.com&quot;</span>, <span class="number">443</span>);
<span class="kw">loop </span>{
  <span class="kw">if </span>client.wants_read() &amp;&amp; socket.ready_for_read() {
    client.read_tls(<span class="kw-2">&amp;mut </span>socket).unwrap();
    client.process_new_packets().unwrap();

    <span class="kw">let </span><span class="kw-2">mut </span>plaintext = Vec::new();
    client.reader().read_to_end(<span class="kw-2">&amp;mut </span>plaintext).unwrap();
    io::stdout().write(<span class="kw-2">&amp;</span>plaintext).unwrap();
  }

  <span class="kw">if </span>client.wants_write() &amp;&amp; socket.ready_for_write() {
    client.write_tls(<span class="kw-2">&amp;mut </span>socket).unwrap();
  }

  socket.wait_for_something_to_happen();
}</code></pre></div>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p><code>tlsserver</code> and <code>tlsclient</code> are full worked examples.  These both use mio.</p>
<h2 id="crate-features"><a href="#crate-features">Crate features</a></h2>
<p>Here’s a list of what features are exposed by the rustls crate and what
they mean.</p>
<ul>
<li>
<p><code>logging</code>: this makes the rustls crate depend on the <code>log</code> crate.
rustls outputs interesting protocol-level messages at <code>trace!</code> and <code>debug!</code>
level, and protocol-level errors at <code>warn!</code> and <code>error!</code> level.  The log
messages do not contain secret key data, and so are safe to archive without
affecting session security.  This feature is in the default set.</p>
</li>
<li>
<p><code>dangerous_configuration</code>: this feature enables a <code>dangerous()</code> method on
<code>ClientConfig</code> and <code>ServerConfig</code> that allows setting inadvisable options,
such as replacing the certificate verification process.  Applications
requesting this feature should be reviewed carefully.</p>
</li>
<li>
<p><code>quic</code>: this feature exposes additional constructors and functions
for using rustls as a TLS library for QUIC.  See the <code>quic</code> module for
details of these.  You will only need this if you’re writing a QUIC
implementation.</p>
</li>
<li>
<p><code>tls12</code>: enables support for TLS version 1.2. This feature is in the default
set. Note that, due to the additive nature of Cargo features and because it
is enabled by default, other crates in your dependency graph could re-enable
it for your application. If you want to disable TLS 1.2 for security reasons,
consider explicitly enabling TLS 1.3 only in the config builder API.</p>
</li>
<li>
<p><code>read_buf</code>: When building with Rust Nightly, adds support for the unstable
<code>std::io::ReadBuf</code> and related APIs. This reduces costs from initializing
buffers. Will do nothing on non-Nightly releases.</p>
</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="cipher_suite/index.html" title="rustls::cipher_suite mod">cipher_suite</a></div><div class="item-right docblock-short">All defined ciphersuites appear in this module.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="client/index.html" title="rustls::client mod">client</a></div><div class="item-right docblock-short">Items for use in a client.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="internal/index.html" title="rustls::internal mod">internal</a></div><div class="item-right docblock-short">Internal classes which may be useful outside the library.
The contents of this section DO NOT form part of the stable interface.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="kx_group/index.html" title="rustls::kx_group mod">kx_group</a></div><div class="item-right docblock-short">All defined key exchange groups appear in this module.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="manual/index.html" title="rustls::manual mod">manual</a></div><div class="item-right docblock-short">This is the rustls manual.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="server/index.html" title="rustls::server mod">server</a></div><div class="item-right docblock-short">Items for use in a server.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="sign/index.html" title="rustls::sign mod">sign</a></div><div class="item-right docblock-short">Message signing interfaces and implementations.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="version/index.html" title="rustls::version mod">version</a></div><div class="item-right docblock-short">All defined protocol versions appear in this module.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Certificate.html" title="rustls::Certificate struct">Certificate</a></div><div class="item-right docblock-short">This type contains a single certificate by value.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ClientConfig.html" title="rustls::ClientConfig struct">ClientConfig</a></div><div class="item-right docblock-short">Common configuration for (typically) all connections made by
a program.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ClientConnection.html" title="rustls::ClientConnection struct">ClientConnection</a></div><div class="item-right docblock-short">This represents a single TLS client connection.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.CommonState.html" title="rustls::CommonState struct">CommonState</a></div><div class="item-right docblock-short">Connection state common to both client and server connections.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ConfigBuilder.html" title="rustls::ConfigBuilder struct">ConfigBuilder</a></div><div class="item-right docblock-short">Building a <a href="server/struct.ServerConfig.html"><code>ServerConfig</code></a> or <a href="client/struct.ClientConfig.html"><code>ClientConfig</code></a> in a linker-friendly and
complete way.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ConnectionCommon.html" title="rustls::ConnectionCommon struct">ConnectionCommon</a></div><div class="item-right docblock-short">Interface shared by client and server connections.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DigitallySignedStruct.html" title="rustls::DigitallySignedStruct struct">DigitallySignedStruct</a></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IoState.html" title="rustls::IoState struct">IoState</a></div><div class="item-right docblock-short">Values of this structure are returned from <a href="enum.Connection.html#method.process_new_packets" title="Connection::process_new_packets"><code>Connection::process_new_packets</code></a>
and tell the caller the current I/O state of the TLS connection.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeyLogFile.html" title="rustls::KeyLogFile struct">KeyLogFile</a></div><div class="item-right docblock-short"><a href="trait.KeyLog.html" title="KeyLog"><code>KeyLog</code></a> implementation that opens a file whose name is
given by the <code>SSLKEYLOGFILE</code> environment variable, and writes
keys into it.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NoKeyLog.html" title="rustls::NoKeyLog struct">NoKeyLog</a></div><div class="item-right docblock-short">KeyLog that does exactly nothing.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.OwnedTrustAnchor.html" title="rustls::OwnedTrustAnchor struct">OwnedTrustAnchor</a></div><div class="item-right docblock-short">A trust anchor, commonly known as a “Root Certificate.”</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PrivateKey.html" title="rustls::PrivateKey struct">PrivateKey</a></div><div class="item-right docblock-short">This type contains a private key by value.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Reader.html" title="rustls::Reader struct">Reader</a></div><div class="item-right docblock-short">A structure that implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="std::io::Read"><code>std::io::Read</code></a> for reading plaintext.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RootCertStore.html" title="rustls::RootCertStore struct">RootCertStore</a></div><div class="item-right docblock-short">A container for root certificates able to provide a root-of-trust
for connection authentication.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ServerConfig.html" title="rustls::ServerConfig struct">ServerConfig</a></div><div class="item-right docblock-short">Common configuration for a set of server sessions.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ServerConnection.html" title="rustls::ServerConnection struct">ServerConnection</a></div><div class="item-right docblock-short">This represents a single TLS server connection.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Stream.html" title="rustls::Stream struct">Stream</a></div><div class="item-right docblock-short">This type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating
a Connection <code>C</code> and an underlying transport <code>T</code>, such as a socket.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StreamOwned.html" title="rustls::StreamOwned struct">StreamOwned</a></div><div class="item-right docblock-short">This type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating
and owning a Connection <code>C</code> and an underlying blocking transport
<code>T</code>, such as a socket.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SupportedKxGroup.html" title="rustls::SupportedKxGroup struct">SupportedKxGroup</a></div><div class="item-right docblock-short">A key-exchange group supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SupportedProtocolVersion.html" title="rustls::SupportedProtocolVersion struct">SupportedProtocolVersion</a></div><div class="item-right docblock-short">A TLS protocol version supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Ticketer.html" title="rustls::Ticketer struct">Ticketer</a></div><div class="item-right docblock-short">A concrete, safe ticket creation mechanism.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Tls12CipherSuite.html" title="rustls::Tls12CipherSuite struct">Tls12CipherSuite</a></div><div class="item-right docblock-short">A TLS 1.2 cipher suite supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Tls13CipherSuite.html" title="rustls::Tls13CipherSuite struct">Tls13CipherSuite</a></div><div class="item-right docblock-short">A TLS 1.3 cipher suite supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WantsCipherSuites.html" title="rustls::WantsCipherSuites struct">WantsCipherSuites</a></div><div class="item-right docblock-short">Config builder state where the caller must supply cipher suites.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WantsKxGroups.html" title="rustls::WantsKxGroups struct">WantsKxGroups</a></div><div class="item-right docblock-short">Config builder state where the caller must supply key exchange groups.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WantsVerifier.html" title="rustls::WantsVerifier struct">WantsVerifier</a></div><div class="item-right docblock-short">Config builder state where the caller must supply a verifier.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WantsVersions.html" title="rustls::WantsVersions struct">WantsVersions</a></div><div class="item-right docblock-short">Config builder state where the caller must supply TLS protocol versions.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Writer.html" title="rustls::Writer struct">Writer</a></div><div class="item-right docblock-short">A structure that implements <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="std::io::Write"><code>std::io::Write</code></a> for writing plaintext.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AlertDescription.html" title="rustls::AlertDescription enum">AlertDescription</a></div><div class="item-right docblock-short">The <code>AlertDescription</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BulkAlgorithm.html" title="rustls::BulkAlgorithm enum">BulkAlgorithm</a></div><div class="item-right docblock-short">Bulk symmetric encryption scheme used by a cipher suite.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.CipherSuite.html" title="rustls::CipherSuite enum">CipherSuite</a></div><div class="item-right docblock-short">The <code>CipherSuite</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Connection.html" title="rustls::Connection enum">Connection</a></div><div class="item-right docblock-short">A client or server connection.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ContentType.html" title="rustls::ContentType enum">ContentType</a></div><div class="item-right docblock-short">The <code>ContentType</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="rustls::Error enum">Error</a></div><div class="item-right docblock-short">rustls reports protocol errors using this type.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.HandshakeType.html" title="rustls::HandshakeType enum">HandshakeType</a></div><div class="item-right docblock-short">The <code>HandshakeType</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.NamedGroup.html" title="rustls::NamedGroup enum">NamedGroup</a></div><div class="item-right docblock-short">The <code>NamedGroup</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ProtocolVersion.html" title="rustls::ProtocolVersion enum">ProtocolVersion</a></div><div class="item-right docblock-short">The <code>ProtocolVersion</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ServerName.html" title="rustls::ServerName enum">ServerName</a></div><div class="item-right docblock-short">Encodes ways a client can know the expected name of the server.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.SignatureAlgorithm.html" title="rustls::SignatureAlgorithm enum">SignatureAlgorithm</a></div><div class="item-right docblock-short">The <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.SignatureScheme.html" title="rustls::SignatureScheme enum">SignatureScheme</a></div><div class="item-right docblock-short">The <code>SignatureScheme</code> TLS protocol enum.  Values in this enum are taken
from the various RFCs covering TLS, and are listed by IANA.
The <code>Unknown</code> item is used when processing unrecognised ordinals.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.SupportedCipherSuite.html" title="rustls::SupportedCipherSuite enum">SupportedCipherSuite</a></div><div class="item-right docblock-short">A cipher suite supported by rustls.</div></div></div><h2 id="statics" class="small-section-header"><a href="#statics">Statics</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="static" href="static.ALL_CIPHER_SUITES.html" title="rustls::ALL_CIPHER_SUITES static">ALL_CIPHER_SUITES</a></div><div class="item-right docblock-short">A list of all the cipher suites supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.ALL_KX_GROUPS.html" title="rustls::ALL_KX_GROUPS static">ALL_KX_GROUPS</a></div><div class="item-right docblock-short">A list of all the key exchange groups supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.ALL_VERSIONS.html" title="rustls::ALL_VERSIONS static">ALL_VERSIONS</a></div><div class="item-right docblock-short">A list of all the protocol versions supported by rustls.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.DEFAULT_CIPHER_SUITES.html" title="rustls::DEFAULT_CIPHER_SUITES static">DEFAULT_CIPHER_SUITES</a></div><div class="item-right docblock-short">The cipher suite configuration that an application should use by default.</div></div><div class="item-row"><div class="item-left module-item"><a class="static" href="static.DEFAULT_VERSIONS.html" title="rustls::DEFAULT_VERSIONS static">DEFAULT_VERSIONS</a></div><div class="item-right docblock-short">The version configuration that an application should use by default.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ConfigSide.html" title="rustls::ConfigSide trait">ConfigSide</a></div><div class="item-right docblock-short">Helper trait to abstract <a href="struct.ConfigBuilder.html" title="ConfigBuilder"><code>ConfigBuilder</code></a> over building a <a href="client/struct.ClientConfig.html"><code>ClientConfig</code></a> or <a href="server/struct.ServerConfig.html"><code>ServerConfig</code></a>.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.KeyLog.html" title="rustls::KeyLog trait">KeyLog</a></div><div class="item-right docblock-short">This trait represents the ability to do something useful
with key material, such as logging it to a file for debugging.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.SideData.html" title="rustls::SideData trait">SideData</a></div><div class="item-right docblock-short">Data specific to the peer’s side (client or server).</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.DistinguishedNames.html" title="rustls::DistinguishedNames type">DistinguishedNames</a></div><div class="item-right docblock-short">DistinguishedNames is a <code>Vec&lt;Vec&lt;u8&gt;&gt;</code> wrapped in internal types. Each element contains the
DER or BER encoded <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6"><code>Subject</code> field from RFC 5280</a>
for a single certificate. The Subject field is
<a href="https://datatracker.ietf.org/doc/html/rfc5280#page-116">encoded as an RFC 5280 <code>Name</code></a>.
It can be decoded using <a href="https://docs.rs/x509-parser/latest/x509_parser/traits/trait.FromDer.html">x509-parser’s FromDer trait</a>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rustls" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (afaf3e07a 2023-01-14)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>