<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate helps with defining “newtype”-style wrappers around `usize` (or other integers), `Vec&lt;T&gt;`, and `[T]` so that some additional type safety can be gained at zero cost."><meta name="keywords" content="rust, rustlang, rust-lang, index_vec"><title>index_vec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../index_vec/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../index_vec/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate index_vec</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../index_vec/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">index_vec</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/index_vec/lib.rs.html#1-806">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate helps with defining “newtype”-style wrappers around <code>usize</code> (or
other integers), <code>Vec&lt;T&gt;</code>, and <code>[T]</code> so that some additional type safety can
be gained at zero cost.</p>
<h3 id="example--overview"><a href="#example--overview">Example / Overview</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">index_vec</span>::{<span class="ident">IndexVec</span>, <span class="ident">IndexSlice</span>, <span class="ident">index_vec</span>};

<span class="macro">index_vec::define_index_type!</span> {
    <span class="comment">// Define StrIdx to use only 32 bits internally (you can use usize, u16,</span>
    <span class="comment">// and even u8).</span>
    <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">StrIdx</span> <span class="op">=</span> <span class="ident">u32</span>;

    <span class="comment">// The defaults are very reasonable, but this macro can let</span>
    <span class="comment">// you customize things quite a bit:</span>

    <span class="comment">// By default, creating a StrIdx would check an incoming `usize against</span>
    <span class="comment">// `u32::max_value()`, as u32 is the wrapped index type. Lets imagine that</span>
    <span class="comment">// StrIdx has to interface with an external system that uses signed ints.</span>
    <span class="comment">// We can change the checking behavior to complain on i32::max_value()</span>
    <span class="comment">// instead:</span>
    <span class="ident">MAX_INDEX</span> <span class="op">=</span> <span class="ident">i32::max_value</span>() <span class="kw">as</span> <span class="ident">usize</span>;

    <span class="comment">// We can also disable checking all-together if we are more concerned with perf</span>
    <span class="comment">// than any overflow problems, or even do so, but only for debug builds: Quite</span>
    <span class="comment">// pointless here, but an okay example</span>
    <span class="ident">DISABLE_MAX_INDEX_CHECK</span> <span class="op">=</span> <span class="macro">cfg!</span>(<span class="ident">not</span>(<span class="ident">debug_assertions</span>));

    <span class="comment">// And more too, see this macro&#39;s docs for more info.</span>
}

<span class="comment">// Create a vector which can be accessed using `StrIdx`s.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">strs</span>: <span class="ident">IndexVec</span><span class="op">&lt;</span><span class="ident">StrIdx</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">index_vec!</span>[<span class="string">&quot;strs&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];

<span class="comment">// l is a `StrIdx`</span>
<span class="kw">let</span> <span class="ident">l</span> <span class="op">=</span> <span class="ident">strs</span>.<span class="ident">last_idx</span>();
<span class="macro">assert_eq!</span>(<span class="ident">strs</span>[<span class="ident">l</span>], <span class="string">&quot;baz&quot;</span>);

<span class="kw">let</span> <span class="ident">new_i</span> <span class="op">=</span> <span class="ident">strs</span>.<span class="ident">push</span>(<span class="string">&quot;quux&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">strs</span>[<span class="ident">new_i</span>], <span class="string">&quot;quux&quot;</span>);

<span class="comment">// The slice APIs are wrapped as well.</span>
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">IndexSlice</span><span class="op">&lt;</span><span class="ident">StrIdx</span>, [<span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">strs</span>[<span class="ident">StrIdx::new</span>(<span class="number">1</span>)..];
<span class="macro">assert_eq!</span>(<span class="ident">s</span>[<span class="number">0</span>], <span class="string">&quot;bar&quot;</span>);

<span class="comment">// Indices are mostly interoperable with `usize`, and support</span>
<span class="comment">// a lot of what you might want to do to an index.</span>

<span class="comment">// Comparison</span>
<span class="macro">assert_eq!</span>(<span class="ident">StrIdx::new</span>(<span class="number">0</span>), <span class="number">0usize</span>);

<span class="comment">// Addition</span>
<span class="macro">assert_eq!</span>(<span class="ident">StrIdx::new</span>(<span class="number">0</span>) <span class="op">+</span> <span class="number">1</span>, <span class="number">1usize</span>);

<span class="comment">// Subtraction</span>
<span class="macro">assert_eq!</span>(<span class="ident">StrIdx::new</span>(<span class="number">1</span>) <span class="op">-</span> <span class="number">1</span>, <span class="number">0usize</span>);

<span class="comment">// Wrapping</span>
<span class="macro">assert_eq!</span>(<span class="ident">StrIdx::new</span>(<span class="number">5</span>) <span class="op">%</span> <span class="ident">strs</span>.<span class="ident">len</span>(), <span class="number">1usize</span>);
<span class="comment">// ...</span></code></pre></div>
<h3 id="background"><a href="#background">Background</a></h3>
<p>The goal is to help with the pattern of using a <code>type FooIdx = usize</code> to
access a <code>Vec&lt;Foo&gt;</code> with something that can statically prevent using a
<code>FooIdx</code> in a <code>Vec&lt;Bar&gt;</code>. It’s most useful if you have a bunch of indices
referring to different sorts of vectors.</p>
<p>The code was originally based on <code>rustc</code>’s <code>IndexVec</code> code, however that has
been almost entirely rewritten (except for the cases where it’s trivial,
e.g. the Vec wrapper).</p>
<h3 id="other-crates"><a href="#other-crates">Other crates</a></h3>
<p>The <a href="https://crates.io/crates/indexed_vec"><code>indexed_vec</code></a> crate predates
this, and is a much closer copy of the code from <code>rustc</code>. Unfortunately,
this means it does not compile on stable.</p>
<p>If you’re looking for something further from a vec and closer to a map, you
might find <a href="https://crates.io/crates/handy"><code>handy</code></a>,
<a href="https://crates.io/crates/slotmap"><code>slotmap</code></a>, or
<a href="https://crates.io/crates/slab"><code>slab</code></a> to be closer what you want.</p>
<h3 id="faq"><a href="#faq">FAQ</a></h3><h5 id="wouldnt-define_index_type-be-better-as-a-proc-macro"><a href="#wouldnt-define_index_type-be-better-as-a-proc-macro">Wouldn’t <code>define_index_type</code> be better as a proc macro?</a></h5>
<p>Probably. It’s not a proc macro because I tend to avoid them where possible
due to wanting to minimize compile times. If the issues around proc-macro
compile times are fixed, then I’ll revisit this.</p>
<p>I also may eventually add a proc-macro feature which is not required, but
avoids some of the grossness.</p>
<h5 id="does-define_index_type-do-too-much"><a href="#does-define_index_type-do-too-much">Does <code>define_index_type</code> do too much?</a></h5>
<p>Possibly. It defines a type, implements a bunch of functions on it, and
quite a few traits. That said, it’s intended to be a very painless journey
from <code>Vec&lt;T&gt;</code> + <code>usize</code> to <code>IndexVec&lt;I, T&gt;</code>. If it left it up to the
developer to do those things, it would be too annoying to be worth using.</p>
<h5 id="the-syntax-for-the-options-in-define_index_type-is-terrible"><a href="#the-syntax-for-the-options-in-define_index_type-is-terrible">The syntax for the options in <code>define_index_type</code> is terrible.</a></h5>
<p>I’m open to suggestions.</p>
<h5 id="does-it-support-no_std"><a href="#does-it-support-no_std">Does it support no_std?</a></h5>
<p>Yes, although it uses <code>extern crate alloc;</code>, of course.</p>
<h5 id="does-it-support-serde"><a href="#does-it-support-serde">Does it support serde?</a></h5>
<p>Yes, but only if you turn on the <code>serde</code> feature.</p>
<h5 id="what-features-are-planned"><a href="#what-features-are-planned">What features are planned?</a></h5>
<p>Planned is a bit strong but here are the things I would find useful.</p>
<ul>
<li>Support any remaining parts of the slice/vec api.</li>
<li>Add typesafe wrappers for SmallVec/ArrayVec (behind a cargo <code>feature</code>, of
course).</li>
<li>Better syntax for the define_index_type macro (no concrete ideas).</li>
<li>Allow the generated type to be a tuple struct, or use a specific field
name.</li>
<li>Allow use of indices for string types (the primary benefit here would
probably be the ability to e.g. use u32 without too much pain rather than
mixing up indices from different strings – but you never know!)</li>
<li>Allow index types such as NonZeroU32 and such, if it can be done sanely.</li>
<li>…</li>
</ul>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.define_index_type.html" title="index_vec::define_index_type macro">define_index_type</a></div><div class="item-right docblock-short"><p>Generate the boilerplate for a newtyped index struct, for use with
<code>IndexVec</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.index_box.html" title="index_vec::index_box macro">index_box</a></div><div class="item-right docblock-short"><p>A macro similar to the stdlib’s <code>vec![]</code>, but producing an
<code>Box&lt;IndexSlice&lt;I, [T]&gt;&gt;</code> (That is, an <code>IndexBox&lt;I, [T]&gt;</code>).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.index_vec.html" title="index_vec::index_vec macro">index_vec</a></div><div class="item-right docblock-short"><p>A macro equivalent to the stdlib’s <code>vec![]</code>, but producing an <code>IndexVec</code>.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IndexSlice.html" title="index_vec::IndexSlice struct">IndexSlice</a></div><div class="item-right docblock-short"><p>A slice that only accepts indices of a specific type. Note that the intended
usage is as <code>IndexSlice&lt;I, [T]&gt;</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.IndexVec.html" title="index_vec::IndexVec struct">IndexVec</a></div><div class="item-right docblock-short"><p>A Vec that only accepts indices of a specific type.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Idx.html" title="index_vec::Idx trait">Idx</a></div><div class="item-right docblock-short"><p>Represents a wrapped value convertable to and from a <code>usize</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IdxRangeBounds.html" title="index_vec::IdxRangeBounds trait">IdxRangeBounds</a></div><div class="item-right docblock-short"><p>This trait to function in API signatures where <code>Vec&lt;T&gt;</code> or <code>[T]</code> use <code>R: RangeBounds&lt;usize&gt;</code>. There are blanket implementations for the basic range
types in <code>core::ops</code> for all Idx types. e.g. <code>Range&lt;I: Idx&gt;</code>, <code>RangeFrom&lt;I: Idx&gt;</code>, <code>RangeTo&lt;I: Idx&gt;</code>, etc all implement it.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IdxSliceIndex.html" title="index_vec::IdxSliceIndex trait">IdxSliceIndex</a></div><div class="item-right docblock-short"><p>This is the equivalent of the sealed <code>core::slice::SliceIndex</code> trait. It
cannot be overridden from user, code nor should it normally need use
directly (Outside of trait bounds, I guess).</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.IndexBox.html" title="index_vec::IndexBox type">IndexBox</a></div><div class="item-right docblock-short"><p><code>IndexBox&lt;I, [T]&gt;</code>: An alias for indexed boxed slice.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="index_vec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0-nightly (f9cba6374 2022-07-31)" ></div></body></html>