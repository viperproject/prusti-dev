<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pest_meta-2.5.6/src/grammar.rs`."><title>grammar.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../static.files/ayu-be46fdc453a55015.css"><script src="../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../pest_meta/index.html"><img src="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
</pre><pre class="rust"><code><span class="kw">pub struct </span>PestParser;
# [doc = <span class="string">&quot;Pest meta-grammar\n\n# Warning: Semantic Versioning\nThere may be non-breaking changes to the meta-grammar\nbetween minor versions. Those non-breaking changes, however,\nmay translate into semver-breaking changes due to the additional variants\nadded to the `Rule` enum. This is a known issue and will be fixed in the\nfuture (e.g. by increasing MSRV and non_exhaustive annotations).&quot;</span>] # [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { EOI , # [doc = <span class="string">&quot;The top-level rule of a grammar.&quot;</span>] r#grammar_rules , # [doc = <span class="string">&quot;A rule of a grammar.&quot;</span>] r#grammar_rule , # [doc = <span class="string">&quot;Assignment operator.&quot;</span>] r#assignment_operator , # [doc = <span class="string">&quot;Opening brace for a rule.&quot;</span>] r#opening_brace , # [doc = <span class="string">&quot;Closing brace for a rule.&quot;</span>] r#closing_brace , # [doc = <span class="string">&quot;Opening parenthesis for a branch, PUSH, etc.&quot;</span>] r#opening_paren , # [doc = <span class="string">&quot;Closing parenthesis for a branch, PUSH, etc.&quot;</span>] r#closing_paren , # [doc = <span class="string">&quot;Opening bracket for PEEK (slice inside).&quot;</span>] r#opening_brack , # [doc = <span class="string">&quot;Closing bracket for PEEK (slice inside).&quot;</span>] r#closing_brack , # [doc = <span class="string">&quot;A rule modifier.&quot;</span>] r#modifier , # [doc = <span class="string">&quot;Silent rule prefix.&quot;</span>] r#silent_modifier , # [doc = <span class="string">&quot;Atomic rule prefix.&quot;</span>] r#atomic_modifier , # [doc = <span class="string">&quot;Compound atomic rule prefix.&quot;</span>] r#compound_atomic_modifier , # [doc = <span class="string">&quot;Non-atomic rule prefix.&quot;</span>] r#non_atomic_modifier , # [doc = <span class="string">&quot;A rule expression.&quot;</span>] r#expression , # [doc = <span class="string">&quot;A rule term.&quot;</span>] r#term , # [doc = <span class="string">&quot;A rule node (inside terms).&quot;</span>] r#node , # [doc = <span class="string">&quot;A terminal expression.&quot;</span>] r#terminal , # [doc = <span class="string">&quot;Possible predicates for a rule.&quot;</span>] r#prefix_operator , # [doc = <span class="string">&quot;Branches or sequences.&quot;</span>] r#infix_operator , # [doc = <span class="string">&quot;Possible modifiers for a rule.&quot;</span>] r#postfix_operator , # [doc = <span class="string">&quot;A positive predicate.&quot;</span>] r#positive_predicate_operator , # [doc = <span class="string">&quot;A negative predicate.&quot;</span>] r#negative_predicate_operator , # [doc = <span class="string">&quot;A sequence operator.&quot;</span>] r#sequence_operator , # [doc = <span class="string">&quot;A choice operator.&quot;</span>] r#choice_operator , # [doc = <span class="string">&quot;An optional operator.&quot;</span>] r#optional_operator , # [doc = <span class="string">&quot;A repeat operator.&quot;</span>] r#repeat_operator , # [doc = <span class="string">&quot;A repeat at least once operator.&quot;</span>] r#repeat_once_operator , # [doc = <span class="string">&quot;A repeat exact times.&quot;</span>] r#repeat_exact , # [doc = <span class="string">&quot;A repeat at least times.&quot;</span>] r#repeat_min , # [doc = <span class="string">&quot;A repeat at most times.&quot;</span>] r#repeat_max , # [doc = <span class="string">&quot;A repeat in a range.&quot;</span>] r#repeat_min_max , # [doc = <span class="string">&quot;A number.&quot;</span>] r#number , # [doc = <span class="string">&quot;An integer number (positive or negative).&quot;</span>] r#integer , # [doc = <span class="string">&quot;A comma terminal.&quot;</span>] r#comma , # [doc = <span class="string">&quot;A PUSH expression.&quot;</span>] r#_push , # [doc = <span class="string">&quot;A PEEK expression.&quot;</span>] r#peek_slice , # [doc = <span class="string">&quot;An identifier.&quot;</span>] r#identifier , # [doc = <span class="string">&quot;An alpha character.&quot;</span>] r#alpha , # [doc = <span class="string">&quot;An alphanumeric character.&quot;</span>] r#alpha_num , # [doc = <span class="string">&quot;A string.&quot;</span>] r#string , # [doc = <span class="string">&quot;An insensitive string.&quot;</span>] r#insensitive_string , # [doc = <span class="string">&quot;A character range.&quot;</span>] r#range , # [doc = <span class="string">&quot;A single quoted character&quot;</span>] r#character , # [doc = <span class="string">&quot;A quoted string.&quot;</span>] r#inner_str , # [doc = <span class="string">&quot;An escaped or any character.&quot;</span>] r#inner_chr , # [doc = <span class="string">&quot;An escape sequence.&quot;</span>] r#escape , # [doc = <span class="string">&quot;A hexadecimal code.&quot;</span>] r#code , # [doc = <span class="string">&quot;A unicode code.&quot;</span>] r#unicode , # [doc = <span class="string">&quot;A hexadecimal digit.&quot;</span>] r#hex_digit , # [doc = <span class="string">&quot;A double quote.&quot;</span>] r#quote , # [doc = <span class="string">&quot;A single quote.&quot;</span>] r#single_quote , # [doc = <span class="string">&quot;A range operator.&quot;</span>] r#range_operator , # [doc = <span class="string">&quot;A newline character.&quot;</span>] r#newline , # [doc = <span class="string">&quot;A whitespace character.&quot;</span>] r#WHITESPACE , # [doc = <span class="string">&quot;A single line comment.&quot;</span>] r#line_comment , # [doc = <span class="string">&quot;A multi-line comment.&quot;</span>] r#block_comment , # [doc = <span class="string">&quot;A grammar comment.&quot;</span>] r#COMMENT , # [doc = <span class="string">&quot;A space character.&quot;</span>] r#space , # [doc = <span class="string">&quot;A top-level comment.&quot;</span>] r#grammar_doc , # [doc = <span class="string">&quot;A rule comment.&quot;</span>] r#line_doc , # [doc = <span class="string">&quot;A comment content.&quot;</span>] r#inner_doc } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>PestParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">&#39;i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">&#39;i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result </span>&lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">&#39;i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rules (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_doc (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_doc (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#grammar_rule (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_rule (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_rule (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rule (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#grammar_rule , | state | { state . sequence (| state | { <span class="self">self </span>:: r#identifier (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#assignment_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#modifier (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#line_doc (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#assignment_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#assignment_operator , | state | { state . match_string (<span class="string">&quot;=&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brace , | state | { state . match_string (<span class="string">&quot;{&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brace , | state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_paren , | state | { state . match_string (<span class="string">&quot;(&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_paren , | state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brack , | state | { state . match_string (<span class="string">&quot;[&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brack , | state | { state . match_string (<span class="string">&quot;]&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#silent_modifier (state) . or_else (| state | { <span class="self">self </span>:: r#atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#compound_atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#non_atomic_modifier (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#silent_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#silent_modifier , | state | { state . match_string (<span class="string">&quot;_&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#atomic_modifier , | state | { state . match_string (<span class="string">&quot;@&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#compound_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#compound_atomic_modifier , | state | { state . match_string (<span class="string">&quot;$&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#non_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#non_atomic_modifier , | state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#expression (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#expression , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#choice_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#term (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#term , | state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#prefix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#prefix_operator (state) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#node (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#postfix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#postfix_operator (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#node (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#opening_paren (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#terminal (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#terminal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#_push (state) . or_else (| state | { <span class="self">self </span>:: r#peek_slice (state) }) . or_else (| state | { <span class="self">self </span>:: r#identifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#insensitive_string (state) }) . or_else (| state | { <span class="self">self </span>:: r#range (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#prefix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#positive_predicate_operator (state) . or_else (| state | { <span class="self">self </span>:: r#negative_predicate_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#infix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#sequence_operator (state) . or_else (| state | { <span class="self">self </span>:: r#choice_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#postfix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#optional_operator (state) . or_else (| state | { <span class="self">self </span>:: r#repeat_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_once_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_exact (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_max (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min_max (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#positive_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#positive_predicate_operator , | state | { state . match_string (<span class="string">&quot;&amp;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#negative_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#negative_predicate_operator , | state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#sequence_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#sequence_operator , | state | { state . match_string (<span class="string">&quot;~&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#choice_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#choice_operator , | state | { state . match_string (<span class="string">&quot;|&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#optional_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#optional_operator , | state | { state . match_string (<span class="string">&quot;?&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_operator , | state | { state . match_string (<span class="string">&quot;*&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_once_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_once_operator , | state | { state . match_string (<span class="string">&quot;+&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_exact (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_exact , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . and_then (| state | { state . repeat (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#integer (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#integer , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#number (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;-&quot;</span>) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">&quot;0&quot;</span>) }) }) . and_then (| state | { state . match_range (<span class="string">&#39;1&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#number (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#comma (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#comma , | state | { state . match_string (<span class="string">&quot;,&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#_push (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#_push , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;PUSH&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_paren (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#peek_slice (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#peek_slice , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;PEEK&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brack (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brack (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#identifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#identifier , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;PUSH&quot;</span>) }) . and_then (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;z&#39;</span>) . or_else (| state | { state . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;Z&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha_num (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#alpha (state) . or_else (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#string , | state | { state . sequence (| state | { <span class="self">self </span>:: r#quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) . and_then (| state | { <span class="self">self </span>:: r#quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#insensitive_string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#insensitive_string , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;^&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#string (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range , | state | { state . sequence (| state | { <span class="self">self </span>:: r#character (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#character , | state | { state . sequence (| state | { <span class="self">self </span>:: r#single_quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_chr (state) }) . and_then (| state | { <span class="self">self </span>:: r#single_quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_str (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_str , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="kw">let </span>strings = [<span class="string">&quot;\&quot;&quot; </span>, <span class="string">&quot;\\&quot;</span>] ; state . skip_until (&amp; strings) . and_then (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#escape (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_chr (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_chr , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#escape (state) . or_else (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#escape (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#escape , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) . and_then (| state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;r&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;n&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;t&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;0&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;&#39;&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: r#code (state) }) . or_else (| state | { <span class="self">self </span>:: r#unicode (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#code (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#code , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;x&quot;</span>) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#unicode (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#unicode , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;u&quot;</span>) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#hex_digit (state) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#hex_digit (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#hex_digit , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . or_else (| state | { state . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;f&#39;</span>) }) . or_else (| state | { state . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;F&#39;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#quote , | state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#single_quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#single_quote , | state | { state . match_string (<span class="string">&quot;&#39;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range_operator , | state | { state . match_string (<span class="string">&quot;..&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#newline (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">&quot;\n&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\r\n&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">&quot; &quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\t&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: r#newline (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">&quot;//&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;/&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">&quot;/*&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { <span class="self">self </span>:: r#line_comment (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#space (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">&quot; &quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\t&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#grammar_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;//!&quot;</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#line_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;///&quot;</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_doc , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: r#grammar_rules =&gt; rules :: r#grammar_rules (state) , Rule :: r#grammar_rule =&gt; rules :: r#grammar_rule (state) , Rule :: r#assignment_operator =&gt; rules :: r#assignment_operator (state) , Rule :: r#opening_brace =&gt; rules :: r#opening_brace (state) , Rule :: r#closing_brace =&gt; rules :: r#closing_brace (state) , Rule :: r#opening_paren =&gt; rules :: r#opening_paren (state) , Rule :: r#closing_paren =&gt; rules :: r#closing_paren (state) , Rule :: r#opening_brack =&gt; rules :: r#opening_brack (state) , Rule :: r#closing_brack =&gt; rules :: r#closing_brack (state) , Rule :: r#modifier =&gt; rules :: r#modifier (state) , Rule :: r#silent_modifier =&gt; rules :: r#silent_modifier (state) , Rule :: r#atomic_modifier =&gt; rules :: r#atomic_modifier (state) , Rule :: r#compound_atomic_modifier =&gt; rules :: r#compound_atomic_modifier (state) , Rule :: r#non_atomic_modifier =&gt; rules :: r#non_atomic_modifier (state) , Rule :: r#expression =&gt; rules :: r#expression (state) , Rule :: r#term =&gt; rules :: r#term (state) , Rule :: r#node =&gt; rules :: r#node (state) , Rule :: r#terminal =&gt; rules :: r#terminal (state) , Rule :: r#prefix_operator =&gt; rules :: r#prefix_operator (state) , Rule :: r#infix_operator =&gt; rules :: r#infix_operator (state) , Rule :: r#postfix_operator =&gt; rules :: r#postfix_operator (state) , Rule :: r#positive_predicate_operator =&gt; rules :: r#positive_predicate_operator (state) , Rule :: r#negative_predicate_operator =&gt; rules :: r#negative_predicate_operator (state) , Rule :: r#sequence_operator =&gt; rules :: r#sequence_operator (state) , Rule :: r#choice_operator =&gt; rules :: r#choice_operator (state) , Rule :: r#optional_operator =&gt; rules :: r#optional_operator (state) , Rule :: r#repeat_operator =&gt; rules :: r#repeat_operator (state) , Rule :: r#repeat_once_operator =&gt; rules :: r#repeat_once_operator (state) , Rule :: r#repeat_exact =&gt; rules :: r#repeat_exact (state) , Rule :: r#repeat_min =&gt; rules :: r#repeat_min (state) , Rule :: r#repeat_max =&gt; rules :: r#repeat_max (state) , Rule :: r#repeat_min_max =&gt; rules :: r#repeat_min_max (state) , Rule :: r#number =&gt; rules :: r#number (state) , Rule :: r#integer =&gt; rules :: r#integer (state) , Rule :: r#comma =&gt; rules :: r#comma (state) , Rule :: r#_push =&gt; rules :: r#_push (state) , Rule :: r#peek_slice =&gt; rules :: r#peek_slice (state) , Rule :: r#identifier =&gt; rules :: r#identifier (state) , Rule :: r#alpha =&gt; rules :: r#alpha (state) , Rule :: r#alpha_num =&gt; rules :: r#alpha_num (state) , Rule :: r#string =&gt; rules :: r#string (state) , Rule :: r#insensitive_string =&gt; rules :: r#insensitive_string (state) , Rule :: r#range =&gt; rules :: r#range (state) , Rule :: r#character =&gt; rules :: r#character (state) , Rule :: r#inner_str =&gt; rules :: r#inner_str (state) , Rule :: r#inner_chr =&gt; rules :: r#inner_chr (state) , Rule :: r#escape =&gt; rules :: r#escape (state) , Rule :: r#code =&gt; rules :: r#code (state) , Rule :: r#unicode =&gt; rules :: r#unicode (state) , Rule :: r#hex_digit =&gt; rules :: r#hex_digit (state) , Rule :: r#quote =&gt; rules :: r#quote (state) , Rule :: r#single_quote =&gt; rules :: r#single_quote (state) , Rule :: r#range_operator =&gt; rules :: r#range_operator (state) , Rule :: r#newline =&gt; rules :: r#newline (state) , Rule :: r#WHITESPACE =&gt; rules :: r#WHITESPACE (state) , Rule :: r#line_comment =&gt; rules :: r#line_comment (state) , Rule :: r#block_comment =&gt; rules :: r#block_comment (state) , Rule :: r#COMMENT =&gt; rules :: r#COMMENT (state) , Rule :: r#space =&gt; rules :: r#space (state) , Rule :: r#grammar_doc =&gt; rules :: r#grammar_doc (state) , Rule :: r#line_doc =&gt; rules :: r#line_doc (state) , Rule :: r#inner_doc =&gt; rules :: r#inner_doc (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }
</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pest_meta" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (e3dfeeaa4 2023-03-07)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>