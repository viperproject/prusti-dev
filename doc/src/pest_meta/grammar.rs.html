<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/pest_meta-2.5.2/src/grammar.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>grammar.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/source-script-ea63cb6500f71309.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../pest_meta/index.html">
                        <img src="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
</pre><pre class="rust"><code><span class="kw">pub struct </span>PestParser;
# [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { EOI , grammar_rules , grammar_rule , assignment_operator , opening_brace , closing_brace , opening_paren , closing_paren , opening_brack , closing_brack , modifier , silent_modifier , atomic_modifier , compound_atomic_modifier , non_atomic_modifier , expression , term , node , terminal , prefix_operator , infix_operator , postfix_operator , positive_predicate_operator , negative_predicate_operator , sequence_operator , choice_operator , optional_operator , repeat_operator , repeat_once_operator , repeat_exact , repeat_min , repeat_max , repeat_min_max , number , integer , comma , _push , peek_slice , identifier , alpha , alpha_num , string , insensitive_string , range , character , inner_str , inner_chr , escape , code , unicode , hex_digit , quote , single_quote , range_operator , newline , WHITESPACE , block_comment , COMMENT } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>PestParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">&#39;i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">&#39;i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result </span>&lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">&#39;i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>grammar_rules (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: grammar_rule (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: grammar_rule (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: grammar_rule (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: EOI (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>grammar_rule (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: grammar_rule , | state | { state . sequence (| state | { <span class="self">self </span>:: identifier (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: assignment_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: modifier (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: opening_brace (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>assignment_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: assignment_operator , | state | { state . match_string (<span class="string">&quot;=&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: opening_brace , | state | { state . match_string (<span class="string">&quot;{&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: closing_brace , | state | { state . match_string (<span class="string">&quot;}&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: opening_paren , | state | { state . match_string (<span class="string">&quot;(&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: closing_paren , | state | { state . match_string (<span class="string">&quot;)&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: opening_brack , | state | { state . match_string (<span class="string">&quot;[&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: closing_brack , | state | { state . match_string (<span class="string">&quot;]&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: silent_modifier (state) . or_else (| state | { <span class="self">self </span>:: atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: compound_atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: non_atomic_modifier (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>silent_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: silent_modifier , | state | { state . match_string (<span class="string">&quot;_&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: atomic_modifier , | state | { state . match_string (<span class="string">&quot;@&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>compound_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: compound_atomic_modifier , | state | { state . match_string (<span class="string">&quot;$&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>non_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: non_atomic_modifier , | state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>expression (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: expression , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: choice_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: term (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: term (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: term (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>term (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: term , | state | { state . sequence (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: prefix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: prefix_operator (state) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: node (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: postfix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: postfix_operator (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>node (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: opening_paren (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_paren (state) }) }) . or_else (| state | { <span class="self">self </span>:: terminal (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>terminal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: _push (state) . or_else (| state | { <span class="self">self </span>:: peek_slice (state) }) . or_else (| state | { <span class="self">self </span>:: identifier (state) }) . or_else (| state | { <span class="self">self </span>:: string (state) }) . or_else (| state | { <span class="self">self </span>:: insensitive_string (state) }) . or_else (| state | { <span class="self">self </span>:: range (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>prefix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: positive_predicate_operator (state) . or_else (| state | { <span class="self">self </span>:: negative_predicate_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>infix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: sequence_operator (state) . or_else (| state | { <span class="self">self </span>:: choice_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>postfix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: optional_operator (state) . or_else (| state | { <span class="self">self </span>:: repeat_operator (state) }) . or_else (| state | { <span class="self">self </span>:: repeat_once_operator (state) }) . or_else (| state | { <span class="self">self </span>:: repeat_exact (state) }) . or_else (| state | { <span class="self">self </span>:: repeat_min (state) }) . or_else (| state | { <span class="self">self </span>:: repeat_max (state) }) . or_else (| state | { <span class="self">self </span>:: repeat_min_max (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>positive_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: positive_predicate_operator , | state | { state . match_string (<span class="string">&quot;&amp;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>negative_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: negative_predicate_operator , | state | { state . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>sequence_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: sequence_operator , | state | { state . match_string (<span class="string">&quot;~&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>choice_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: choice_operator , | state | { state . match_string (<span class="string">&quot;|&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>optional_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: optional_operator , | state | { state . match_string (<span class="string">&quot;?&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_operator , | state | { state . match_string (<span class="string">&quot;*&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_once_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_once_operator , | state | { state . match_string (<span class="string">&quot;+&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_exact (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_exact , | state | { state . sequence (| state | { <span class="self">self </span>:: opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_min (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_min , | state | { state . sequence (| state | { <span class="self">self </span>:: opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_max , | state | { state . sequence (| state | { <span class="self">self </span>:: opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_min_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: repeat_min_max , | state | { state . sequence (| state | { <span class="self">self </span>:: opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . and_then (| state | { state . repeat (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>integer (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: integer , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: number (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;-&quot;</span>) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">&quot;0&quot;</span>) }) }) . and_then (| state | { state . match_range (<span class="string">&#39;1&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: number (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>comma (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: comma , | state | { state . match_string (<span class="string">&quot;,&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>_push (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: _push , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;PUSH&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: opening_paren (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_paren (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>peek_slice (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: peek_slice , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;PEEK&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: opening_brack (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: closing_brack (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>identifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: identifier , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;PUSH&quot;</span>) }) . and_then (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>alpha (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;z&#39;</span>) . or_else (| state | { state . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;Z&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>alpha_num (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: alpha (state) . or_else (| state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: string , | state | { state . sequence (| state | { <span class="self">self </span>:: quote (state) . and_then (| state | { <span class="self">self </span>:: inner_str (state) }) . and_then (| state | { <span class="self">self </span>:: quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>insensitive_string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: insensitive_string , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;^&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: string (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>range (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: range , | state | { state . sequence (| state | { <span class="self">self </span>:: character (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: character , | state | { state . sequence (| state | { <span class="self">self </span>:: single_quote (state) . and_then (| state | { <span class="self">self </span>:: inner_chr (state) }) . and_then (| state | { <span class="self">self </span>:: single_quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>inner_str (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: inner_str , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="kw">let </span>strings = [<span class="string">&quot;\&quot;&quot; </span>, <span class="string">&quot;\\&quot;</span>] ; state . skip_until (&amp; strings) . and_then (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: escape (state) . and_then (| state | { <span class="self">self </span>:: inner_str (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>inner_chr (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: inner_chr , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: escape (state) . or_else (| state | { <span class="self">self </span>:: ANY (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>escape (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: escape , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) . and_then (| state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\\&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;r&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;n&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;t&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;0&quot;</span>) }) . or_else (| state | { state . match_string (<span class="string">&quot;&#39;&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: code (state) }) . or_else (| state | { <span class="self">self </span>:: unicode (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>code (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: code , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;x&quot;</span>) . and_then (| state | { <span class="self">self </span>:: hex_digit (state) }) . and_then (| state | { <span class="self">self </span>:: hex_digit (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>unicode (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: unicode , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">&quot;u&quot;</span>) . and_then (| state | { <span class="self">self </span>:: opening_brace (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: hex_digit (state) . and_then (| state | { <span class="self">self </span>:: hex_digit (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: hex_digit (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>hex_digit (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: hex_digit , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . or_else (| state | { state . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;f&#39;</span>) }) . or_else (| state | { state . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;F&#39;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: quote , | state | { state . match_string (<span class="string">&quot;\&quot;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>single_quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: single_quote , | state | { state . match_string (<span class="string">&quot;&#39;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>range_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: range_operator , | state | { state . match_string (<span class="string">&quot;..&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>newline (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">&quot;\n&quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\r\n&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">&quot; &quot;</span>) . or_else (| state | { state . match_string (<span class="string">&quot;\t&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: newline (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>block_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">&quot;/*&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: ANY (state) }) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: ANY (state) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">&quot;*/&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: block_comment (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">&quot;//&quot;</span>) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: newline (state) }) . and_then (| state | { <span class="self">self </span>:: ANY (state) }) }) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">&#39;_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: grammar_rules =&gt; rules :: grammar_rules (state) , Rule :: grammar_rule =&gt; rules :: grammar_rule (state) , Rule :: assignment_operator =&gt; rules :: assignment_operator (state) , Rule :: opening_brace =&gt; rules :: opening_brace (state) , Rule :: closing_brace =&gt; rules :: closing_brace (state) , Rule :: opening_paren =&gt; rules :: opening_paren (state) , Rule :: closing_paren =&gt; rules :: closing_paren (state) , Rule :: opening_brack =&gt; rules :: opening_brack (state) , Rule :: closing_brack =&gt; rules :: closing_brack (state) , Rule :: modifier =&gt; rules :: modifier (state) , Rule :: silent_modifier =&gt; rules :: silent_modifier (state) , Rule :: atomic_modifier =&gt; rules :: atomic_modifier (state) , Rule :: compound_atomic_modifier =&gt; rules :: compound_atomic_modifier (state) , Rule :: non_atomic_modifier =&gt; rules :: non_atomic_modifier (state) , Rule :: expression =&gt; rules :: expression (state) , Rule :: term =&gt; rules :: term (state) , Rule :: node =&gt; rules :: node (state) , Rule :: terminal =&gt; rules :: terminal (state) , Rule :: prefix_operator =&gt; rules :: prefix_operator (state) , Rule :: infix_operator =&gt; rules :: infix_operator (state) , Rule :: postfix_operator =&gt; rules :: postfix_operator (state) , Rule :: positive_predicate_operator =&gt; rules :: positive_predicate_operator (state) , Rule :: negative_predicate_operator =&gt; rules :: negative_predicate_operator (state) , Rule :: sequence_operator =&gt; rules :: sequence_operator (state) , Rule :: choice_operator =&gt; rules :: choice_operator (state) , Rule :: optional_operator =&gt; rules :: optional_operator (state) , Rule :: repeat_operator =&gt; rules :: repeat_operator (state) , Rule :: repeat_once_operator =&gt; rules :: repeat_once_operator (state) , Rule :: repeat_exact =&gt; rules :: repeat_exact (state) , Rule :: repeat_min =&gt; rules :: repeat_min (state) , Rule :: repeat_max =&gt; rules :: repeat_max (state) , Rule :: repeat_min_max =&gt; rules :: repeat_min_max (state) , Rule :: number =&gt; rules :: number (state) , Rule :: integer =&gt; rules :: integer (state) , Rule :: comma =&gt; rules :: comma (state) , Rule :: _push =&gt; rules :: _push (state) , Rule :: peek_slice =&gt; rules :: peek_slice (state) , Rule :: identifier =&gt; rules :: identifier (state) , Rule :: alpha =&gt; rules :: alpha (state) , Rule :: alpha_num =&gt; rules :: alpha_num (state) , Rule :: string =&gt; rules :: string (state) , Rule :: insensitive_string =&gt; rules :: insensitive_string (state) , Rule :: range =&gt; rules :: range (state) , Rule :: character =&gt; rules :: character (state) , Rule :: inner_str =&gt; rules :: inner_str (state) , Rule :: inner_chr =&gt; rules :: inner_chr (state) , Rule :: escape =&gt; rules :: escape (state) , Rule :: code =&gt; rules :: code (state) , Rule :: unicode =&gt; rules :: unicode (state) , Rule :: hex_digit =&gt; rules :: hex_digit (state) , Rule :: quote =&gt; rules :: quote (state) , Rule :: single_quote =&gt; rules :: single_quote (state) , Rule :: range_operator =&gt; rules :: range_operator (state) , Rule :: newline =&gt; rules :: newline (state) , Rule :: WHITESPACE =&gt; rules :: WHITESPACE (state) , Rule :: block_comment =&gt; rules :: block_comment (state) , Rule :: COMMENT =&gt; rules :: COMMENT (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }
</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pest_meta" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (afaf3e07a 2023-01-14)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>