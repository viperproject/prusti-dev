<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait describing the interface of a deterministic finite automaton (DFA)."><meta name="keywords" content="rust, rustlang, rust-lang, DFA"><title>DFA in regex_automata - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../regex_automata/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../regex_automata/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">DFA</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.ID">ID</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.is_anchored">is_anchored</a></li><li><a href="#tymethod.is_dead_state">is_dead_state</a></li><li><a href="#tymethod.is_match_or_dead_state">is_match_or_dead_state</a></li><li><a href="#tymethod.is_match_state">is_match_state</a></li><li><a href="#tymethod.next_state">next_state</a></li><li><a href="#tymethod.next_state_unchecked">next_state_unchecked</a></li><li><a href="#tymethod.start_state">start_state</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.find">find</a></li><li><a href="#method.find_at">find_at</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rfind_at">rfind_at</a></li><li><a href="#method.shortest_match">shortest_match</a></li><li><a href="#method.shortest_match_at">shortest_match_at</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-DFA-for-%26%27a%20T">&amp;&#39;a T</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In regex_automata</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">regex_automata</a>::<wbr><a class="trait" href="#">DFA</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/regex_automata/dfa.rs.html#19-320">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust trait"><code>pub trait DFA {
    type <a href="#associatedtype.ID" class="associatedtype">ID</a>: <a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>;

<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 15 methods</span></summary>    fn <a href="#tymethod.start_state" class="fn">start_state</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_match_or_dead_state" class="fn">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.is_anchored" class="fn">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;
<span class="item-spacer"></span>    unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>;

    fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.shortest_match" class="fn">shortest_match</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find" class="fn">find</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind" class="fn">rfind</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.shortest_match_at" class="fn">shortest_match_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.find_at" class="fn">find_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.rfind_at" class="fn">rfind_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt; { ... }
</details>}</code></pre></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait describing the interface of a deterministic finite automaton (DFA).</p>
<p>Every DFA has exactly one start state and at least one dead state (which
may be the same, as in the case of an empty DFA). In all cases, a state
identifier of <code>0</code> must be a dead state such that <code>DFA::is_dead_state(0)</code>
always returns <code>true</code>.</p>
<p>Every DFA also has zero or more match states, such that
<code>DFA::is_match_state(id)</code> returns <code>true</code> if and only if <code>id</code> corresponds to
a match state.</p>
<p>In general, users of this trait likely will only need to use the search
routines such as <code>is_match</code>, <code>shortest_match</code>, <code>find</code> or <code>rfind</code>. The other
methods are lower level and are used for walking the transitions of a DFA
manually. In particular, the aforementioned search routines are implemented
generically in terms of the lower level transition walking routines.</p>
</div></details><h2 id="required-associated-types" class="small-section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.ID" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#23">source</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a>: <a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a></h4></section></summary><div class="docblock"><p>The representation used for state identifiers in this DFA.</p>
<p>Typically, this is one of <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> or <code>usize</code>.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.start_state" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#26">source</a><h4 class="code-header">fn <a href="#tymethod.start_state" class="fn">start_state</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section></summary><div class="docblock"><p>Return the identifier of this DFA’s start state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_match_state" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#30">source</a><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a match
state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_dead_state" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#35">source</a><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave and
thus can never lead to a match.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_match_or_dead_state" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#45">source</a><h4 class="code-header">fn <a href="#tymethod.is_match_or_dead_state" class="fn">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given identifier corresponds to either
a dead state or a match state, such that one of <code>is_match_state(id)</code>
or <code>is_dead_state(id)</code> must return true.</p>
<p>Depending on the implementation of the DFA, this routine can be used
to save a branch in the core matching loop. Nevertheless,
<code>is_match_state(id) || is_dead_state(id)</code> is always a valid
implementation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.is_anchored" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#51">source</a><h4 class="code-header">fn <a href="#tymethod.is_anchored" class="fn">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this DFA is anchored.</p>
<p>When a DFA is anchored, it is only allowed to report matches that
start at index <code>0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.next_state" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#56">source</a><h4 class="code-header">fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section></summary><div class="docblock"><p>Given the current state that this DFA is in and the next input byte,
this method returns the identifier of the next state. The identifier
returned is always valid, but it may correspond to a dead state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.next_state_unchecked" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#63-67">source</a><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section></summary><div class="docblock"><p>Like <code>next_state</code>, but its implementation may look up the next state
without memory safety checks such as bounds checks. As such, callers
must ensure that the given identifier corresponds to a valid DFA
state. Implementors must, in turn, ensure that this routine is safe
for all valid state identifiers and for all possible <code>u8</code> values.</p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#91-93">source</a><h4 class="code-header">fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the given bytes match this DFA.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if a DFA enters
a match state or a dead state, then this routine will return <code>true</code> or
<code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{DFA, DenseDFA};

<span class="kw">let </span>dfa = DenseDFA::new(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, dfa.is_match(<span class="string">b&quot;foo12345bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="bool-val">false</span>, dfa.is_match(<span class="string">b&quot;foobar&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shortest_match" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#121-123">source</a><h4 class="code-header">fn <a href="#method.shortest_match" class="fn">shortest_match</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first position at which a match is found.</p>
<p>This routine stops scanning input in precisely the same circumstances
as <code>is_match</code>. The key difference is that this routine returns the
position at which it stopped scanning input if and only if a match
was found. If no match is found, then <code>None</code> is returned.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{DFA, DenseDFA};

<span class="kw">let </span>dfa = DenseDFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), dfa.shortest_match(<span class="string">b&quot;foo12345&quot;</span>));

<span class="comment">// Normally, the end of the leftmost first match here would be 3,
// but the shortest match semantics detect a match earlier.
</span><span class="kw">let </span>dfa = DenseDFA::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), dfa.shortest_match(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#171-173">source</a><h4 class="code-header">fn <a href="#method.find" class="fn">find</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end offset of the longest match. If no match exists,
then <code>None</code> is returned.</p>
<p>Implementors of this trait are not required to implement any particular
match semantics (such as leftmost-first), which are instead manifest in
the DFA’s topology itself.</p>
<p>In particular, this method must continue searching even after it
enters a match state. The search should only terminate once it has
reached the end of the input or when it has entered a dead state. Upon
termination, the position of the last byte seen while still in a match
state is returned.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>. By default, a dense DFA uses
“leftmost first” match semantics.</p>
<p>Leftmost first match semantics corresponds to the match with the
smallest starting offset, but where the end offset is determined by
preferring earlier branches in the original regular expression. For
example, <code>Sam|Samwise</code> will match <code>Sam</code> in <code>Samwise</code>, but <code>Samwise|Sam</code>
will match <code>Samwise</code> in <code>Samwise</code>.</p>
<p>Generally speaking, the “leftmost first” match is how most backtracking
regular expressions tend to work. This is in contrast to POSIX-style
regular expressions that yield “leftmost longest” matches. Namely,
both <code>Sam|Samwise</code> and <code>Samwise|Sam</code> match <code>Samwise</code> when using
leftmost longest semantics.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{DFA, DenseDFA};

<span class="kw">let </span>dfa = DenseDFA::new(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), dfa.find(<span class="string">b&quot;foo12345&quot;</span>));

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the leftmost first match semantics demand that we find the earliest
// match that prefers earlier parts of the pattern over latter parts.
</span><span class="kw">let </span>dfa = DenseDFA::new(<span class="string">&quot;abc|a&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), dfa.find(<span class="string">b&quot;abc&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#199-201">source</a><h4 class="code-header">fn <a href="#method.rfind" class="fn">rfind</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start offset of the longest match in reverse, by searching
from the end of the input towards the start of the input. If no match
exists, then <code>None</code> is returned. In other words, this has the same
match semantics as <code>find</code>, but in reverse.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>This example shows how to use this method with a
<a href="enum.DenseDFA.html"><code>DenseDFA</code></a>. In particular, this routine
is principally useful when used in conjunction with the
<a href="dense/struct.Builder.html#method.reverse"><code>dense::Builder::reverse</code></a>
configuration knob. In general, it’s unlikely to be correct to use both
<code>find</code> and <code>rfind</code> with the same DFA since any particular DFA will only
support searching in one direction.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dense, DFA};

<span class="kw">let </span>dfa = dense::Builder::new().reverse(<span class="bool-val">true</span>).build(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), dfa.rfind(<span class="string">b&quot;foo12345&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_at" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#210-226">source</a><h4 class="code-header">fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns the same as <code>is_match</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shortest_match_at" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#235-255">source</a><h4 class="code-header">fn <a href="#method.shortest_match_at" class="fn">shortest_match_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>shortest_match</code>, but starts the search at the
given offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_at" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#264-287">source</a><h4 class="code-header">fn <a href="#method.find_at" class="fn">find_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>find</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind_at" class="method has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#296-319">source</a><h4 class="code-header">fn <a href="#method.rfind_at" class="fn">rfind_at</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>rfind</code>, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, if the DFA is anchored, then
a match can only occur when <code>start == bytes.len()</code>.</p>
</div></details></div><h2 id="foreign-impls" class="small-section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-%26%27a%20T" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#322-363">source</a><a href="#impl-DFA-for-%26%27a%20T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T:&nbsp;<a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;'a </a>T</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = &lt;T as <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a>&gt;::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section><section id="method.start_state" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#326-328">source</a><a href="#method.start_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.start_state" class="fn">start_state</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section><section id="method.is_match_state" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#331-333">source</a><a href="#method.is_match_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section><section id="method.is_match_or_dead_state" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#336-338">source</a><a href="#method.is_match_or_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_match_or_dead_state" class="fn">is_match_or_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section><section id="method.is_dead_state" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#341-343">source</a><a href="#method.is_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section><section id="method.is_anchored" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#346-348">source</a><a href="#method.is_anchored" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.is_anchored" class="fn">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section><section id="method.next_state" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#351-353">source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section><section id="method.next_state_unchecked" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dfa.rs.html#356-362">source</a><a href="#method.next_state_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>) -&gt; Self::<a class="associatedtype" href="trait.DFA.html#associatedtype.ID" title="type regex_automata::DFA::ID">ID</a></h4></section></div></details><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-DenseDFA%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dense.rs.html#546-662">source</a><a href="#impl-DFA-for-DenseDFA%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[S]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="enum" href="dense/enum.DenseDFA.html" title="enum regex_automata::dense::DenseDFA">DenseDFA</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-ByteClass%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dense.rs.html#735-776">source</a><a href="#impl-DFA-for-ByteClass%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[S]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::dense::<a class="struct" href="dense/struct.ByteClass.html" title="struct regex_automata::dense::ByteClass">ByteClass</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-3" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-Premultiplied%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dense.rs.html#796-835">source</a><a href="#impl-DFA-for-Premultiplied%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[S]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="struct" href="dense/struct.Premultiplied.html" title="struct regex_automata::dense::Premultiplied">Premultiplied</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-4" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-PremultipliedByteClass%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dense.rs.html#849-890">source</a><a href="#impl-DFA-for-PremultipliedByteClass%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[S]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="struct" href="dense/struct.PremultipliedByteClass.html" title="struct regex_automata::dense::PremultipliedByteClass">PremultipliedByteClass</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-5" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-5" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-Standard%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/dense.rs.html#675-714">source</a><a href="#impl-DFA-for-Standard%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[S]</a>&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::dense::<a class="struct" href="dense/struct.Standard.html" title="struct regex_automata::dense::Standard">Standard</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-6" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-6" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-SparseDFA%3CT%2C%20S%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/sparse.rs.html#415-499">source</a><a href="#impl-DFA-for-SparseDFA%3CT%2C%20S%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="enum" href="sparse/enum.SparseDFA.html" title="enum regex_automata::sparse::SparseDFA">SparseDFA</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-7" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-7" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-ByteClass%3CT%2C%20S%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/sparse.rs.html#573-611">source</a><a href="#impl-DFA-for-ByteClass%3CT%2C%20S%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::sparse::<a class="struct" href="sparse/struct.ByteClass.html" title="struct regex_automata::sparse::ByteClass">ByteClass</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-8" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-8" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-DFA-for-Standard%3CT%2C%20S%3E-1" class="impl has-srclink"><a class="srclink rightside" href="../src/regex_automata/sparse.rs.html#512-549">source</a><a href="#impl-DFA-for-Standard%3CT%2C%20S%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>]&gt;, S:&nbsp;<a class="trait" href="trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for regex_automata::sparse::<a class="struct" href="sparse/struct.Standard.html" title="struct regex_automata::sparse::Standard">Standard</a>&lt;T, S&gt;</h3></section></summary><div class="impl-items"><section id="associatedtype.ID-9" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.ID-9" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.ID" class="associatedtype">ID</a> = S</h4></section></div></details></div><script src="../implementors/regex_automata/dfa/trait.DFA.js" async></script></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (afaf3e07a 2023-01-14)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>