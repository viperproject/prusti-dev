<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A multi-producer, single-consumer queue for sending values between asynchronous tasks."><meta name="keywords" content="rust, rustlang, rust-lang, mpsc"><title>tokio::sync::mpsc - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../../../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../tokio/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../tokio/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module mpsc</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">tokio</a>::<wbr><a href="../index.html">sync</a>::<wbr><a class="mod" href="#">mpsc</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/tokio/sync/mpsc/mod.rs.html#1-117">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A multi-producer, single-consumer queue for sending values between
asynchronous tasks.</p>
<p>This module provides two variants of the channel: bounded and unbounded. The
bounded variant has a limit on the number of messages that the channel can
store, and if this limit is reached, trying to send another message will
wait until a message is received from the channel. An unbounded channel has
an infinite capacity, so the <code>send</code> method will always complete immediately.
This makes the <a href="struct.UnboundedSender.html"><code>UnboundedSender</code></a> usable from both synchronous and
asynchronous code.</p>
<p>Similar to the <code>mpsc</code> channels provided by <code>std</code>, the channel constructor
functions provide separate send and receive handles, <a href="struct.Sender.html"><code>Sender</code></a> and
<a href="struct.Receiver.html"><code>Receiver</code></a> for the bounded channel, <a href="struct.UnboundedSender.html"><code>UnboundedSender</code></a> and
<a href="struct.UnboundedReceiver.html"><code>UnboundedReceiver</code></a> for the unbounded channel. If there is no message to read,
the current task will be notified when a new value is sent. <a href="struct.Sender.html"><code>Sender</code></a> and
<a href="struct.UnboundedSender.html"><code>UnboundedSender</code></a> allow sending values into the channel. If the bounded
channel is at capacity, the send is rejected and the task will be notified
when additional capacity is available. In other words, the channel provides
backpressure.</p>
<h2 id="disconnection"><a href="#disconnection">Disconnection</a></h2>
<p>When all <a href="struct.Sender.html"><code>Sender</code></a> handles have been dropped, it is no longer
possible to send values into the channel. This is considered the termination
event of the stream. As such, <code>Receiver::poll</code> returns <code>Ok(Ready(None))</code>.</p>
<p>If the <a href="struct.Receiver.html"><code>Receiver</code></a> handle is dropped, then messages can no longer
be read out of the channel. In this case, all further attempts to send will
result in an error.</p>
<h2 id="clean-shutdown"><a href="#clean-shutdown">Clean Shutdown</a></h2>
<p>When the <a href="struct.Receiver.html"><code>Receiver</code></a> is dropped, it is possible for unprocessed messages to
remain in the channel. Instead, it is usually desirable to perform a “clean”
shutdown. To do this, the receiver first calls <code>close</code>, which will prevent
any further messages to be sent into the channel. Then, the receiver
consumes the channel to completion, at which point the receiver can be
dropped.</p>
<h2 id="communicating-between-sync-and-async-code"><a href="#communicating-between-sync-and-async-code">Communicating between sync and async code</a></h2>
<p>When you want to communicate between synchronous and asynchronous code, there
are two situations to consider:</p>
<p><strong>Bounded channel</strong>: If you need a bounded channel, you should use a bounded
Tokio <code>mpsc</code> channel for both directions of communication. Instead of calling
the async <a href="struct.Sender.html#method.send"><code>send</code></a> or <a href="struct.Receiver.html#method.recv"><code>recv</code></a> methods, in
synchronous code you will need to use the <a href="struct.Sender.html#method.blocking_send"><code>blocking_send</code></a> or
<a href="struct.Receiver.html#method.blocking_recv"><code>blocking_recv</code></a> methods.</p>
<p><strong>Unbounded channel</strong>: You should use the kind of channel that matches where
the receiver is. So for sending a message <em>from async to sync</em>, you should
use <a href="https://doc.rust-lang.org/nightly/std/sync/mpsc/fn.channel.html">the standard library unbounded channel</a> or
<a href="https://docs.rs/crossbeam/*/crossbeam/channel/fn.unbounded.html">crossbeam</a>.  Similarly, for sending a message <em>from sync
to async</em>, you should use an unbounded Tokio <code>mpsc</code> channel.</p>
<p>Please be aware that the above remarks were written with the <code>mpsc</code> channel
in mind, but they can also be generalized to other kinds of channels. In
general, any channel method that isn’t marked async can be called anywhere,
including outside of the runtime. For example, sending a message on a
oneshot channel from outside the runtime is perfectly fine.</p>
<h2 id="multiple-runtimes"><a href="#multiple-runtimes">Multiple runtimes</a></h2>
<p>The mpsc channel does not care about which runtime you use it in, and can be
used to send messages from one runtime to another. It can also be used in
non-Tokio runtimes.</p>
<p>There is one exception to the above: the <a href="struct.Sender.html#method.send_timeout"><code>send_timeout</code></a> must be used from
within a Tokio runtime, however it is still not tied to one specific Tokio
runtime, and the sender may be moved from one Tokio runtime to another.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="error/index.html" title="tokio::sync::mpsc::error mod">error</a></div><div class="item-right docblock-short">Channel error types.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.OwnedPermit.html" title="tokio::sync::mpsc::OwnedPermit struct">OwnedPermit</a></div><div class="item-right docblock-short">Owned permit to send one value into the channel.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Permit.html" title="tokio::sync::mpsc::Permit struct">Permit</a></div><div class="item-right docblock-short">Permits to send one value into the channel.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Receiver.html" title="tokio::sync::mpsc::Receiver struct">Receiver</a></div><div class="item-right docblock-short">Receives values from the associated <code>Sender</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Sender.html" title="tokio::sync::mpsc::Sender struct">Sender</a></div><div class="item-right docblock-short">Sends values to the associated <code>Receiver</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UnboundedReceiver.html" title="tokio::sync::mpsc::UnboundedReceiver struct">UnboundedReceiver</a></div><div class="item-right docblock-short">Receive values from the associated <code>UnboundedSender</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UnboundedSender.html" title="tokio::sync::mpsc::UnboundedSender struct">UnboundedSender</a></div><div class="item-right docblock-short">Send values to the associated <code>UnboundedReceiver</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WeakSender.html" title="tokio::sync::mpsc::WeakSender struct">WeakSender</a></div><div class="item-right docblock-short">A sender that does not prevent the channel from being closed.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.WeakUnboundedSender.html" title="tokio::sync::mpsc::WeakUnboundedSender struct">WeakUnboundedSender</a></div><div class="item-right docblock-short">An unbounded sender that does not prevent the channel from being closed.</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.channel.html" title="tokio::sync::mpsc::channel fn">channel</a></div><div class="item-right docblock-short">Creates a bounded mpsc channel for communicating between asynchronous tasks
with backpressure.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.unbounded_channel.html" title="tokio::sync::mpsc::unbounded_channel fn">unbounded_channel</a></div><div class="item-right docblock-short">Creates an unbounded mpsc channel for communicating between asynchronous
tasks without backpressure.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (afaf3e07a 2023-01-14)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>