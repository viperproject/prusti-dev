<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for acquiring a backtrace at runtime"><meta name="keywords" content="rust, rustlang, rust-lang, backtrace"><title>backtrace - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-52c5db6f6f352e54.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2686a620d99aad7.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../backtrace/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../backtrace/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate backtrace</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.67</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">backtrace</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/backtrace/lib.rs.html#1-193">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library for acquiring a backtrace at runtime</p>
<p>This library is meant to supplement the <code>RUST_BACKTRACE=1</code> support of the
standard library by allowing an acquisition of a backtrace at runtime
programmatically. The backtraces generated by this library do not need to be
parsed, for example, and expose the functionality of multiple backend
implementations.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>First, add this to your Cargo.toml</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
backtrace = &quot;0.3&quot;
</code></pre></div>
<p>Next:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() {
    backtrace::trace(|frame| {
        <span class="kw">let </span>ip = frame.ip();
        <span class="kw">let </span>symbol_address = frame.symbol_address();

        <span class="comment">// Resolve this instruction pointer to a symbol name
        </span>backtrace::resolve_frame(frame, |symbol| {
            <span class="kw">if let </span><span class="prelude-val">Some</span>(name) = symbol.name() {
                <span class="comment">// ...
            </span>}
            <span class="kw">if let </span><span class="prelude-val">Some</span>(filename) = symbol.filename() {
                <span class="comment">// ...
            </span>}
        });

        <span class="bool-val">true </span><span class="comment">// keep going to the next frame
    </span>});
}</code></pre></div>
<h2 id="backtrace-accuracy"><a href="#backtrace-accuracy">Backtrace accuracy</a></h2>
<p>This crate implements best-effort attempts to get the native backtrace. This
is not always guaranteed to work, and some platforms don’t return any
backtrace at all. If your application requires accurate backtraces then it’s
recommended to closely evaluate this crate to see whether it’s suitable
for your use case on your target platforms.</p>
<p>Even on supported platforms, there’s a number of reasons that backtraces may
be less-than-accurate, including but not limited to:</p>
<ul>
<li>
<p>Unwind information may not be available. This crate primarily implements
backtraces by unwinding the stack, but not all functions may have
unwinding information (e.g. DWARF unwinding information).</p>
</li>
<li>
<p>Rust code may be compiled without unwinding information for some
functions. This can also happen for Rust code compiled with
<code>-Cpanic=abort</code>. You can remedy this, however, with
<code>-Cforce-unwind-tables</code> as a compiler option.</p>
</li>
<li>
<p>Unwind information may be inaccurate or corrupt. In the worst case
inaccurate unwind information can lead this library to segfault. In the
best case inaccurate information will result in a truncated stack trace.</p>
</li>
<li>
<p>Backtraces may not report filenames/line numbers correctly due to missing
or corrupt debug information. This won’t lead to segfaults unlike corrupt
unwinding information, but missing or malformed debug information will
mean that filenames and line numbers will not be available. This may be
because debug information wasn’t generated by the compiler, or it’s just
missing on the filesystem.</p>
</li>
<li>
<p>Not all platforms are supported. For example there’s no way to get a
backtrace on WebAssembly at the moment.</p>
</li>
<li>
<p>Crate features may be disabled. Currently this crate supports using Gimli
libbacktrace on non-Windows platforms for reading debuginfo for
backtraces. If both crate features are disabled, however, then these
platforms will generate a backtrace but be unable to generate symbols for
it.</p>
</li>
</ul>
<p>In most standard workflows for most standard platforms you generally don’t
need to worry about these caveats. We’ll try to fix ones where we can over
time, but otherwise it’s important to be aware of the limitations of
unwinding-based backtraces!</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Backtrace.html" title="backtrace::Backtrace struct">Backtrace</a></div><div class="item-right docblock-short">Representation of an owned and self-contained backtrace.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BacktraceFmt.html" title="backtrace::BacktraceFmt struct">BacktraceFmt</a></div><div class="item-right docblock-short">A formatter for backtraces.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BacktraceFrame.html" title="backtrace::BacktraceFrame struct">BacktraceFrame</a></div><div class="item-right docblock-short">Captured version of a frame in a backtrace.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BacktraceFrameFmt.html" title="backtrace::BacktraceFrameFmt struct">BacktraceFrameFmt</a></div><div class="item-right docblock-short">A formatter for just one frame of a backtrace.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BacktraceSymbol.html" title="backtrace::BacktraceSymbol struct">BacktraceSymbol</a></div><div class="item-right docblock-short">Captured version of a symbol in a backtrace.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Frame.html" title="backtrace::Frame struct">Frame</a></div><div class="item-right docblock-short">A trait representing one frame of a backtrace, yielded to the <code>trace</code>
function of this crate.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Symbol.html" title="backtrace::Symbol struct">Symbol</a></div><div class="item-right docblock-short">A trait representing the resolution of a symbol in a file.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SymbolName.html" title="backtrace::SymbolName struct">SymbolName</a></div><div class="item-right docblock-short">A wrapper around a symbol name to provide ergonomic accessors to the
demangled name, the raw bytes, the raw string, etc.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BytesOrWideString.html" title="backtrace::BytesOrWideString enum">BytesOrWideString</a></div><div class="item-right docblock-short">A platform independent representation of a string. When working with <code>std</code>
enabled it is recommended to the convenience methods for providing
conversions to <code>std</code> types.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.PrintFmt.html" title="backtrace::PrintFmt enum">PrintFmt</a></div><div class="item-right docblock-short">The styles of printing that we can print</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.clear_symbol_cache.html" title="backtrace::clear_symbol_cache fn">clear_symbol_cache</a></div><div class="item-right docblock-short">Attempt to reclaim that cached memory used to symbolicate addresses.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.resolve.html" title="backtrace::resolve fn">resolve</a></div><div class="item-right docblock-short">Resolve an address to a symbol, passing the symbol to the specified
closure.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.resolve_frame.html" title="backtrace::resolve_frame fn">resolve_frame</a></div><div class="item-right docblock-short">Resolve a previously capture frame to a symbol, passing the symbol to the
specified closure.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.resolve_frame_unsynchronized.html" title="backtrace::resolve_frame_unsynchronized fn">resolve_frame_unsynchronized</a><sup title="unsafe function">⚠</sup></div><div class="item-right docblock-short">Same as <code>resolve_frame</code>, only unsafe as it’s unsynchronized.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.resolve_unsynchronized.html" title="backtrace::resolve_unsynchronized fn">resolve_unsynchronized</a><sup title="unsafe function">⚠</sup></div><div class="item-right docblock-short">Same as <code>resolve</code>, only unsafe as it’s unsynchronized.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.trace.html" title="backtrace::trace fn">trace</a></div><div class="item-right docblock-short">Inspects the current call-stack, passing all active frames into the closure
provided to calculate a stack trace.</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.trace_unsynchronized.html" title="backtrace::trace_unsynchronized fn">trace_unsynchronized</a><sup title="unsafe function">⚠</sup></div><div class="item-right docblock-short">Same as <code>trace</code>, only unsafe as it’s unsynchronized.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="backtrace" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-nightly (afaf3e07a 2023-01-14)" data-search-js="search-181581080540673f.js" data-settings-js="settings-a2afdefbb7c817f1.js" data-settings-css="settings-84508a86fe805444.css" ></div></body></html>