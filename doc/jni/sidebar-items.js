window.SIDEBAR_ITEMS = {"constant":[["DEFAULT_LOCAL_FRAME_CAPACITY","The capacity of local frames, allocated for attached threads by default. Same as the default value Hotspot uses when calling native Java methods."]],"enum":[["JNIVersion","JNI Version"],["JvmError","Errors that can occur when invoking a `JavaVM` with the Invocation API."]],"mod":[["descriptors","Descriptors for classes and method IDs."],["errors","Errors. Do you really need more explanation?"],["objects","Wrappers for object pointers returned from the JVM."],["signature","Parser for java type signatures."],["strings","String types for going to/from java strings."],["sys","`jni-sys` re-exports"]],"struct":[["AttachGuard","A RAII implementation of scoped guard which detaches the current thread when dropped. The attached `JNIEnv` can be accessed through this guard via its `Deref` implementation."],["Executor","Thread attachment manager. It allows to execute closures in attached threads with automatic local references management done with `with_local_frame`. It combines the performance benefits of permanent attaches whilst removing the risk of local references leaks if used consistently."],["InitArgs","JavaVM InitArgs."],["InitArgsBuilder","Builder for JavaVM InitArgs."],["JNIEnv","FFI-compatible JNIEnv struct. You can safely use this as the JNIEnv argument to exported methods that will be called by java. This is where most of the magic happens. All methods on this object are wrappers around JNI functions, so the documentation on their behavior is still pretty applicable."],["JavaVM","The Java VM, providing Invocation API support."],["MonitorGuard","Guard for a lock on a java object. This gets returned from the `lock_obj` method."],["NativeMethod","Native method descriptor."]]};