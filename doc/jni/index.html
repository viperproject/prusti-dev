<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Safe JNI Bindings in Rust"><meta name="keywords" content="rust, rustlang, rust-lang, jni"><title>jni - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-3d4cb87af9468701.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-1469fca9efc07bcb.css"><link rel="stylesheet" disabled href="../static.files/dark-e9b7e5d8ba0dc980.css"><link rel="stylesheet" disabled href="../static.files/ayu-0c1cf144240c9f40.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-799a64abec831f72.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../jni/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../jni/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate jni</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.20.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">jni</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/jni/lib.rs.html#1-231">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="safe-jni-bindings-in-rust"><a href="#safe-jni-bindings-in-rust">Safe JNI Bindings in Rust</a></h2>
<p>This crate provides a (mostly) safe way to implement methods in Java using
the JNI. Because who wants to <em>actually</em> write Java?</p>
<h3 id="getting-started"><a href="#getting-started">Getting Started</a></h3>
<p>Naturally, any ffi-related project is going to require some code in both
languages that we’re trying to make communicate. Java requires all native
methods to adhere to the Java Native Interface (JNI), so we first have to
define our function signature from Java, and then we can write Rust that
will adhere to it.</p>
<h4 id="the-java-side"><a href="#the-java-side">The Java side</a></h4>
<p>First, you need a Java class definition. <code>HelloWorld.java</code>:</p>
<div class="example-wrap"><pre class="language-java"><code>class HelloWorld {
    // This declares that the static `hello` method will be provided
    // a native library.
    private static native String hello(String input);

    static {
        // This actually loads the shared object that we&#39;ll be creating.
        // The actual location of the .so or .dll may differ based on your
        // platform.
        System.loadLibrary(&quot;mylib&quot;);
    }

    // The rest is just regular ol&#39; Java!
    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;josh&quot;);
        System.out.println(output);
    }
}</code></pre></div>
<p>Compile this to a class file with <code>javac HelloWorld.java</code>.</p>
<p>Trying to run it now will give us the error <code>Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no mylib in java.library.path</code> since we
haven’t written our native code yet.</p>
<p>To do that, first we need the name and type signature that our Rust function
needs to adhere to. Luckily, the Java compiler can generate that for you!
Run <code>javac -h . HelloWorld.java</code> and you’ll get a <code>HelloWorld.h</code> output to your
directory. It should look something like this:</p>
<div class="example-wrap"><pre class="language-c"><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class HelloWorld */

#ifndef _Included_HelloWorld
#define _Included_HelloWorld
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     HelloWorld
 * Method:    hello
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_HelloWorld_hello
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif</code></pre></div>
<p>It’s a C header, but luckily for us, the types will mostly match up. Let’s
make our crate that’s going to compile to our native library.</p>
<h4 id="the-rust-side"><a href="#the-rust-side">The Rust side</a></h4>
<p>Create your crate with <code>cargo new mylib</code>. This will create a directory
<code>mylib</code> that has everything needed to build an basic crate with <code>cargo</code>. We
need to make a couple of changes to <code>Cargo.toml</code> before we do anything else.</p>
<ul>
<li>Under <code>[dependencies]</code>, add <code>jni = &quot;0.20.0&quot;</code></li>
<li>Add a new <code>[lib]</code> section and under it, <code>crate_type = [&quot;cdylib&quot;]</code>.</li>
</ul>
<p>Now, if you run <code>cargo build</code> from inside the crate directory, you should
see a <code>libmylib.so</code> (if you’re on linux) or a <code>libmylib.dylib</code> (if you are on OSX) in the <code>target/debug</code>
directory.</p>
<p>The last thing we need to do is to define our exported method. Add this to
your crate’s <code>src/lib.rs</code>:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="comment">// This is the interface to the JVM that we&#39;ll call the majority of our
// methods on.
</span><span class="kw">use </span>jni::JNIEnv;

<span class="comment">// These objects are what you should use as arguments to your native
// function. They carry extra lifetime information to prevent them escaping
// this context and getting used after being GC&#39;d.
</span><span class="kw">use </span>jni::objects::{JClass, JString};

<span class="comment">// This is just a pointer. We&#39;ll be returning it from our function. We
// can&#39;t return one of the objects with lifetime information because the
// lifetime checker won&#39;t let us.
</span><span class="kw">use </span>jni::sys::jstring;

<span class="comment">// This keeps Rust from &quot;mangling&quot; the name and making it unique for this
// crate.
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">&quot;system&quot; </span><span class="kw">fn </span>Java_HelloWorld_hello(env: JNIEnv,
<span class="comment">// This is the class that owns our static method. It&#39;s not going to be used,
// but still must be present to match the expected signature of a static
// native method.
                                             </span>class: JClass,
                                             input: JString)
                                             -&gt; jstring {
    <span class="comment">// First, we have to get the string out of Java. Check out the `strings`
    // module for more info on how this works.
    </span><span class="kw">let </span>input: String =
        env.get_string(input).expect(<span class="string">&quot;Couldn&#39;t get java string!&quot;</span>).into();

    <span class="comment">// Then we have to create a new Java string to return. Again, more info
    // in the `strings` module.
    </span><span class="kw">let </span>output = env.new_string(<span class="macro">format!</span>(<span class="string">&quot;Hello, {}!&quot;</span>, input))
        .expect(<span class="string">&quot;Couldn&#39;t create java string!&quot;</span>);

    <span class="comment">// Finally, extract the raw pointer to return.
    </span>output.into_inner()
}</code></pre></div>
<p>Note that the type signature for our function is almost identical to the one
from the generated header, aside from our lifetime-carrying arguments.</p>
<h4 id="final-steps"><a href="#final-steps">Final steps</a></h4>
<p>That’s it! Build your crate and try to run your Java class again.</p>
<p>… Same error as before you say? Well that’s because JVM is looking for
<code>mylib</code> in all the wrong places. This will differ by platform thanks to
different linker/loader semantics, but on Linux, you can simply <code>export LD_LIBRARY_PATH=/path/to/mylib/target/debug</code>. Now, you should get the
expected output <code>Hello, josh!</code> from your Java class.</p>
<h3 id="launching-jvm-from-rust"><a href="#launching-jvm-from-rust">Launching JVM from Rust</a></h3>
<p>It is possible to launch a JVM from a native process using the <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/invocation.html">Invocation API</a>, provided
by <a href="struct.JavaVM.html"><code>JavaVM</code></a>.</p>
<h3 id="see-also"><a href="#see-also">See Also</a></h3><h4 id="examples"><a href="#examples">Examples</a></h4>
<ul>
<li><a href="https://github.com/jni-rs/jni-rs/tree/master/example">Example project</a></li>
<li>Our <a href="https://github.com/jni-rs/jni-rs/tree/master/tests">integration tests</a> and <a href="https://github.com/jni-rs/jni-rs/tree/master/benches">benchmarks</a></li>
</ul>
<h4 id="jni-documentation"><a href="#jni-documentation">JNI Documentation</a></h4>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html">Java Native Interface Specification</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a> — general tips on JNI development and some Android-specific</li>
</ul>
<h4 id="open-source-users"><a href="#open-source-users">Open-Source Users</a></h4>
<ul>
<li>The Servo browser engine Android <a href="https://github.com/servo/servo/tree/master/ports/libsimpleservo">port</a></li>
<li>The Exonum framework <a href="https://github.com/exonum/exonum-java-binding/tree/master/exonum-java-binding/core/rust">Java Binding</a></li>
<li>MaidSafe <a href="https://github.com/maidsafe/safe_client_libs/tree/master/safe_app_jni">Java Binding</a></li>
</ul>
<h4 id="other-projects-simplifying-java-and-rust-communication"><a href="#other-projects-simplifying-java-and-rust-communication">Other Projects Simplifying Java and Rust Communication</a></h4>
<ul>
<li>Consider <a href="https://github.com/jnr/jnr-ffi/">JNR</a> if you just need to use a native library with C interface</li>
<li>Watch OpenJDK <a href="https://jdk.java.net/panama/">Project Panama</a> which aims to enable using native libraries
with no JNI code</li>
<li>Consider <a href="http://www.graalvm.org/docs/why-graal/#for-java-programs">GraalVM</a> — a recently released VM that gives zero-cost
interoperability between various languages (including Java and <a href="http://www.graalvm.org/docs/reference-manual/languages/llvm/#running-rust">Rust</a> compiled
into LLVM-bitcode)</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="descriptors/index.html" title="jni::descriptors mod">descriptors</a></div><div class="item-right docblock-short">Descriptors for classes and method IDs.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="errors/index.html" title="jni::errors mod">errors</a></div><div class="item-right docblock-short">Errors. Do you really need more explanation?</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="objects/index.html" title="jni::objects mod">objects</a></div><div class="item-right docblock-short">Wrappers for object pointers returned from the JVM.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="signature/index.html" title="jni::signature mod">signature</a></div><div class="item-right docblock-short">Parser for java type signatures.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="strings/index.html" title="jni::strings mod">strings</a></div><div class="item-right docblock-short">String types for going to/from java strings.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="sys/index.html" title="jni::sys mod">sys</a></div><div class="item-right docblock-short"><code>jni-sys</code> re-exports</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AttachGuard.html" title="jni::AttachGuard struct">AttachGuard</a></div><div class="item-right docblock-short">A RAII implementation of scoped guard which detaches the current thread
when dropped. The attached <code>JNIEnv</code> can be accessed through this guard
via its <code>Deref</code> implementation.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Executor.html" title="jni::Executor struct">Executor</a></div><div class="item-right docblock-short">Thread attachment manager. It allows to execute closures in attached threads with automatic
local references management done with <code>with_local_frame</code>. It combines the performance benefits
of permanent attaches whilst removing the risk of local references leaks if used consistently.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InitArgs.html" title="jni::InitArgs struct">InitArgs</a></div><div class="item-right docblock-short">JavaVM InitArgs.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.InitArgsBuilder.html" title="jni::InitArgsBuilder struct">InitArgsBuilder</a></div><div class="item-right docblock-short">Builder for JavaVM InitArgs.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.JNIEnv.html" title="jni::JNIEnv struct">JNIEnv</a></div><div class="item-right docblock-short">FFI-compatible JNIEnv struct. You can safely use this as the JNIEnv argument
to exported methods that will be called by java. This is where most of the
magic happens. All methods on this object are wrappers around JNI functions,
so the documentation on their behavior is still pretty applicable.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.JavaVM.html" title="jni::JavaVM struct">JavaVM</a></div><div class="item-right docblock-short">The Java VM, providing <a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jni/invocation.html">Invocation API</a> support.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MonitorGuard.html" title="jni::MonitorGuard struct">MonitorGuard</a></div><div class="item-right docblock-short">Guard for a lock on a java object. This gets returned from the <code>lock_obj</code>
method.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NativeMethod.html" title="jni::NativeMethod struct">NativeMethod</a></div><div class="item-right docblock-short">Native method descriptor.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.JNIVersion.html" title="jni::JNIVersion enum">JNIVersion</a></div><div class="item-right docblock-short">JNI Version</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.JvmError.html" title="jni::JvmError enum">JvmError</a></div><div class="item-right docblock-short">Errors that can occur when invoking a <a href="struct.JavaVM.html"><code>JavaVM</code></a> with the
<a href="https://docs.oracle.com/en/java/javase/12/docs/specs/jni/invocation.html">Invocation API</a>.</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.DEFAULT_LOCAL_FRAME_CAPACITY.html" title="jni::DEFAULT_LOCAL_FRAME_CAPACITY constant">DEFAULT_LOCAL_FRAME_CAPACITY</a></div><div class="item-right docblock-short">The capacity of local frames, allocated for attached threads by default. Same as the default
value Hotspot uses when calling native Java methods.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="jni" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (96ddd32c4 2022-11-14)" data-search-js="search-39ee4160c7dc16c9.js" data-settings-js="settings-7873449fa8c00e11.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>